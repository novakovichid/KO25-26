<!doctype html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22%3E%3Ctext y=%22.9em%22 font-size=%2290%22%3E%F0%9F%A7%91%E2%80%8D%F0%9F%94%AC%3C/text%3E%3C/svg%3E">
  <title>–≠–º–æ–¥–∑–∏-—Ä–æ–±–æ—Ç</title>
  <script src="../section-auth.js"></script>
  <script>window.SectionAuth && window.SectionAuth.guardPage("LOVELACE", { requiredProfile: "ROBOT" });</script>
  <style>
    @font-face {
      font-family: "Noto Color Emoji";
      font-style: normal;
      font-weight: 400;
      font-display: swap;
      src:
        url("https://cdn.jsdelivr.net/fontsource/fonts/noto-color-emoji@latest/emoji-400-normal.woff2") format("woff2"),
        url("https://cdn.jsdelivr.net/fontsource/fonts/noto-color-emoji@latest/emoji-400-normal.ttf") format("truetype");
    }

    :root {
      --bg: #f3f4f6;
      --panel: #ffffff;
      --text: #111827;
      --muted: #6b7280;
      --border: #d1d5db;
      --accent: #2563eb;
      --accent-strong: #1d4ed8;
      --danger-bg: #fee2e2;
      --danger-fg: #991b1b;
      --ok-bg: #dcfce7;
      --ok-fg: #166534;
      --warn-bg: #fef3c7;
      --warn-fg: #92400e;
      --emoji-font: "Noto Color Emoji", "Twemoji Mozilla", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Sans", "Segoe UI", sans-serif;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at 20% 0%, #ffffff, var(--bg));
      color: var(--text);
      font-family: "Segoe UI", "Noto Sans", sans-serif;
      padding: 20px;
    }

    .app {
      width: min(1320px, 100%);
      margin: 0 auto;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 18px;
      padding: 16px;
      box-shadow: 0 14px 30px rgba(17, 24, 39, 0.09);
      display: grid;
      gap: 12px;
    }

    .topbar {
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
    }

    .title {
      margin: 0;
      font-size: clamp(1.35rem, 2vw, 1.8rem);
      font-weight: 900;
      letter-spacing: -0.02em;
    }

    .back-link {
      text-decoration: none;
      border: 1px solid var(--border);
      border-radius: 10px;
      color: var(--text);
      background: #fff;
      padding: 8px 12px;
      font-weight: 700;
      transition: 120ms ease;
    }

    .back-link:hover {
      border-color: #9ca3af;
      transform: translateY(-1px);
    }

    .blocks {
      display: grid;
      gap: 12px;
    }

    .panel {
      border: 1px solid var(--border);
      border-radius: 14px;
      background: #fcfcfd;
      padding: 12px;
      display: grid;
      gap: 10px;
    }

    .panel[hidden] {
      display: none !important;
    }

    h2 {
      margin: 0;
      font-size: 1rem;
      font-weight: 800;
    }

    .block-title {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .block-num {
      width: 24px;
      height: 24px;
      border-radius: 999px;
      display: inline-grid;
      place-items: center;
      font-size: 12px;
      font-weight: 900;
      background: #dbeafe;
      color: #1d4ed8;
      border: 1px solid #93c5fd;
      flex: 0 0 auto;
    }

    .switchers {
      display: grid;
      gap: 10px;
      grid-template-columns: 1fr 1fr;
    }

    .mini-title {
      font-size: 12px;
      font-weight: 800;
      letter-spacing: 0.02em;
      text-transform: uppercase;
      color: #475569;
      margin-bottom: 6px;
    }

    label {
      font-weight: 700;
      font-size: 14px;
    }

    textarea {
      width: 100%;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #fff;
      color: var(--text);
      padding: 10px 12px;
      outline: none;
      transition: 120ms ease;
      resize: vertical;
    }

    .text-input {
      width: 100%;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #fff;
      color: var(--text);
      padding: 10px 12px;
      outline: none;
      transition: 120ms ease;
      font: inherit;
    }

    .text-input:focus {
      border-color: #3b82f6;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
    }

    textarea:focus {
      border-color: #3b82f6;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
    }

    .emoji-field {
      font-family: var(--emoji-font);
      font-size: 18px;
      line-height: 1.45;
    }

    .code-editor {
      display: grid;
      grid-template-columns: auto 1fr;
      border: 1px solid var(--border);
      border-radius: 10px;
      overflow: hidden;
      background: #fff;
    }

    .code-editor:focus-within {
      border-color: #3b82f6;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
    }

    .code-lines {
      width: 84px;
      min-width: 84px;
      border: none;
      border-right: 1px solid #e5e7eb;
      border-radius: 0;
      background: #f8fafc;
      color: #64748b;
      text-align: right;
      resize: none;
      overflow: hidden;
      padding: 10px 8px;
      letter-spacing: 0;
      word-spacing: 0;
      font-variant-ligatures: none;
      user-select: none;
      pointer-events: none;
    }

    .code-lines:focus {
      box-shadow: none;
      border-color: #e5e7eb;
    }

    .code-input {
      min-height: 320px;
      border: none;
      border-radius: 0;
      background: transparent;
    }

    .code-input:focus {
      border-color: transparent;
      box-shadow: none;
    }

    .stdin-input {
      min-height: 84px;
      font-family: "Noto Sans", "Segoe UI", "Noto Color Emoji", "Twemoji Mozilla", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", sans-serif;
      font-size: 18px;
      line-height: 1.35;
      letter-spacing: 0;
      word-spacing: 0;
      font-variant-ligatures: none;
    }

    .output-box {
      min-height: 140px;
      font-family: "Noto Sans", "Segoe UI", "Noto Color Emoji", "Twemoji Mozilla", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", sans-serif;
      font-size: 18px;
      line-height: 1.35;
      letter-spacing: 0;
      word-spacing: 0;
      font-variant-ligatures: none;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .examples {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .task-grid,
    .subtask-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .subtask-grid {
      margin-top: 8px;
      min-height: 40px;
    }

    .subtask-grid[hidden] {
      display: none !important;
    }

    .task-text-wrap[hidden] {
      display: none !important;
    }

    .task-text-wrap {
      margin-top: 8px;
      display: grid;
      gap: 6px;
    }

    .task-text-label {
      font-size: 14px;
      font-weight: 700;
    }

    .task-text {
      min-height: 72px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #fff;
      padding: 10px 12px;
      font-size: 16px;
      line-height: 1.35;
      letter-spacing: 0;
      word-spacing: 0;
      font-variant-ligatures: none;
    }

    .task-text p {
      margin: 0;
    }

    .task-text p + p {
      margin-top: 6px;
    }

    .scenario-wrap {
      display: grid;
      gap: 10px;
    }

    .scenario-tools {
      display: flex;
      justify-content: flex-end;
      align-items: center;
    }

    .scenario-toggle {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      font-weight: 700;
      color: #1f2937;
      user-select: none;
      cursor: pointer;
    }

    .scenario-toggle input {
      width: 16px;
      height: 16px;
      accent-color: var(--accent);
      cursor: pointer;
      margin: 0;
    }

    .scenario-meta {
      font-size: 13px;
      font-weight: 700;
      color: #334155;
      min-height: 18px;
    }

    .scenario-board {
      border: 1px solid #dbeafe;
      border-radius: 10px;
      background: #f8fafc;
      padding: 10px;
      min-height: 150px;
      overflow: hidden;
      display: grid;
      gap: 10px;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      align-items: start;
    }

    .scenario-card {
      border: 1px solid #cbd5e1;
      border-radius: 10px;
      background: #ffffff;
      padding: 8px;
      display: grid;
      gap: 8px;
      min-width: 0;
    }

    .scenario-card-meta {
      font-size: 12px;
      font-weight: 700;
      color: #334155;
      min-height: 16px;
    }

    .scenario-card-board {
      min-height: 70px;
      overflow: hidden;
      padding-bottom: 2px;
    }

    .scenario-grid {
      display: grid;
      --scenario-unit: 38px;
      --scenario-gap: 4px;
      gap: var(--scenario-gap);
      width: fit-content;
      max-width: 100%;
    }

    .scenario-axis {
      width: var(--scenario-unit);
      height: var(--scenario-unit);
      border: 1px dashed #cbd5e1;
      border-radius: 8px;
      background: #f1f5f9;
      display: grid;
      place-items: center;
      font-family: var(--emoji-font);
      font-size: clamp(8px, calc(var(--scenario-unit) * 0.42), 15px);
      line-height: 1;
      color: #334155;
      user-select: none;
    }

    .scenario-axis.corner {
      border-style: solid;
      background: #e2e8f0;
      font-family: "Segoe UI", "Noto Sans", sans-serif;
      font-size: clamp(7px, calc(var(--scenario-unit) * 0.26), 10px);
      font-weight: 800;
      letter-spacing: 0.02em;
      line-height: 1.15;
      white-space: pre-line;
      text-align: center;
    }

    .scenario-cell {
      width: var(--scenario-unit);
      height: var(--scenario-unit);
      border: 1px solid #cbd5e1;
      border-radius: 8px;
      background: #ffffff;
      position: relative;
      display: grid;
      place-items: center;
      font-family: var(--emoji-font);
      font-size: clamp(9px, calc(var(--scenario-unit) * 0.48), 18px);
      line-height: 1;
    }

    .scenario-cell.color-red { background: #fee2e2; }
    .scenario-cell.color-yellow { background: #fef9c3; }
    .scenario-cell.color-green { background: #dcfce7; }
    .scenario-cell.color-purple { background: #f3e8ff; }

    .scenario-cell.blocked {
      background: #e5e7eb;
      border-color: #94a3b8;
      color: #334155;
      font-size: 17px;
    }

    .scenario-cell.finish {
      box-shadow: inset 0 0 0 2px #2563eb;
    }

    .scenario-marker {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      pointer-events: none;
      font-family: var(--emoji-font);
      font-size: clamp(9px, calc(var(--scenario-unit) * 0.48), 18px);
      line-height: 1;
    }

    .scenario-marker.start {
      font-size: clamp(7px, calc(var(--scenario-unit) * 0.32), 12px);
      font-weight: 900;
      color: #0f172a;
      font-family: "Segoe UI", "Noto Sans", sans-serif;
      place-items: start;
      padding-top: max(1px, calc(var(--scenario-unit) * 0.06));
      padding-left: max(1px, calc(var(--scenario-unit) * 0.1));
      justify-items: start;
      align-items: start;
    }

    .scenario-marker.finish {
      font-size: clamp(7px, calc(var(--scenario-unit) * 0.32), 12px);
      font-weight: 900;
      color: #1d4ed8;
      font-family: "Segoe UI", "Noto Sans", sans-serif;
      place-items: end;
      padding-bottom: max(1px, calc(var(--scenario-unit) * 0.06));
      padding-right: max(1px, calc(var(--scenario-unit) * 0.1));
      justify-items: end;
      align-items: end;
    }

    .scenario-temp {
      position: absolute;
      right: max(1px, calc(var(--scenario-unit) * 0.06));
      top: max(1px, calc(var(--scenario-unit) * 0.05));
      font-family: "Segoe UI", "Noto Sans", sans-serif;
      font-size: clamp(6px, calc(var(--scenario-unit) * 0.24), 10px);
      font-weight: 800;
      color: #475569;
      line-height: 1;
      pointer-events: none;
    }

    .scenario-control {
      position: absolute;
      left: max(1px, calc(var(--scenario-unit) * 0.06));
      bottom: max(1px, calc(var(--scenario-unit) * 0.06));
      width: clamp(6px, calc(var(--scenario-unit) * 0.32), 12px);
      height: clamp(6px, calc(var(--scenario-unit) * 0.32), 12px);
      border-radius: 999px;
      border: 1px solid rgba(15, 23, 42, 0.35);
      background: #94a3b8;
      color: #ffffff;
      display: grid;
      place-items: center;
      font-family: "Segoe UI", "Noto Sans", sans-serif;
      font-size: clamp(5px, calc(var(--scenario-unit) * 0.2), 8px);
      font-weight: 900;
      line-height: 1;
      pointer-events: none;
      z-index: 1;
    }

    .scenario-control.color-red { background: #ef4444; }
    .scenario-control.color-yellow { background: #f59e0b; }
    .scenario-control.color-green { background: #22c55e; }
    .scenario-control.color-purple { background: #a855f7; }

    .scenario-legend {
      display: flex;
      flex-wrap: wrap;
      gap: 8px 14px;
      align-items: center;
      font-size: 12px;
      font-weight: 700;
      color: #334155;
    }

    .legend-item {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .legend-chip {
      width: 16px;
      height: 16px;
      border-radius: 4px;
      border: 1px solid #94a3b8;
      display: inline-grid;
      place-items: center;
      font-size: 12px;
      line-height: 1;
      font-family: var(--emoji-font);
    }

    .legend-chip.red { background: #fee2e2; }
    .legend-chip.yellow { background: #fef9c3; }
    .legend-chip.green { background: #dcfce7; }
    .legend-chip.purple { background: #f3e8ff; }
    .legend-chip.blocked { background: #e5e7eb; }

    .scenario-error {
      color: #991b1b;
      font-weight: 700;
      font-size: 14px;
      padding: 8px;
      border: 1px dashed #fca5a5;
      border-radius: 8px;
      background: #fef2f2;
      width: fit-content;
    }

    .test-label {
      font-size: 13px;
      font-weight: 800;
      color: #334155;
    }

    .test-output-grid {
      display: grid;
      gap: 10px;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
    }

    .test-output-card {
      border: 1px solid #e5e7eb;
      border-radius: 10px;
      background: #ffffff;
      padding: 10px;
      display: grid;
      gap: 8px;
    }

    .test-output-card.ok {
      border-color: #86efac;
      background: #f0fdf4;
    }

    .test-output-card.error {
      border-color: #fca5a5;
      background: #fef2f2;
    }

    .test-output-card.warn {
      border-color: #fcd34d;
      background: #fffbeb;
    }

    .test-output-meta {
      font-size: 12px;
      font-weight: 700;
      color: #475569;
    }

    button {
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #fff;
      color: var(--text);
      font: inherit;
      font-weight: 700;
      padding: 9px 12px;
      cursor: pointer;
      transition: 120ms ease;
    }

    button:hover {
      border-color: #9ca3af;
      transform: translateY(-1px);
    }

    button:disabled {
      opacity: 0.65;
      cursor: not-allowed;
      transform: none;
    }

    .switchers button[aria-pressed="true"] {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2);
    }

    .switchers button[aria-pressed="true"]:hover {
      background: var(--accent-strong);
      border-color: var(--accent-strong);
    }

    button.primary {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
    }

    button.primary:hover {
      background: var(--accent-strong);
      border-color: var(--accent-strong);
    }

    .status-box {
      border-radius: 10px;
      border: 1px solid var(--border);
      padding: 10px 12px;
      font-weight: 700;
      background: #f3f4f6;
      color: #1f2937;
      min-height: 44px;
      display: flex;
      align-items: center;
    }

    .status-box.ok {
      background: var(--ok-bg);
      color: var(--ok-fg);
      border-color: #86efac;
    }

    .status-box.error {
      background: var(--danger-bg);
      color: var(--danger-fg);
      border-color: #fca5a5;
    }

    .status-box.warn {
      background: var(--warn-bg);
      color: var(--warn-fg);
      border-color: #fcd34d;
    }

    .step-count {
      font-weight: 700;
      color: #1f2937;
      font-size: 14px;
    }

    .keyboard {
      display: grid;
      gap: 10px;
    }

    .keyboard-layout {
      display: grid;
      grid-template-columns: minmax(0, 1fr) 220px;
      gap: 10px;
      align-items: start;
    }

    .keyboard-left {
      display: grid;
      gap: 10px;
      min-width: 0;
    }

    .emoji-group {
      border: 1px solid #e5e7eb;
      border-radius: 10px;
      background: #fff;
      padding: 10px;
    }

    .emoji-group.group-1 { background: linear-gradient(180deg, #ffffff, #f8fafc); }
    .emoji-group.group-2 { background: linear-gradient(180deg, #ffffff, #f9fafb); }
    .emoji-group.group-3 { background: linear-gradient(180deg, #ffffff, #eff6ff); }

    .emoji-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(40px, 1fr));
      gap: 6px;
    }

    .emoji-btn {
      font-family: var(--emoji-font);
      font-size: 22px;
      line-height: 1;
      padding: 8px 6px;
      min-height: 40px;
      display: grid;
      place-items: center;
    }

    .editor-nav {
      border: 1px solid #d1d5db;
      border-radius: 10px;
      background: linear-gradient(180deg, #ffffff, #f8fafc);
      padding: 10px;
      display: grid;
      gap: 8px;
    }

    .nav-title {
      margin: 0;
      font-size: 12px;
      font-weight: 800;
      text-transform: uppercase;
      letter-spacing: 0.02em;
      color: #475569;
    }

    .nav-arrows {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      grid-template-areas:
        ". up ."
        "left down right";
      gap: 6px;
    }

    .nav-actions {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 6px;
    }

    .nav-btn {
      min-height: 42px;
      padding: 7px 8px;
      display: grid;
      place-items: center;
      font-weight: 800;
      border-radius: 10px;
      user-select: none;
    }

    .nav-btn.up { grid-area: up; }
    .nav-btn.left { grid-area: left; }
    .nav-btn.down { grid-area: down; }
    .nav-btn.right { grid-area: right; }
    .nav-btn.enter { grid-column: 1 / -1; }

    .vars-panel[hidden] {
      display: none !important;
    }

    @media (max-width: 1040px) {
      .switchers {
        grid-template-columns: 1fr;
      }

      .keyboard-layout {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <main class="app">
    <header class="topbar">
      <h1 class="title">–≠–º–æ–¥–∑–∏-—Ä–æ–±–æ—Ç</h1>
      <a href="../index.html" class="back-link">–ù–∞ –≥–ª–∞–≤–Ω—É—é</a>
    </header>

    <section class="blocks">
      <section class="panel">
        <h2 class="block-title"><span class="block-num">0</span>–ü—Ä–∏–º–µ—Ä—ã –∏ –ó–∞–¥–∞–Ω–∏—è</h2>
        <div class="switchers">
          <section>
            <div class="mini-title">–ü—Ä–∏–º–µ—Ä—ã</div>
            <div class="examples">
              <button id="example1Btn" type="button" aria-pressed="false">–ü—Ä–∏–º–µ—Ä ‚Ññ1</button>
              <button id="example2Btn" type="button" aria-pressed="false">–ü—Ä–∏–º–µ—Ä ‚Ññ2</button>
              <button id="example3Btn" type="button" aria-pressed="false">–ü—Ä–∏–º–µ—Ä ‚Ññ3</button>
              <button id="example4Btn" type="button" aria-pressed="false">–ü—Ä–∏–º–µ—Ä ‚Ññ4</button>
              <button id="example5Btn" type="button" aria-pressed="false">–ü—Ä–∏–º–µ—Ä ‚Ññ5</button>
            </div>
          </section>
          <section>
            <div class="mini-title">–ó–∞–¥–∞–Ω–∏—è</div>
            <div id="taskButtons" class="task-grid">
              <button type="button" data-task="1" aria-pressed="false">–ó–∞–¥–∞–Ω–∏–µ 1</button>
              <button type="button" data-task="2" aria-pressed="false">–ó–∞–¥–∞–Ω–∏–µ 2</button>
              <button type="button" data-task="3" aria-pressed="false">–ó–∞–¥–∞–Ω–∏–µ 3</button>
              <button type="button" data-task="4" aria-pressed="false">–ó–∞–¥–∞–Ω–∏–µ 4</button>
            </div>
            <div id="taskSubtasks" class="subtask-grid" hidden></div>
            <section id="taskTextWrap" class="task-text-wrap" hidden>
              <div class="task-text-label">–¢–µ–∫—Å—Ç –∑–∞–¥–∞–Ω–∏—è</div>
              <div id="taskText" class="task-text"></div>
            </section>
          </section>
        </div>
      </section>

      <section class="panel">
        <h2 class="block-title"><span class="block-num">1</span>–†–µ–¥–∞–∫—Ç–æ—Ä –∫–æ–¥–∞</h2>
        <label for="codeInput">–ö–æ–¥</label>
        <div class="code-editor">
          <textarea id="codeLineNumbers" class="emoji-field code-lines" readonly tabindex="-1" aria-hidden="true">üìå</textarea>
          <textarea id="codeInput" class="emoji-field code-input" spellcheck="false" autocomplete="off" autocapitalize="off"></textarea>
        </div>
      </section>

      <section class="panel">
        <h2 class="block-title"><span class="block-num">2</span>–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞</h2>
        <div id="emojiKeyboard" class="keyboard"></div>
      </section>

      <section class="panel">
        <h2 class="block-title"><span class="block-num">3</span>–ü–æ–ª–µ —Å—Ü–µ–Ω–∞—Ä–∏—è</h2>
        <div class="scenario-wrap">
          <div class="scenario-tools">
            <label class="scenario-toggle" for="scenarioAnimationToggle">
              <input id="scenarioAnimationToggle" type="checkbox" checked>
              –ê–Ω–∏–º–∞—Ü–∏—è —Ä–æ–±–æ—Ç–∞
            </label>
          </div>
          <div id="scenarioMeta" class="scenario-meta"></div>
          <div id="scenarioBoard" class="scenario-board"></div>
          <div class="scenario-legend">
            <span class="legend-item"><span class="legend-chip">ü§ñ</span>–†–æ–±–æ—Ç</span>
            <span class="legend-item"><span class="legend-chip blocked">‚ñ†</span>–°—Ç–µ–Ω–∞</span>
            <span class="legend-item"><span class="legend-chip">S</span>–°—Ç–∞—Ä—Ç</span>
            <span class="legend-item"><span class="legend-chip">F</span>–§–∏–Ω–∏—à</span>
          </div>
        </div>
      </section>

      <section class="panel">
        <h2 class="block-title"><span class="block-num">4</span>–ó–∞–ø—É—Å–∫</h2>
        <div class="controls">
          <button id="runBtn" class="primary">–ó–∞–ø—É—Å—Ç–∏—Ç—å</button>
          <button id="resetBtn">–°–±—Ä–æ—Å</button>
        </div>
        <div id="statusBox" class="status-box">–û–∂–∏–¥–∞–Ω–∏–µ –∑–∞–ø—É—Å–∫–∞.</div>
        <div id="stepCount" class="step-count">–°—É–º–º–∞—Ä–Ω—ã–µ —à–∞–≥–∏: 0</div>
      </section>

      <section class="panel" hidden>
        <h2 class="block-title"><span class="block-num">5</span>–í—ã—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ</h2>
        <div id="testOutputs" class="test-output-grid"></div>
      </section>

      <section id="codePhrasePanel" class="panel" hidden>
        <h2 class="block-title"><span class="block-num">6</span>–ö–æ–¥–æ–≤–∞—è —Ñ—Ä–∞–∑–∞</h2>
        <label for="codePhraseInput">–ö–æ–¥–æ–≤–∞—è —Ñ—Ä–∞–∑–∞</label>
        <input id="codePhraseInput" class="text-input" type="text" autocomplete="off" autocapitalize="off" spellcheck="false" placeholder="–ö–æ–¥–æ–≤–∞—è —Ñ—Ä–∞–∑–∞" readonly>
        <div class="controls">
          <button id="copyCodePhraseBtn" type="button">–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
        </div>
      </section>
    </section>

    <section class="vars-panel" hidden>
      <h2>–°–æ—Å—Ç–æ—è–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö</h2>
      <div id="varsGrid"></div>
    </section>
  </main>

  <script src="./js/lab-shell.js"></script>
  <script src="./js/domain-robot.js"></script>
  <script>
    const KEYCAP_DIGITS = ["0Ô∏è‚É£", "1Ô∏è‚É£", "2Ô∏è‚É£", "3Ô∏è‚É£", "4Ô∏è‚É£", "5Ô∏è‚É£", "6Ô∏è‚É£", "7Ô∏è‚É£", "8Ô∏è‚É£", "9Ô∏è‚É£"];
    const COLOR_CSS_BY_CODE = { red: "color-red", yellow: "color-yellow", green: "color-green", purple: "color-purple" };

    const ROBOT_EXAMPLES = [
      { label: "–ü—Ä–∏–º–µ—Ä ‚Ññ1", code: ["üö∂üö†", "üö∂üöá", "üö∂üöá"].join("\n") },
      { label: "–ü—Ä–∏–º–µ—Ä ‚Ññ2", code: ["üö∂üö†", "üö∂üöá", "üé®üåπ", "üö∂üö†", "üé®üçÄ"].join("\n") },
      { label: "–ü—Ä–∏–º–µ—Ä ‚Ññ3", code: ["üîÅüß±üö†", "üö∂üöá", "üòê", "ü§îüõ§üö†", "üö∂üö†", "üòê", "üé®üåª"].join("\n") },
      { label: "–ü—Ä–∏–º–µ—Ä ‚Ññ4", code: ["ü§îüå°üî•1Ô∏è‚É£0Ô∏è‚É£", "üé®üåπ", "üòê", "ü§îüå°üßä1Ô∏è‚É£0Ô∏è‚É£", "üé®üçÄ", "üòê", "ü§îüå°üü∞1Ô∏è‚É£0Ô∏è‚É£", "üé®üçá", "üòê", "ü§îüéØüåπ", "üö∂‚úàÔ∏è", "üòê", "ü§îüéØüçÄ", "üö∂üö†", "üòê", "ü§îüéØüçá", "üö∂üöá", "üòê", "üé®üçá"].join("\n") },
      { label: "–ü—Ä–∏–º–µ—Ä ‚Ññ5", code: ["ü§îüå°üßäüü∞1Ô∏è‚É£0Ô∏è‚É£", "üé®üåπ", "üòê", "ü§îüéØüåπ", "üîÅüõ§üöá", "üö∂üöá", "üòê", "üòê", "ü§îüå°üî•1Ô∏è‚É£0Ô∏è‚É£", "üîÅüõ§‚úàÔ∏è", "üö∂‚úàÔ∏è", "üòê", "üòê", "üîÇ1Ô∏è‚É£", "ü§îüß±üöú", "üòê", "üòê", "üîÅüõ§üö†", "üö∂üö†", "üòê", "ü§îüèÅ", "üé®üçÄ", "üòê"].join("\n") }
    ];

    const ROBOT_SUBTASK_PRESETS = Object.freeze({
      "1.1": {
        code: [
          "üö∂üö†",
          "üé®üåπ",
          "üö∂üö†",
          "üö∂üöá"
        ].join("\n")
      },
      "1.2": {
        code: [
          "üö∂üö†",
          "üö∂üö†",
          "üé®üçÄ",
          "üö∂üö†",
          "üö∂üöá"
        ].join("\n")
      },
      "1.3": {
        code: [
          "üé®üåª",
          "ü§îüß±üö†",
          "üö∂üöá",
          "üòê",
          "ü§îüõ§üö†",
          "üö∂üö†",
          "üòê"
        ].join("\n")
      },
      "1.4": {
        code: [
          "üîÇ2Ô∏è‚É£",
          "üö∂üö†",
          "üòê",
          "üé®üçá",
          "üîÇ2Ô∏è‚É£",
          "üö∂üö†",
          "üòê",
          "üö∂üöá"
        ].join("\n")
      },
      "2.1": { code: "" },
      "2.2": { code: "" },
      "3.1": {
        code: [
          "ü§îüå°üî•1Ô∏è‚É£0Ô∏è‚É£",
          "üòê",
          "ü§îüå°üßäüü∞1Ô∏è‚É£0Ô∏è‚É£",
          "üòê",
          "üîÅüõ§üö†",
          "üö∂üö†",
          "üòê",
          "ü§îüõ§üöá",
          "üö∂üöá",
          "üòê"
        ].join("\n")
      },
      "3.2": {
        code: [
          "ü§îüå°üî•üü∞1Ô∏è‚É£5Ô∏è‚É£",
          "üòê",
          "ü§îüå°üßä1Ô∏è‚É£5Ô∏è‚É£",
          "üòê",
          "üîÅüõ§üöá",
          "üö∂üöá",
          "üòê",
          "üîÅüõ§üö†",
          "üö∂üö†",
          "üòê"
        ].join("\n")
      },
      "4.1": { code: "" }
    });

    const ROBOT_SUBTASK_TEXTS = Object.freeze({
      "2.1": ["–ù–∞ –∫–∞–∂–¥–æ–º –∏–∑ 3 –ø–æ–ª–µ–π –¥–æ–π–¥–∏—Ç–µ –¥–æ —Ñ–∏–Ω–∏—à–∞ –∏ –∑–∞–∫—Ä–∞—Å—å—Ç–µ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—É—é –∫–ª–µ—Ç–∫—É –≤ üåπ."],
      "2.2": ["–ù–∞ –∫–∞–∂–¥–æ–º –∏–∑ 3 –ø–æ–ª–µ–π –¥–æ–π–¥–∏—Ç–µ –¥–æ —Ñ–∏–Ω–∏—à–∞ –∏ –∑–∞–∫—Ä–∞—Å—å—Ç–µ –¥–≤–µ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—ã–µ –∫–ª–µ—Ç–∫–∏: –æ–¥–Ω—É –≤ üçÄ –∏ –æ–¥–Ω—É –≤ üåª."],
      "3.1": ["–ù–∞ –∫–∞–∂–¥–æ–º –∏–∑ 3 –ø–æ–ª–µ–π: –µ—Å–ª–∏ —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞ —Å—Ç–∞—Ä—Ç–æ–≤–æ–π –∫–ª–µ—Ç–∫–∏ –≤—ã—à–µ 1Ô∏è‚É£0Ô∏è‚É£, –∑–∞–∫—Ä–∞—Å—å—Ç–µ —Å—Ç–∞—Ä—Ç–æ–≤—É—é –∫–ª–µ—Ç–∫—É –≤ üåπ, –∞ —Å–æ—Å–µ–¥–Ω—é—é —Å–ø—Ä–∞–≤–∞ –≤ üçÄ; –∏–Ω–∞—á–µ –Ω–∞–æ–±–æ—Ä–æ—Ç. –ü–æ—Å–ª–µ —ç—Ç–æ–≥–æ –¥–æ–π–¥–∏—Ç–µ –¥–æ —Ñ–∏–Ω–∏—à–∞."],
      "3.2": ["–ù–∞ –∫–∞–∂–¥–æ–º –∏–∑ 3 –ø–æ–ª–µ–π: –µ—Å–ª–∏ —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞ —Å—Ç–∞—Ä—Ç–æ–≤–æ–π –∫–ª–µ—Ç–∫–∏ –Ω–µ –Ω–∏–∂–µ 1Ô∏è‚É£5Ô∏è‚É£, —Å—Ç–∞—Ä—Ç–æ–≤–∞—è –∫–ª–µ—Ç–∫–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å üåª, –∞ —Ñ–∏–Ω–∏—à–Ω–∞—è üåπ; –∏–Ω–∞—á–µ —Å—Ç–∞—Ä—Ç–æ–≤–∞—è üçá, –∞ —Ñ–∏–Ω–∏—à–Ω–∞—è üçÄ. –î–æ–π–¥–∏—Ç–µ –¥–æ —Ñ–∏–Ω–∏—à–∞."],
      "4.1": ["–ù–∞ –∫–∞–∂–¥–æ–º –∏–∑ 10 –ø–æ–ª–µ–π –Ω–∞–π–¥–∏—Ç–µ —Ñ–∏–Ω–∏—à –ø–æ —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–µ –∏ –¥–æ–π–¥–∏—Ç–µ –¥–æ –Ω–µ–≥–æ."]
    });

    const ROBOT_KEYBOARD_GROUPS = [
      ["üö∂", "üé®", "ü§î", "üîÅ", "üîÇ", "üòê"],
      ["‚úàÔ∏è", "üöá", "üö†", "üöú", "üß±", "üõ§", "üèÅ", "üéØ", "üå°", "üåπ", "üåª", "üçÄ", "üçá"],
      ["üü∞", "üö´", "üî•", "üßä", "üî•üü∞", "üßäüü∞", "0Ô∏è‚É£", "1Ô∏è‚É£", "2Ô∏è‚É£", "3Ô∏è‚É£", "4Ô∏è‚É£", "5Ô∏è‚É£", "6Ô∏è‚É£", "7Ô∏è‚É£", "8Ô∏è‚É£", "9Ô∏è‚É£"]
    ];

    const ROBOT_SCENARIO_BLOBS = Object.freeze({
      "example:1": [
        { "seed": 3668005737, "blob": "Epbwb9dNRaBq6adbqPzN8Y1l4aIfQixb7RzGEqdGljzgJ8uE95O1FmMhhyx3HGBBcsHXVGdDyibDr96yybM9yPKp72SIENe/EmjplE4ySatXLaB+L93WyWkJv1z/FE3nrLjBlmJ7rg7404Vsb+t9Tmu5jss=" },
        { "seed": 3273459124, "blob": "z6F1xFICuAuHvULDjcOginDypElaTTHxAKpjqQKZO+c90M7v8twLfU/2IjcSY016z9YSfyLMV83u2LvJrGzQk6+eas8N36oUf7+MD2sNpFAqumUV6tLLYgS+GudaS+C88c/EfWe0E+XVhCB3ihRTddeuy+A=" },
        { "seed": 1136784771, "blob": "+CTeQR3/E+bQWdnlsq7bd+e3TwxVUJoftw7YDN004DrK1aXqvWFlUJlTOVJtTnbH2BM5Oq1RvOCZvcCsc4GLzpgbwUrCogF5qNoXKlTgXy29fw7Q5c9gD7MboUIF5rvhhsoveKgJ+MiCITuSdTltyMHr4CU=" }
      ],
      "example:2": [
        { "seed": 4008025350, "blob": "fY9bDuBU/rE1w/zb39Um4KJcCgNI+3erErV903DvPc3PvqClAApOhz9IXC1AdcvQHTh8tTC6kZf8xqVzntrW+R2wRIW/CWyuzUEyFbkbIrp4FMvf+GQNuBagBB2oveaWgyEqoRP/1ZgmFt8jDSvGyZT6KrIvTy7XPIZlM16aFjndVoqfOIttJ8wMclUzVaZwOdGXhch7jmnbYYICj3Sp" },
        { "seed": 809390253, "blob": "1goU80u5qVSu58O3pCixpUkZBR7jFsAMqRGifqsyysiku+8YayefIictIwB7yNwVNn3zKNuX5vKHo3qexYfhfLY1i/gUZLvLVmQN+EJmtX8T0cTCUwm6Ha0FW7Dz4JGTaCTlHPjSgj098yAONpbRjL8/pS9EYtkyx2M6XoVHIbx208Vik2Y4wlcpTThLqDE10pSYmGOWOcxgxF2vVKle" },
        { "seed": 1688402472, "blob": "U0XpWKbuTM+L167PWb/0TgwWGLUOoWW0DM0PpXbFz6Oh9FJzRvA9OUNSDjvG3xk+c/Juw/bgg4nifJfFmLBk1zP69lN5s95Qc1vgAz/xcBTW3tlpPr4fpgha9uuul5R4betY99WFJybYDA01i4GUp3qwOERplTzJIjxXhVhwpBfznDjJfjHcWXIWIEO3P3Tel5uFM44hnHfFG/B0iV5b" }
      ],
      "example:3": [
        { "seed": 3058276199, "blob": "HLhCtfEL1+q0ttU3zvofCwMLs1i5BN4R02LUeIHApKbuSTlekVUnXD5/NYbRGjJ7/G+F7oGF/vIzwvSp72SODcu2Aj7x9Wg8DadBNLZ1CZqN0SMKshCsE1fArPWAjmhs5UDlzp4reZIpCzeNgN7eN7slUy7BPJxlM16GQyH7UA==" },
        { "seed": 2576199066, "blob": "4ROv4hSQ8tXZzyinixFaBB6gXu8cv3vNfrkJj4SroelTIhSJNE5DIxBEiJEUMXf0YYSomeT+myzemanvHd5ElocsMOnNUHxDsRt+iEtRmtLScQm4CudaRLCv/Y2PfmCVH/DfgysxknUWK5GWmr8+viRIf5NdimwwQMsOIf9IxIt1xn52kw==" },
        { "seed": 1876303921, "blob": "Sv74B4+1zbiiMb/lYFRVGbVN6UqnGqRipWX+iu+u7lQ4D8MsLys+Dij5n1Q/dPhpiqnf/J+bQt6Ll6YqgRuF4CpB54xQaF+nWjDxLAaa0cNvBagWlwVe8aHxh8Q3fLUP9JDJKDzeJhExp5za8ir1cAN1nnKJbygQlEk=" }
      ],
      "example:4": [
        { "seed": 1609243612, "blob": "p6kdnKqKoMNfoPoOJVtIslj6TPECxQm4eJL74erhUz8V2GY3SlQTNZTuWn96+2WCp966h/pEr4XWoCOBBNT4S0ewjE0yFfMVZqo0R4mbiHUJtg7nWg6ntMnPxGhwtx/yyMl0LpIpCzeNgN7PPbYpSWmfPN90LUeMGCHgRMaOadkfZIIaIk04W/RmJM2Uksg80Q==" },
        { "seed": 2163541387, "blob": "8EyGuZXn2z7I5RFLKkbjX+9f91TdaNJlj5eQ5KVcOBLCfX1SNXkriIIrcTr1Zo6v0LvB4iWp9NjhJYgEy6lTJpDVF2gN+Aho8W9fgoaGIxi+E7VCBaq0yc/EaHC3H/LIyXQukikLN42A3s89tilJaZ8833QtR4wYIeBExo5p2R9kghoiTThb9GYkzZSSyDzR" },
        { "seed": 4087913838, "blob": "FdejhvicJqmNDlREN+0O6ErkUotwsw+SivyVqxg3FcVnZhgtGEKVn0QANLVojaPYtcCkPcjyqe9kjg3LtgI+8fVOMlfgA3X/NASajZstTq8bqBAdqPiknrshKqIC4dmIOneKNEA/jZ3f7jCFL0Bvk3uBImVGm0Fmqg/OjnTYL2OtGjwAcFu+MSbIioeGJI5mww==" }
      ],
      "example:5": [
        { "seed": 2867345121, "blob": "mu7It9+lPcjyw+9zsESFqQV9udoXKnTyFXaOOl/e3sRoH7Nc/zsJvvnJz8RvZKgZ+tmPbG/rEk57h5ba8Sv1cHp32WbHOm8ey00hvB+ExW7UMXvMT2FafySoMTPFiJKJNY4hxSfGFrxgp0t0KClk0rSYCbThgvrHtQZVn7PxZOIiI1cxV2KlUE4GJqMDylon" },
        { "seed": 904733842, "blob": "6evnipxoKv0hp5DfE3mSPBY4loeUpwPmZhBR1zyDaTFbmlwhvHadyynscCmMGT8MaRzgMWzmpdvIIsl30naCRYly9lsEd3krmKjeEb+50vvH9FQRzOXlSqZDKUMuQCPrUBMPYaAEhk4pmc4uT9b4yiab/ifkiF0bCOeFNZc2iPx9JXsRRLeqIIh0WQXsqE0=" },
        { "seed": 1946207755, "blob": "cMwGORVnW75IbpHNqsZj32/fd9Rd6FLmDxYQZCXcuJJC/f3StfmuCAer8bp15g4vUDtBYqUpdFhhpQiESynTphBVl+iNeIvoce/fAgcGo5g+kzXChSN5aT5Kr+0/inRfH+zvS+2EsAoaRXWKMqvC5B76R7qrwBzRryTLQQnzQrTIAZm/naDDJvSkWB0ZSLxR" }
      ],
      "task:1.1": [{ "seed": 2850069356, "blob": "F/kNrBpasPPP1so+VetY4siKPCGSdTlpyMPrsXqxI09liHbHOgQAxQVeqg/Ki3XSN26KV2o0X1WmcDPRlITIe/dGkifFB6Jst1cEdzMl3LiSQv39ourD+kxWkv+iY/gUKRd8RiXzHlpWeZ0Wyl94y61nDMyylXKV5jD5kVdFCLvOKZshwsJPNGk=" }],
      "task:1.2": [{ "seed": 2286936027, "blob": "oFy2CUX366640yE7mlazz58vJ8RtWALU34bAdPUsSGKSbY0iZWnaGDLbAYqFdt4/YIsRclVZJKgxNdiUm5ljlkDjKYIaqnmxQFJvcnyYt5VF5+aY3cf4R1uTubot/hM5XnIHI/oeRQdh/DaTBSLTpnkCl+mNeInocfWSVFhYo9Z5mTeF2nxraT4b8A==" }],
      "task:1.3": [
        { "seed": 445038722, "blob": "+dt3+qxYWk0x9QCoY6kCjCboJteE95O2FmEhhyxzGWFLasyRTAYquzu84Jm8ya98mcyQ4Xy2M5X2QUGWghdzSq5VN/EsJuWbiGQUqxumFB2osraFj2NhtBLD2YotPdUrQGOQgcP4dPUpRGCXbcc6BEnLTCG8HITFY5NmO8JXMwBuFvYxbJ+BkoYtw2yceP0Crw==" },
        { "seed": 313296377, "blob": "gibgv0cdVVCaGbcN2AzdIf010dLv8twLfU32IjcWZkxw19tUZ0OlJtCRl/zHrHCRwpGnZNcz+vZTf67CWWMN+GIZ/zQYwMfPYhj5RL5CWfun/ZCOX22mGfnZj2xvxD0XPMjR1fg0uzkDNqBlx3h9CNgYIf8PktY2kz9kghoiTThb/XY60ZeAyDzxZsM=" },
        { "seed": 31717124, "blob": "f7GlVAISSPt3rhK2fdNw+iDC1LnqvWFgUJtTOVJpS3fNwB5/Isw7zf3m8oeic53Kn6Yiz1L8gUMw+/MZSx3uCBmOOl/b0sZtH/lEnj0TsKzsk4NufOVA6p6NJzvZPAoLgZLV9T2zaBt4iWuALH1RjFhv9Q+SvGGTJCnURHxNe1u+I3qfm5iGLt45hCfZGr5lu1QEMBV6xw==" }
      ],
      "task:1.4": [{ "seed": 2640684229, "blob": "vkJM+7PxwdxWPutJzJDJPSHRPRZ73qiGsWiKZgNqknCMczcQ0283qhz1yzjTMGSNHjULIEPfTnqfm5KGLd85hF79U/BsrFNDLjwlgKreTef7mfzKy0FSlbX9c6hbOEkrQGy9EUwYL7VP0nwh0+RpFIe8jTub/mO631tYRu6eecRnkMpgOXgGRPDVOoc=" }],
      "task:2.1": [
        { "seed": 1107345981, "blob": "RloEA7tJuQTeFtNm1HiB1bmp9U5zRvA/OUBSDjvC2hg0a/8o25eO8padM9DLmKwlhg3D+EtHkJwZIXLuYnb/JCCU7J4tXIZSnlQToJS4uNUhOponvZ6IKzncPEBjv66avz2vOkRvjzzfe31UgFpq9UX6gnvSNG6KV2obcAzhP3TenZuGMo4h5X6CB/Az5w8ENGo9iv3eSOH5n/2AowZBk7m6atccMQ==" },
        { "seed": 358992145, "blob": "ah4Yp69V7diCUV8CQPR1udXtCepHuoSCRYXeKo9ODvRYr+NMz4vbrspZv/RfFBgJqkn/HL97pGOlZf6KlvurCwxQ8D05QlIOQpWfRQA0zD7N/uaDieJ8l8WYsGTXM/r2U3mz3lBzW+ADP/FwFNbe2Wk+vh+mCFr2666XlHht61jy2YciJpJ1OSLGi5SnavtoWC7BLMkiPF2FW3GkF4qVf9V+drMILQ==" },
        { "seed": 2468135791, "blob": "FCAK7Wkzn8Ks3W2YRpIn0wuze6ABHBZ5K4uM0Ano/J7m0fEGCa3rtCTXTW5ZMkoj9BdNVnmdNtoLa6ywEBqZofJu4vB/pKAUbB+t3gbSHtKTIRRJT0Tu7SuWYh5RlYgc7YehFBZVafptsYPqEvAM87fgDNXgbshMRaBFrv4L2fKM55Vo4PQHIwxIuQ6hDakChnCzZo+ErqfrVSNekSxnFWsAZPnOCw==" }
      ],
      "task:2.2": [
        { "seed": 1765432109, "blob": "VoqUc8s5KdQuZkM2JKgxJcmZhZ5jlkCPKZAi/iuySkgkO2+Y66ceoqato4D7SFyVtv1zqFsXYGwJccJeckZv9DDEfG7drBYC7qSDcOToCKXRCmp3rc44mymMzDBzTz5Kr+0/inRfH+zvS+2EsAoaRXWKMqvC5B76R7qrwBzRryTOTQv2Qv6xNY7yl6DDN7/0RFpNWu0O+FHpT41ws3bE1Kit6RgsUNAsbVI1FzWGylRnKrsogqPXsdfiJdDQka8qgh+Fpyxhtg==" },
        { "seed": 990123457, "blob": "ug7oV/9F3WjSYY+SkOSlSSUd2Xo3SlQSNZXuWn9+/mSIv9P8n5sr3pqp72SPBMi5GnmvjA9LdPMVdY46Joubm1xAgE3pUmK+kqXP1VAknE69jrYTeZIsBzWIgJSnA4pmA2mDboBjKxDTTyHgRMaOadkObo8WOApmW75nJMid28giyXfSdoJFiXL2WwR3eiuYqN4RvLnS7M31S0HU57pw+AQpVXxYbORQUVZ59kHKXnjLrmcM1v/DLcvmabSEXVtG7pt5gxidwg==" },
        { "seed": 305419896, "blob": "A1UZqFb+HL97yH69CY+EvrzmSCVekVUkXD5/NYbVHzNx5GLD9uDoifNC3ouWrymOA8K+UyaQ9Qc8Hp8VH+c6TOWb8TVA6SPpOwq++8nPvT8k9CfMkMktMNwjEXveqOuxerIyUWmYasc6JBCPXW3vXsC1f9A/Y4sRclV2C/F2ep+bkoYt3zmEXttdqivuEApvMSWA49AJ7fqc4NC7HhGRr/1y5EMxFyUHOL1IGFhhv0/SFXbT/yRC2uKNeJu9NvqRV0AI/LEmgw==" }
      ],
      "task:3.1": [
        { "seed": 914230517, "blob": "jvKc64NhsexmTFtYnAC5TfFBjSarbviX4fjaFnMawmB8A2cAI/+AWmxFuyiDoNS9zqV70JOvnmrPC8K2HW/plG5rDbobfuI6X8GVkDFA+QqgDU+w86XXm1Ak5R/pzI4tIZJ1GXuCmtj0K78YRG2YdoBkfQidRnbjAYqEf90weMxPCxQgAaYpZ5Hajsh7nDecZs8TvXv2GQQ/LWOYrNBQrO3StZC1BkrU56g7qAIjVzFXYqVQTgYmowPKWgeM4Q==" },
        { "seed": 2749103821, "blob": "tur0UysZiTRORSMRRIiRBSl55X7D9uDuifBC3ouSqiiEG8/4S0f/ggRNA+BbKLx1Ft3TiDs3hlLnA1r+pefB3FZz5QKzhttid8ltWGnI0cL4NadoGzqGQ8kiOkqZUWDyD5KcONc1ZYcGOD1nGOd7M9nazZ4z2X6SJ8MavmWnARwWMyXC88YboreJrZipCBGVsvR4+EN2GTlXJfocCwlvvU+QBWDAsGlXl6qfbpunPPqSShUQo54+mmed4m80" },
        { "seed": 1604331287, "blob": "bKgSJUE7B3rERAVAHupPm1M7g+hpFO6ig3Lk6HHwlFZeWenOYaVwzI5PZTYBCuLrLJ91HlGViBztgbwIH0U/4gyxg/RZpFes/ctLjrMqj1wC90H+sV/ErbKu22HrplgbA0j7V7lY7E6WIeEGxseuoOJec0bffGAVIwB6wd8aLjqtUZruw/yf8jPQ0Nb5dsFKxLUdc7mMDzJdp11mrjoGms+IO1/3XLxCBaLltoCJYWe1WKuejDww1SFAJLmOyw==" }
      ],
      "task:3.2": [
        { "seed": 420198337, "blob": "ug7oV/9F3WjSY4+TkOSlSSUd2Xo3SlQTNZTuWn9+/mSIv9P8n5sp3p2p72SPBMi5GnmvjA9Lcu4bJ7Z6EcuVkFoX+QbnWg6+6+3B3D0k5Q700Ztsb4F9H3Wf0c6/YuFmA3XZJNEsfUaMWXOkF5CaR51+bpYFNQx2W75odNuRmYMyxEnbZMMXt232GVI/PWKW85pC4PyD5+H2SFyE/6I17RMpXjAHbL0RTBgvtU/SfCHT5GkUhLyNO5v+Y7rfW1hG7p55xGeQymA5eAZE8NU6hw==" },
        { "seed": 1997300441, "blob": "okYAX2e9dfD6tFeoOKz9wR3V8XKPEjyoHezWQte2huyQd/v0ByNARvRxtxznTJAx4jHHhPeT2hZzH85ieQMtGELfkQ5/IqUmw7WZ5JXsPYbMmbNk11mQp11n6dYXKhjuGz3xLEiUld5kAatc/1IN75S4wYN1eKIZ5Z7RNXfWJgwwl5vk+Dm0IkRo2SSRcipXxRZl70PBlHLyM2eBB3JVIAvhd3SR2pSPLcBonD/7BPBx9hkUYWp+mOvMB6z2n+PN6wYJ1KT9e+YOOxkjeD3i" },
        { "seed": 3284517773, "blob": "9qo0k2tZSfSOCePVhEhRRWm5Jb6DtiCtSbCCnkvS6mjEWw+4C4ezQsONw6CbaPy1Vh0TSPt3xhKnQ5o+5SeBnJazpUJzRpgiNwktGCmIkQI4deco2/XG8t7iZ9CTzO9klEqd7F0+v8tYYA34DzmOOl/dz9pkD69c/xsd9KD6ipVlWqIb8tSOKneKOxAsgd+U+zG5I1JkuHGJby0Q0xZk9EjNiTidfmiLGTwcIEPfaHTF2s3ZbY5inD+QU/Bqu09JP2o9mKGJWf75la3fxFlO" }
      ],
      "task:4.1": [
        { "seed": 3369442101, "blob": "TjJcq0Mh8Swmj5udXED5DbEBTebrrrjQITiaVrPagiA8wydAY7/Bmq8F+2hDYJR9jmU7ENNvWLIBnro26m4n2Ch8NDdVsE565sjb3ByAQI0plSL+UuQPFxBkXIz9yHaizsGjkMR5H9S+/XvmEm4BBV5i51ATQm/kFModat2+P0vY4I14iLl/7d9AFRC0wHmHZ9qPPmtgBgv9qn3LbBAQ7K0S9db1RgoUJ+h76NXpFu5Huu7PRc+hfo8SVLYTpalUxfzN9pxp4/QHSQpGug7jHL8S03DwdpmW4erzXzwMiTQnDSNZO9yRTG80tXPD9oryh7R6n9nW+XSQRNz4CT7xnBkyVuADdv80Cd3a2iNW4gPpGx3q667Vyi9x5UCgkMk6MN0/QGPVjprmeq9oGzrXPJwiZQDFFnfjQNjFIIMhJ5VXKE04SqgxL5/Cw8Zj2H7TdYJF4XT4WAQ1aj2P/d5SrK/Eo4DtQV6G/6Ij9003GSYHeq1eCw1h/F7EBS6U8TsMj6XSH5XmNu6NXVReo9Yg3COJ0Xs6fDED7Osvn3UeUbqnRaqfpA==" },
        { "seed": 918662407, "blob": "fJiilVHrt8rUlbUTbtr/62PrEzgZZH52s0N0WGGgBIZOKZm+cXWGvJ0fleYx+pJbXE/lzmGlHtWTIBQ4OFOhuBrWSg9H/ogclNb1VC4aRul7+/ygIK9JtIKeMoavM/AEPKwd6dYz2fKM55Vo4PQHIwxIuQ6hCKkChnCzZY+Eua3qSnNGmnM5Cy1aO56GWn9htTDQ4JmqwK1v0JPFvmqWSt/4SyjnjEwyFfMVZqdzEMiVkDAR9wXnGB2o+rjBny8y9lazyI4jJZJ1UCTIiJTleu15DS6CPN8ycxCdUW72D5LeZ50nKZZXalsuW/0xbIvU1Z4kwWucP5IC/nL2WwR3fSuYqN4RvrnS+8f0VBHM7uU78UM0GWQTbL0LC05x6k+cQjeBvnEayLzUYMHmaaPRGk4Iu9533DGF0mJrLlYbofNlgjMGWuL3Se3Y7UhRQni1J+ibugbDSaK6yhnR4HKPEhy4V7XlB4a4veeYZ/uzWVpNHrNZ/kP4" },
        { "seed": 1510683271, "blob": "/BgiFdFrN0pUFTWT7lp/a+Nrk7iZ5P72M8D02OEghAbOqRk+8fUBPB2fFWaxehLb3M9lTuElnlATppS4uNQhOZpWyo3HfQicFFd11a6axmz7fHwgoC7JMwIesgAvt3CEvCmdbFazWXIMZxXoYHSHo4zIOY4hiCmCBvAz5g8EOS1qyvPGGvO5i63aux4G2v/hNbBTYBkqQC3vUBNFPuoWyl94y6hnDMyylXCV5ifzkEgVELiRd4VnmJ0oeDhBH6+yc9YzSA6jpRL10aRICBRl+m3/ja4CvF+z85Ad0e52jxJT5x2nqRbX6tyu232x7AxUVR6kQescvxWCfvJ224T3/asYKF6RODlSe0d01JFMa2W7ccO0meSV7D2Li87zas8cwrcBPvGZSE0D4Fw8o3MezJWQek69F6sJTPqb8YKFZW2jWKvImTswzTI=" },
        { "seed": 2445579001, "blob": "gibgv0cdVVCaG7cJ2AzdIf010dLv8twMfU/2IjcWZkxw19tUZ0OlJtKRl/zHrHCRwpGnZNcz/O5dKZaCbiQD8mRoiCZRi+qGWlr3S5hMZKTlpL7KVjjrT8yQsH15gBJOAtffgMAF+2hCaZdyliJlaZIWe6QXnss4yH4x3VlyG2cU9DFsjIXbkWPUOYQwjF2rK+4QCm88Yteh3hG/6Nz0gOEGCcLxum6oW38XfFEl8gILTnK7QZMFItOmeAKX6Y14iuhx4phVRwi73SbSPsLHMHMmT0T0qn3JPR4fq7hA7djgGV9NP6B18JOgWedHuu6eS8Dma90KXa5M8PBMjfLVstUm6vQHTVtItUn2Tqcayi+lL4He7/KxFnMFiTQnXC1WfMnDVGcu6iaa7sP8n/Qz0NDW+XfBStO/HGzplAJtA7kbPPEsTJSV0yNW71LnFFr/ubbZ13BV61j0xJsrNsRtWCLGld/zMaQic2mafY1lOxDTQHHzSNWa" },
        { "seed": 39223481, "blob": "wuYg/4ddFRDa23fJGMydYT11ERKvshzMPQg24vdWpoywFxsUJ4Nk5pLRV7wH7LDRAtHnJJdzPKod6tZCrubDsqQoyOIRSCpGmhm3DtgMpGalYv6KlvirCwxQ8Ds5RlIOQpKfRABFuyiCqdey1uIlqdLWu2TXXov4CD7xmhkyW6dUNPEsTMWb0SMU+UTwTB3r667Xyi98ohfhntF/KJw0QCHGyYKxeq5oGzjXPJFlMkLLDjL7AdPFYpNmOMJXKU04TagxItiVh8h7mGaSfoIH8DPnDwQ0aj2J/d5f6/iArZigWR+N/+A1sFNgGScHeqxeCwAmqx3KHW+MsDAMzbKVc5XmKrTHCRsI9Yk2jmfaiW9lb0Eer7J31jNFSfTgHO2WvAkDFCfvKubargO8X7DzkBCWuTSBChP/XKypVMStw/nbfLHsCVRVE+MWrRKnVJo/+XaZlLCVqxg0BNtrdgQtGGKG1R8zceRis6navc2le9CTgLEziBXa" },
        { "seed": 2863197749, "blob": "TjJcq0Mh8Swmj5udXED5DbEBTebrrrjTITiaVrPagiA8wydAY7/Hmq4F+2hDYJR9jmU7ENNvWLIBnro26mwn3ih8NDRVt0565svb3ByAQIgpkiL+UuEPFRBkXIr9zXaizsSjl8R5H9S+/XvmEm4BBV5i51ATQW/kFModat2+P0vY4I14iLl/7d9AFRC1wHmHZ9qPPmtgBgv9qn3IbBAQ7K0S9db1RgoUJ+l76NXpFu5Huu3PRc+hfo8SU7YTpalUx/zN9pxp4/QHSgpGug7jHL8U03DwdpmV4erzXzwMiTQsDSNZO9yRTGw0tXPD9onyh7R6n9nW+XCQRNz4CT7xmBkyVuADdP80Cd3a2iNW7APpGx3q667Xyi9x5UClkMk6MN0/QGPVjprmeq9oGz3XPJwiZQLFFnfjQNjFIIMhJ5VXKE04TKgxL5/CxsZj2H7TdYJF4XSJDwQoMHffsogJtO7S6cv3TUCej/126QkpX3wfNO0HTAk+" },
        { "seed": 1200345523, "blob": "yFQuce1vw/bg6Yn3Qt6Lh7cnnxyF4Cop559oPA2kUCq6ZRWajfEzQO8j6UJd/qb3iINpKv0hyonHegicFFJ11q6axmj7fnwgoC/JNgIesgUvtnCEvCydaFbCLmNDMiSoSGKRyKq3bY5422nMDPAzj1gENWo9j/3eUqyvwaOA7UFehv+iJvdNNxkmB3qrXgsNYfxcxAUulPE7DI+h0m7C5iu0xwsbCPjOYc9pwst3JGRBXLz1a4EzREn05xztm/teQho/rDKn0a5BrBispJARlrk0gQoeuAvup0yBtYLy2z6hqxEDVRLjFqkSp1ndaLp4gdKopfcYa07WIm5SdwAjlp9UJDqtPs3uz7vIsD3IkInvPc8QheBAMOnXFyoZ7hswtnsNmo2dfECgXL1CBabltprENzvrWOXZhj53in4fdZ/Rzr9i4WYDddkk0Sx9RoxZc6QXmpo2yn5zzE9gQyAApilmkdqDjyzcOYQ23VOpK6wBHH1kJcPzxhiit4Tqz+kGCcKgxTuoBDRLO0Y0vUhSViWvA4FUMqP5Kk3d9ctgg7Ah45hFSg==" },
        { "seed": 409352177, "blob": "ir44R8/1jXji83+hoBQVWfWNKYpn2uQnZSY+Sq/uLpR4TwPs72v8zu05XxR/tDipyukfvF/bhINFgN4q9h1Lrmzw0FjZ5LKuojS/4GBULFjtHMYS3hbTYNR4+JXh+doWCk6HO0gtIwB6wd8aLjqtUZruw/yf9TPQ0Nb5dMFK078cbOmUBG0DuRs88SxJlJXTI1bpUucUWv+5ttnXcCS8WOme0X15kjZAY9bflOk9ujoDNsljyXt9SssOMKoP0cUggnApmhA9HyBDtm56xtqPyHufN5x8gkXmJfZXQyA4JYDogQf1t4itmK0IEY//oiemQzheM1VipUNUWDjkFcodad2+MgyPpYNgzaE+5t8CBVetl3mGZ9qPPmttQVy4pGWOdFEb7O8Dss6iRgsUJ+x76NiuQapJoqvXBMShPJlVS+ETpKlUxPzN+9s+ovofDBIHsQ6hC/h903DsLNPDrrylACpezWd7GXxKS8HSFTV98yjbuMmrwL1i" },
        { "seed": 1729084103, "blob": "vFji1ZErd4oUVXXTrpq/K6MrU3jZJL41cwG0GCHgRMaOadl+MbVBfFtfVaZxOtKbnI8ljiHlXpNT51T4eBJheVqWiswHvcjc1JO1FW7ahqk7uDxgYGsJdsJeckRv8DDEfGvdqBZzmbLMJ9WoILTHY0wI+c5hy2nCxjBzJ09E+e0qijMGWrP5S+2a+15HGj+hdfCSoFnqAO2vkFOG/irWCh+4C+inTIzy1bbVJuezUAhVUPhRt0WnWN1ouHiB3+/ysxZzCM5jZVI1EGSIyFQlOq0/ze7C/J/xM9Ddka42z1KUp11n6dYXKhruGz3xLEuUld5kAatc/1RCvrK2m8Q3OOtY6J7ReHmSOwc0lNGMqCX7MQN02STXLH1Lyw43qg/cgnfBfjHYCA1DIBz8YzPejNXQOo5912vJDLpbsUJFJS1jmOuIWfvwjfI=" },
        { "seed": 3581407061, "blob": "LpI8CyOB0YzGb/t9fCDZbZFhLUbLDlizAZy6NpM6YoAcIwcgQ98geo6l28gjwHTdbsUb8DOPeBdheVqWis0HvMjc1JK1Em7ahqg7ujxgYG8JdMJeckZv8DDEfG/drhYC7qaDdOSZf7SeXVtG8s5hpT7CxzBzIU9E9Kp9zj0eH6u4QO3Y6BlfTT+gdfCVoFnnR7rrnkvA5mvdCl2rTPDwTI3y1bHVJur0B0xbSLVJ9k6nGssvpS+B3u/ytBZzBYk0JlwtVnzJw1RnIeommu7D/J/yM9DQ1vl1wUrTvxxs6ZQGbQO5GzzxLE+UldMjVulS5xRa/7m22dJwJLxY6Z7Rf3mSNkBj19+U6T26OgM2zmPJe31Kyw4yqg/RxSCAcCmaED0fIEOybnrG2o/Ie5o3nHyCReMl9ldDIDglgOaBdqK3lffS/EdH1OfjNewIIlItTRL6E0ocJqJP0lMohPk2Uw==" }
      ],
      "*": [{ "seed": 16355678, "blob": "JQcz9ghMVnmdXMQWB92+OFrU4ttgg59jus1lGwjnhTWXNoidKBIkT1bQpGWYfVMIpbBU7diCOV8Ufr07ptKuQcU4rP3XEcTmZdkKXeETuuIAnKOH0Jxl8L5YHFVQtV7uW/hd" }]
    });

    const ROBOT_CODE_PHRASE_BLOBS = Object.freeze({
      "task:2.1": { "seed": 311769112, "blob": "X+VKr/vvgXVhz0f9n4IZ2hmelg==" },
      "task:2.2": { "seed": 2048129377, "blob": "LTRojp2QJi1kNJJGvGB1L6XDcxrDog==" },
      "task:3.1": { "seed": 985441263, "blob": "v+et1CgGkicjE4xs1WGxeJxq" },
      "task:3.2": { "seed": 3770266941, "blob": "dkgZPrh8xO4aEC/pWfv8n6CasQ==" },
      "task:4.1": { "seed": 1266015570, "blob": "FLga4+r38leYgPzqa16hjRLIJGPujJfI2n4cDoyUjXqmeHScf95dloUpTQ==" }
    });

    function decodeScenarioBlob(entry) {
      if (!entry || typeof entry !== "object") return "";
      const blob = String(entry.blob || "");
      const seed = Number(entry.seed) >>> 0;
      let encoded = "";
      try {
        encoded = atob(blob);
      } catch (_) {
        return "";
      }

      const bytes = new Uint8Array(encoded.length);
      let state = seed;
      for (let i = 0; i < encoded.length; i++) {
        const cipher = encoded.charCodeAt(i) & 0xff;
        bytes[i] = cipher ^ (state & 0xff);
        state = (state * 1664525 + 1013904223) >>> 0;
      }

      try {
        return new TextDecoder("utf-8").decode(bytes);
      } catch (_) {
        let fallback = "";
        for (let i = 0; i < bytes.length; i++) fallback += String.fromCharCode(bytes[i]);
        return fallback;
      }
    }

    function decodeScenarioMap(blobMap) {
      const out = {};
      const source = blobMap && typeof blobMap === "object" ? blobMap : {};
      const keys = Object.keys(source);
      for (const key of keys) {
        const encodedList = Array.isArray(source[key]) ? source[key] : [];
        const decoded = encodedList.map((entry) => decodeScenarioBlob(entry)).filter((text) => text.length > 0);
        if (decoded.length) out[key] = decoded;
      }
      return out;
    }

    function decodeSecretMap(secretMap) {
      const out = {};
      const source = secretMap && typeof secretMap === "object" ? secretMap : {};
      for (const key of Object.keys(source)) {
        const value = decodeScenarioBlob(source[key]);
        if (value) out[key] = value;
      }
      return out;
    }

    function scenarioLabelFromKey(scenarioKey) {
      const key = String(scenarioKey || "");
      if (key.startsWith("example:")) {
        const n = key.slice("example:".length);
        return `–ü—Ä–∏–º–µ—Ä ‚Ññ${n}`;
      }
      if (key.startsWith("task:")) {
        const n = key.slice("task:".length);
        return `–ü–æ–¥–∑–∞–¥–∞—á–∞ ${n}`;
      }
      return "–°—Ü–µ–Ω–∞—Ä–∏–π";
    }

    function visibleScenarioCountForKey(scenarioKey, totalCount) {
      const total = Math.max(0, Math.trunc(Number(totalCount) || 0));
      return total;
    }

    function toKeycapNumberText(value) {
      const safe = Math.max(0, Math.trunc(Number(value) || 0));
      const text = String(safe);
      let out = "";
      for (let i = 0; i < text.length; i++) {
        const code = text.charCodeAt(i) - 48;
        if (code >= 0 && code <= 9) out += KEYCAP_DIGITS[code];
      }
      return out || KEYCAP_DIGITS[0];
    }

    function keyOf(x, y) {
      return `${x}:${y}`;
    }

    function normEmojiToken(value) {
      return String(value || "").replace(/\uFE0F/g, "");
    }

    function toColorCode(value) {
      const token = normEmojiToken(String(value || "").trim().toLowerCase());
      if (!token) return null;
      if (token === "red" || token === "–∫—Ä–∞—Å–Ω—ã–π") return "red";
      if (token === "yellow" || token === "–∂–µ–ª—Ç—ã–π" || token === "–∂—ë–ª—Ç—ã–π") return "yellow";
      if (token === "green" || token === "–∑–µ–ª–µ–Ω—ã–π" || token === "–∑–µ–ª—ë–Ω—ã–π") return "green";
      if (token === "purple" || token === "—Ñ–∏–æ–ª–µ—Ç–æ–≤—ã–π") return "purple";
      if (token === normEmojiToken("üåπ")) return "red";
      if (token === normEmojiToken("üåª")) return "yellow";
      if (token === normEmojiToken("üçÄ")) return "green";
      if (token === normEmojiToken("üçá")) return "purple";
      return null;
    }

    function buildControlMarks(expectData, width, height) {
      const out = new Map();
      if (!expectData || typeof expectData !== "object") return out;
      const cells = Array.isArray(expectData.cells) ? expectData.cells : [];
      for (const item of cells) {
        if (!item || typeof item !== "object") continue;
        const x = Number(item.x);
        const y = Number(item.y);
        if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
        const nx = Math.trunc(x);
        const ny = Math.trunc(y);
        if (nx < 0 || nx >= width || ny < 0 || ny >= height) continue;
        const colorCode = toColorCode(item.color);
        out.set(keyOf(nx, ny), { colorCode });
      }
      return out;
    }

    function clampCoord(value, maxValue) {
      const num = Number(value);
      if (!Number.isFinite(num)) return 0;
      const n = Math.trunc(num);
      return Math.max(0, Math.min(maxValue, n));
    }

    function setScenarioError(boardEl, metaEl, title, message) {
      if (!boardEl || !metaEl) return;
      metaEl.textContent = String(title || "–°—Ü–µ–Ω–∞—Ä–∏–π");
      boardEl.textContent = "";
      const errorEl = document.createElement("div");
      errorEl.className = "scenario-error";
      errorEl.textContent = String(message || "–°—Ü–µ–Ω–∞—Ä–∏–π –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω.");
      boardEl.appendChild(errorEl);
    }

    function cloneCells(cells, width, height) {
      const out = [];
      for (let y = 0; y < height; y++) {
        const row = [];
        for (let x = 0; x < width; x++) {
          const cell = cells && cells[y] && cells[y][x] ? cells[y][x] : null;
          row.push({
            color: cell && typeof cell.color === "string" ? cell.color : null,
            temp: cell && Number.isFinite(Number(cell.temp)) ? Math.trunc(Number(cell.temp)) : 0
          });
        }
        out.push(row);
      }
      return out;
    }

    function cloneBoardState(boardState) {
      const controlMarks = new Map();
      if (boardState.controlMarks && typeof boardState.controlMarks.values === "function") {
        for (const [coord, mark] of boardState.controlMarks.entries()) {
          controlMarks.set(String(coord), { colorCode: mark && typeof mark.colorCode === "string" ? mark.colorCode : null });
        }
      }
      return {
        width: boardState.width,
        height: boardState.height,
        start: boardState.start.slice(),
        finish: boardState.finish.slice(),
        robot: boardState.robot.slice(),
        blockedSet: new Set(boardState.blockedSet.values()),
        controlMarks,
        cells: cloneCells(boardState.cells, boardState.width, boardState.height),
        finishReached: Boolean(boardState.finishReached)
      };
    }

    function boardStateFromScenario(scenarioData) {
      const width = scenarioData.width;
      const height = scenarioData.height;
      const blockedSet = new Set();
      for (const item of scenarioData.blocked.values()) blockedSet.add(String(item));
      const start = scenarioData.start.slice();
      const finish = scenarioData.finish.slice();
      const robot = start.slice();
      return {
        width,
        height,
        start,
        finish,
        robot,
        blockedSet,
        controlMarks: buildControlMarks(scenarioData.expect, width, height),
        cells: cloneCells(scenarioData.cells, width, height),
        finishReached: robot[0] === finish[0] && robot[1] === finish[1]
      };
    }

    function applySnapshotToBoardState(boardState, snapshot) {
      const out = cloneBoardState(boardState);
      if (!snapshot || typeof snapshot !== "object") return out;

      if (Array.isArray(snapshot.robot) && snapshot.robot.length === 2) {
        out.robot = [
          clampCoord(snapshot.robot[0], out.width - 1),
          clampCoord(snapshot.robot[1], out.height - 1)
        ];
      }

      if (Array.isArray(snapshot.blocked)) {
        const blockedSet = new Set();
        for (const pair of snapshot.blocked) {
          if (!Array.isArray(pair) || pair.length !== 2) continue;
          const x = Number(pair[0]);
          const y = Number(pair[1]);
          if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
          const nx = Math.trunc(x);
          const ny = Math.trunc(y);
          if (nx < 0 || nx >= out.width || ny < 0 || ny >= out.height) continue;
          blockedSet.add(keyOf(nx, ny));
        }
        out.blockedSet = blockedSet;
      }

      if (Array.isArray(snapshot.cells)) {
        out.cells = cloneCells(snapshot.cells, out.width, out.height);
      }

      out.finishReached = out.robot[0] === out.finish[0] && out.robot[1] === out.finish[1];
      return out;
    }

    function normalizeTrace(trace, boardState) {
      const start = boardState.start.slice();
      const out = [start];
      if (!Array.isArray(trace)) return out;

      function pushPos(x, y) {
        const last = out[out.length - 1];
        if (last && last[0] === x && last[1] === y) return;
        out.push([x, y]);
      }

      for (const pair of trace) {
        if (!Array.isArray(pair) || pair.length !== 2) continue;
        const x = Number(pair[0]);
        const y = Number(pair[1]);
        if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
        const nx = Math.trunc(x);
        const ny = Math.trunc(y);
        if (nx < 0 || nx >= boardState.width || ny < 0 || ny >= boardState.height) continue;
        pushPos(nx, ny);
      }

      return out;
    }

    function computeScenarioCellSize(boardEl, width, height) {
      const cols = Math.max(2, Math.trunc(width) + 1);
      const rows = Math.max(2, Math.trunc(height) + 1);
      const gap = 4;
      const minUnit = 12;
      const maxUnit = 38;
      const fallbackWidth = cols * maxUnit + (cols - 1) * gap;
      const measuredWidth = boardEl
        ? Math.max(
            Number(boardEl.clientWidth) || 0,
            Number(boardEl.getBoundingClientRect && boardEl.getBoundingClientRect().width) || 0
          )
        : 0;
      const availableWidth = Math.max(140, Math.floor(measuredWidth || fallbackWidth));
      const sizeByWidth = Math.floor((availableWidth - gap * (cols - 1)) / cols);
      const maxRowsToKeepReadable = 9;
      const sizeByRows = rows > maxRowsToKeepReadable
        ? Math.floor((maxRowsToKeepReadable * maxUnit + (maxRowsToKeepReadable - 1) * gap) / rows)
        : maxUnit;
      let unit = Math.min(maxUnit, sizeByWidth, sizeByRows);
      if (!Number.isFinite(unit)) unit = maxUnit;
      if (unit < minUnit) unit = minUnit;
      return { unit, gap };
    }

    function renderScenarioBoard(boardEl, metaEl, boardTitle, boardState, phaseText, showControlMarks = true, showFinishMarker = true) {
      if (!boardEl || !metaEl) return;
      boardEl.textContent = "";

      const width = boardState.width;
      const height = boardState.height;
      const start = boardState.start;
      const finish = boardState.finish;
      const robot = boardState.robot;
      const blockedSet = boardState.blockedSet;
      const controlMarks = showControlMarks && boardState.controlMarks && typeof boardState.controlMarks.get === "function"
        ? boardState.controlMarks
        : new Map();
      const cells = boardState.cells;
      const metaParts = [];
      if (boardTitle) metaParts.push(String(boardTitle));
      metaParts.push(`${width}x${height}`);
      if (phaseText) metaParts.push(String(phaseText));
      metaEl.textContent = metaParts.join(" ¬∑ ");

      const cellSize = computeScenarioCellSize(boardEl, width, height);
      const gridEl = document.createElement("div");
      gridEl.className = "scenario-grid";
      gridEl.style.setProperty("--scenario-unit", `${cellSize.unit}px`);
      gridEl.style.setProperty("--scenario-gap", `${cellSize.gap}px`);
      gridEl.style.gridTemplateColumns = `repeat(${width + 1}, var(--scenario-unit))`;

      const cornerEl = document.createElement("div");
      cornerEl.className = "scenario-axis corner";
      cornerEl.textContent = "x‚Üí\ny‚Üì";
      cornerEl.title = "x: —Å–ª–µ–≤–∞ –Ω–∞–ø—Ä–∞–≤–æ, y: —Å–≤–µ—Ä—Ö—É –≤–Ω–∏–∑";
      gridEl.appendChild(cornerEl);
      for (let x = 0; x < width; x++) {
        const xEl = document.createElement("div");
        xEl.className = "scenario-axis";
        xEl.textContent = toKeycapNumberText(x);
        gridEl.appendChild(xEl);
      }

      for (let y = 0; y < height; y++) {
        const yEl = document.createElement("div");
        yEl.className = "scenario-axis";
        yEl.textContent = toKeycapNumberText(y);
        gridEl.appendChild(yEl);
        for (let x = 0; x < width; x++) {
          const cellEl = document.createElement("div");
          cellEl.className = "scenario-cell";
          const blocked = blockedSet.has(keyOf(x, y));
          if (blocked) {
            cellEl.classList.add("blocked");
            cellEl.textContent = "‚ñ†";
          } else {
            const cell = cells[y][x];
            if (cell && cell.color && COLOR_CSS_BY_CODE[cell.color]) {
              cellEl.classList.add(COLOR_CSS_BY_CODE[cell.color]);
            }
            const temp = cell && Number.isFinite(Number(cell.temp)) ? Math.trunc(Number(cell.temp)) : 0;
            if (temp !== 0) {
              const tempEl = document.createElement("span");
              tempEl.className = "scenario-temp";
              tempEl.textContent = String(temp);
              cellEl.appendChild(tempEl);
            }

            const controlMark = controlMarks.get(keyOf(x, y));
            if (controlMark) {
              const controlEl = document.createElement("span");
              controlEl.className = "scenario-control";
              if (controlMark.colorCode && COLOR_CSS_BY_CODE[controlMark.colorCode]) {
                controlEl.classList.add(COLOR_CSS_BY_CODE[controlMark.colorCode]);
              }
              controlEl.textContent = "‚óè";
              cellEl.appendChild(controlEl);
            }
          }

          if (x === start[0] && y === start[1]) {
            const startEl = document.createElement("span");
            startEl.className = "scenario-marker start";
            startEl.textContent = "S";
            cellEl.appendChild(startEl);
          }

          if (showFinishMarker && x === finish[0] && y === finish[1]) {
            cellEl.classList.add("finish");
            const finishEl = document.createElement("span");
            finishEl.className = "scenario-marker finish";
            finishEl.textContent = "F";
            cellEl.appendChild(finishEl);
          }

          if (x === robot[0] && y === robot[1]) {
            const robotEl = document.createElement("span");
            robotEl.className = "scenario-marker";
            robotEl.textContent = "ü§ñ";
            cellEl.appendChild(robotEl);
          }

          gridEl.appendChild(cellEl);
        }
      }

      boardEl.appendChild(gridEl);
    }

    if (window.LovelaceLabShell && window.LovelaceDomains && typeof window.LovelaceDomains.createRobotDomain === "function") {
      const robotDomain = window.LovelaceDomains.createRobotDomain();
      const fixedTestsByScenario = decodeScenarioMap(ROBOT_SCENARIO_BLOBS);
      const codePhraseByScenario = decodeSecretMap(ROBOT_CODE_PHRASE_BLOBS);
      const scenarioMetaEl = document.getElementById("scenarioMeta");
      const scenarioBoardEl = document.getElementById("scenarioBoard");
      const scenarioAnimationToggleEl = document.getElementById("scenarioAnimationToggle");
      const codePhrasePanelEl = document.getElementById("codePhrasePanel");
      const codePhraseInputEl = document.getElementById("codePhraseInput");
      const copyCodePhraseBtn = document.getElementById("copyCodePhraseBtn");
      const ANIMATION_STEP_MS = 120;

      let lastScenarioPayload = null;
      let lastScenarioDomainResults = null;
      let animationTimerIds = [];
      let animationToken = 0;
      let task1ControlMarksRevealed = false;

      function isTaskOneScenarioKey(scenarioKey) {
        return /^task:1\./.test(String(scenarioKey || ""));
      }

      function scheduleScenarioFrame(callback, delayMs) {
        const timerId = window.setTimeout(() => {
          animationTimerIds = animationTimerIds.filter((id) => id !== timerId);
          callback();
        }, delayMs);
        animationTimerIds.push(timerId);
      }

      function stopScenarioAnimation() {
        if (animationTimerIds.length) {
          for (const timerId of animationTimerIds) {
            window.clearTimeout(timerId);
          }
          animationTimerIds = [];
        }
        animationToken += 1;
      }

      function isAnimationEnabled() {
        if (!scenarioAnimationToggleEl) return true;
        return scenarioAnimationToggleEl.checked;
      }

      function hideRobotCodePhrase() {
        if (!codePhrasePanelEl) return;
        codePhrasePanelEl.hidden = true;
        if (codePhraseInputEl) codePhraseInputEl.value = "";
      }

      function showRobotCodePhrase(phrase) {
        if (!codePhrasePanelEl || !codePhraseInputEl) return;
        const text = String(phrase || "");
        if (!text) {
          hideRobotCodePhrase();
          return;
        }
        codePhraseInputEl.value = text;
        codePhrasePanelEl.hidden = false;
      }

      function isSuccessfulScenarioRun(payload) {
        const results = payload && Array.isArray(payload.outputResults) ? payload.outputResults : [];
        if (!results.length) return false;
        for (const item of results) {
          if (!item || item.kind !== "ok") return false;
        }
        return true;
      }

      function drawScenarioView(payload, domainResults) {
        lastScenarioPayload = payload || null;
        lastScenarioDomainResults = Array.isArray(domainResults) ? domainResults.slice() : null;
        const scenarioKey = payload && typeof payload.scenarioKey === "string" ? payload.scenarioKey : "";
        const showControlMarks = !isTaskOneScenarioKey(scenarioKey) || task1ControlMarksRevealed;
        const showFinishMarker = scenarioKey !== "task:4.1";
        const tests = payload && Array.isArray(payload.tests) ? payload.tests : [];
        const scenarioTitle = scenarioLabelFromKey(scenarioKey);
        stopScenarioAnimation();
        scenarioBoardEl.textContent = "";

        if (!tests.length) {
          setScenarioError(scenarioBoardEl, scenarioMetaEl, `${scenarioTitle}: –æ—à–∏–±–∫–∞ —Å—Ü–µ–Ω–∞—Ä–∏—è.`, "–°—Ü–µ–Ω–∞—Ä–∏–π –Ω–µ –∑–∞–¥–∞–Ω.");
          return;
        }
        if (typeof robotDomain.parseScenario !== "function") {
          setScenarioError(scenarioBoardEl, scenarioMetaEl, `${scenarioTitle}: –æ—à–∏–±–∫–∞ —Å—Ü–µ–Ω–∞—Ä–∏—è.`, "–ü–∞—Ä—Å–µ—Ä —Å—Ü–µ–Ω–∞—Ä–∏—è –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω.");
          return;
        }

        const totalCount = tests.length;
        const visibleCount = visibleScenarioCountForKey(scenarioKey, totalCount);
        const shownCount = Math.max(0, Math.min(totalCount, visibleCount));
        if (shownCount < 1) {
          setScenarioError(scenarioBoardEl, scenarioMetaEl, `${scenarioTitle}: –æ—à–∏–±–∫–∞ —Å—Ü–µ–Ω–∞—Ä–∏—è.`, "–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –ø–æ–ª–µ–π.");
          return;
        }

        scenarioMetaEl.textContent = shownCount < totalCount
          ? `${scenarioTitle}: ${shownCount}/${totalCount}`
          : `${scenarioTitle}: ${shownCount}`;
        const token = animationToken;

        for (let i = 0; i < shownCount; i++) {
          const cardEl = document.createElement("section");
          cardEl.className = "scenario-card";
          const cardMetaEl = document.createElement("div");
          cardMetaEl.className = "scenario-card-meta";
          const cardBoardEl = document.createElement("div");
          cardBoardEl.className = "scenario-card-board";
          cardEl.appendChild(cardMetaEl);
          cardEl.appendChild(cardBoardEl);
          scenarioBoardEl.appendChild(cardEl);

          const boardTitle = `${i + 1}/${shownCount}`;
          const scenarioText = String(tests[i] || "");
          if (!scenarioText) {
            setScenarioError(cardBoardEl, cardMetaEl, `${boardTitle}: –æ—à–∏–±–∫–∞ —Å—Ü–µ–Ω–∞—Ä–∏—è.`, "–°—Ü–µ–Ω–∞—Ä–∏–π –Ω–µ –∑–∞–¥–∞–Ω.");
            continue;
          }

          const parsed = robotDomain.parseScenario(scenarioText);
          if (!parsed || !parsed.ok) {
            setScenarioError(cardBoardEl, cardMetaEl, `${boardTitle}: –æ—à–∏–±–∫–∞ —Å—Ü–µ–Ω–∞—Ä–∏—è.`, (parsed && parsed.error) || "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Å—Ü–µ–Ω–∞—Ä–∏–π.");
            continue;
          }

          const initialState = boardStateFromScenario(parsed.scenario);
          const result = Array.isArray(domainResults) ? domainResults[i] : null;
          const snapshot = result && result.snapshot ? result.snapshot : null;
          const trace = result && Array.isArray(result.trace) ? result.trace : null;

          if (!snapshot) {
            renderScenarioBoard(cardBoardEl, cardMetaEl, boardTitle, initialState, "—Å—Ç–∞—Ä—Ç", showControlMarks, showFinishMarker);
            continue;
          }

          const finalState = applySnapshotToBoardState(initialState, snapshot);
          const finalPhase = finalState.finishReached ? "—Ñ–∏–Ω–∏—à" : "–Ω–µ —Ñ–∏–Ω–∏—à";
          const tracePositions = normalizeTrace(trace, initialState);

          if (!isAnimationEnabled() || tracePositions.length < 2) {
            renderScenarioBoard(cardBoardEl, cardMetaEl, boardTitle, finalState, finalPhase, showControlMarks, showFinishMarker);
            continue;
          }

          let frameIndex = 0;
          const lastIndex = tracePositions.length - 1;
          const renderNextFrame = () => {
            if (token !== animationToken) return;
            const frameState = cloneBoardState(initialState);
            frameState.robot = tracePositions[frameIndex].slice();
            frameState.finishReached = frameState.robot[0] === frameState.finish[0] && frameState.robot[1] === frameState.finish[1];
            const phase = `${frameIndex}/${lastIndex}`;
            renderScenarioBoard(cardBoardEl, cardMetaEl, boardTitle, frameState, phase, showControlMarks, showFinishMarker);

            if (frameIndex < lastIndex) {
              frameIndex += 1;
              scheduleScenarioFrame(renderNextFrame, ANIMATION_STEP_MS);
              return;
            }

            scheduleScenarioFrame(() => {
              if (token !== animationToken) return;
              renderScenarioBoard(cardBoardEl, cardMetaEl, boardTitle, finalState, finalPhase, showControlMarks, showFinishMarker);
            }, ANIMATION_STEP_MS);
          };

          renderNextFrame();
        }
      }

      if (scenarioAnimationToggleEl) {
        try {
          if (window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches) {
            scenarioAnimationToggleEl.checked = false;
          }
        } catch (_) {}
        scenarioAnimationToggleEl.addEventListener("change", () => {
          if (lastScenarioPayload) {
            drawScenarioView(lastScenarioPayload, lastScenarioDomainResults);
          }
        });
      }

      if (copyCodePhraseBtn) {
        copyCodePhraseBtn.addEventListener("click", async () => {
          const text = codePhraseInputEl ? String(codePhraseInputEl.value || "") : "";
          if (!text) return;
          try {
            if (navigator.clipboard && typeof navigator.clipboard.writeText === "function") {
              await navigator.clipboard.writeText(text);
              return;
            }
          } catch (_) {}
          try {
            if (codePhraseInputEl) {
              codePhraseInputEl.focus();
              codePhraseInputEl.select();
              document.execCommand("copy");
            }
          } catch (_) {}
        });
      }

      window.LovelaceLabShell.boot({
        domain: robotDomain,
        examples: ROBOT_EXAMPLES,
        taskSubtaskCounts: { "2": 2, "3": 2, "4": 1 },
        subtaskPresets: ROBOT_SUBTASK_PRESETS,
        subtaskTexts: ROBOT_SUBTASK_TEXTS,
        keyboardGroups: ROBOT_KEYBOARD_GROUPS,
        lineDigits: KEYCAP_DIGITS,
        maxTracePoints: 2200,
        fixedTestsByScenario,
        onScenarioChange(payload) {
          const scenarioKey = payload && typeof payload.scenarioKey === "string" ? payload.scenarioKey : "";
          if (isTaskOneScenarioKey(scenarioKey)) task1ControlMarksRevealed = false;
          hideRobotCodePhrase();
          drawScenarioView(payload, null);
        },
        onRunComplete(payload) {
          const scenarioKey = payload && typeof payload.scenarioKey === "string" ? payload.scenarioKey : "";
          if (isTaskOneScenarioKey(scenarioKey)) task1ControlMarksRevealed = true;
          const domainResults = payload && Array.isArray(payload.domainResults) ? payload.domainResults : null;
          drawScenarioView(payload, domainResults);
          const phrase = codePhraseByScenario[scenarioKey];
          if (phrase && isSuccessfulScenarioRun(payload)) showRobotCodePhrase(phrase);
          else hideRobotCodePhrase();
        }
      });
    }
  </script>
</body>
</html>
