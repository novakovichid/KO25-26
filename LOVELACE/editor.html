<!doctype html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22%3E%3Ctext y=%22.9em%22 font-size=%2290%22%3E%F0%9F%A7%91%E2%80%8D%F0%9F%94%AC%3C/text%3E%3C/svg%3E">
  <title>–≠–º–æ–¥–∑–∏-–ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ</title>
  <script src="../section-auth.js"></script>
  <script>window.SectionAuth && window.SectionAuth.guardPage("LOVELACE");</script>
  <style>
    @font-face {
      font-family: "Noto Color Emoji";
      font-style: normal;
      font-weight: 400;
      font-display: swap;
      src:
        url("https://cdn.jsdelivr.net/fontsource/fonts/noto-color-emoji@latest/emoji-400-normal.woff2") format("woff2"),
        url("https://cdn.jsdelivr.net/fontsource/fonts/noto-color-emoji@latest/emoji-400-normal.ttf") format("truetype");
    }

    :root {
      --bg: #f3f4f6;
      --panel: #ffffff;
      --text: #111827;
      --muted: #6b7280;
      --border: #d1d5db;
      --accent: #0f766e;
      --accent-strong: #115e59;
      --danger-bg: #fee2e2;
      --danger-fg: #991b1b;
      --ok-bg: #dcfce7;
      --ok-fg: #166534;
      --warn-bg: #fef3c7;
      --warn-fg: #92400e;
      --emoji-font: "Noto Color Emoji", "Twemoji Mozilla", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Sans", "Segoe UI", sans-serif;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at 20% 0%, #ffffff, var(--bg));
      color: var(--text);
      font-family: "Segoe UI", "Noto Sans", sans-serif;
      padding: 20px;
    }

    .app {
      width: min(1320px, 100%);
      margin: 0 auto;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 18px;
      padding: 16px;
      box-shadow: 0 14px 30px rgba(17, 24, 39, 0.09);
      display: grid;
      gap: 12px;
    }

    .topbar {
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
    }

    .title {
      margin: 0;
      font-size: clamp(1.35rem, 2vw, 1.8rem);
      font-weight: 900;
      letter-spacing: -0.02em;
    }

    .back-link {
      text-decoration: none;
      border: 1px solid var(--border);
      border-radius: 10px;
      color: var(--text);
      background: #fff;
      padding: 8px 12px;
      font-weight: 700;
      transition: 120ms ease;
    }

    .back-link:hover {
      border-color: #9ca3af;
      transform: translateY(-1px);
    }

    .blocks {
      display: grid;
      gap: 12px;
    }

    .panel {
      border: 1px solid var(--border);
      border-radius: 14px;
      background: #fcfcfd;
      padding: 12px;
      display: grid;
      gap: 10px;
    }

    h2 {
      margin: 0;
      font-size: 1rem;
      font-weight: 800;
    }

    .block-title {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .block-num {
      width: 24px;
      height: 24px;
      border-radius: 999px;
      display: inline-grid;
      place-items: center;
      font-size: 12px;
      font-weight: 900;
      background: #e6fffa;
      color: #115e59;
      border: 1px solid #99f6e4;
      flex: 0 0 auto;
    }

    .switchers {
      display: grid;
      gap: 10px;
      grid-template-columns: 1fr 1fr;
    }

    .mini-title {
      font-size: 12px;
      font-weight: 800;
      letter-spacing: 0.02em;
      text-transform: uppercase;
      color: #475569;
      margin-bottom: 6px;
    }

    label {
      font-weight: 700;
      font-size: 14px;
    }

    textarea {
      width: 100%;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #fff;
      color: var(--text);
      padding: 10px 12px;
      outline: none;
      transition: 120ms ease;
      resize: vertical;
    }

    .text-input {
      width: 100%;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #fff;
      color: var(--text);
      padding: 10px 12px;
      outline: none;
      transition: 120ms ease;
      font: inherit;
    }

    .text-input:focus {
      border-color: #0ea5a4;
      box-shadow: 0 0 0 3px rgba(45, 212, 191, 0.2);
    }

    .text-input.is-valid {
      border-color: #16a34a;
      box-shadow: 0 0 0 3px rgba(74, 222, 128, 0.2);
    }

    .text-input.is-invalid {
      border-color: #dc2626;
      box-shadow: 0 0 0 3px rgba(252, 165, 165, 0.22);
    }

    textarea:focus {
      border-color: #0ea5a4;
      box-shadow: 0 0 0 3px rgba(45, 212, 191, 0.2);
    }

    .emoji-field {
      font-family: var(--emoji-font);
      font-size: 18px;
      line-height: 1.45;
    }

    .code-input {
      min-height: 320px;
    }

    .stdin-input {
      min-height: 84px;
      font-family: "Noto Sans", "Segoe UI", "Noto Color Emoji", "Twemoji Mozilla", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", sans-serif;
      font-size: 18px;
      line-height: 1.35;
      letter-spacing: 0;
      word-spacing: 0;
      font-variant-ligatures: none;
    }

    .output-box {
      min-height: 140px;
      font-family: "Noto Sans", "Segoe UI", "Noto Color Emoji", "Twemoji Mozilla", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", sans-serif;
      font-size: 18px;
      line-height: 1.35;
      letter-spacing: 0;
      word-spacing: 0;
      font-variant-ligatures: none;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .examples {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .task-grid,
    .subtask-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .subtask-grid {
      margin-top: 8px;
      min-height: 40px;
    }

    .subtask-grid[hidden] {
      display: none !important;
    }

    .tests-toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .test-list {
      display: grid;
      gap: 10px;
    }

    .test-item {
      border: 1px solid #dbeafe;
      background: #f8fafc;
      border-radius: 10px;
      padding: 10px;
      display: grid;
      gap: 8px;
    }

    .test-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }

    .test-label {
      font-size: 13px;
      font-weight: 800;
      color: #334155;
    }

    .test-output-grid {
      display: grid;
      gap: 10px;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
    }

    .test-output-card {
      border: 1px solid #e5e7eb;
      border-radius: 10px;
      background: #ffffff;
      padding: 10px;
      display: grid;
      gap: 8px;
    }

    .test-output-card.ok {
      border-color: #86efac;
      background: #f0fdf4;
    }

    .test-output-card.error {
      border-color: #fca5a5;
      background: #fef2f2;
    }

    .test-output-card.warn {
      border-color: #fcd34d;
      background: #fffbeb;
    }

    .test-output-meta {
      font-size: 12px;
      font-weight: 700;
      color: #475569;
    }

    button {
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #fff;
      color: var(--text);
      font: inherit;
      font-weight: 700;
      padding: 9px 12px;
      cursor: pointer;
      transition: 120ms ease;
    }

    button:hover {
      border-color: #9ca3af;
      transform: translateY(-1px);
    }

    button:disabled {
      opacity: 0.65;
      cursor: not-allowed;
      transform: none;
    }

    .switchers button[aria-pressed="true"] {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(15, 118, 110, 0.18);
    }

    .switchers button[aria-pressed="true"]:hover {
      background: var(--accent-strong);
      border-color: var(--accent-strong);
    }

    button.primary {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
    }

    button.primary:hover {
      background: var(--accent-strong);
      border-color: var(--accent-strong);
    }

    .status-box {
      border-radius: 10px;
      border: 1px solid var(--border);
      padding: 10px 12px;
      font-weight: 700;
      background: #f3f4f6;
      color: #1f2937;
      min-height: 44px;
      display: flex;
      align-items: center;
    }

    .status-box.ok {
      background: var(--ok-bg);
      color: var(--ok-fg);
      border-color: #86efac;
    }

    .status-box.error {
      background: var(--danger-bg);
      color: var(--danger-fg);
      border-color: #fca5a5;
    }

    .status-box.warn {
      background: var(--warn-bg);
      color: var(--warn-fg);
      border-color: #fcd34d;
    }

    .step-count {
      font-weight: 700;
      color: #1f2937;
      font-size: 14px;
    }

    .keyboard {
      display: grid;
      gap: 10px;
    }

    .emoji-group {
      border: 1px solid #e5e7eb;
      border-radius: 10px;
      background: #fff;
      padding: 10px;
    }

    .emoji-group.group-1 { background: linear-gradient(180deg, #ffffff, #f8fafc); }
    .emoji-group.group-2 { background: linear-gradient(180deg, #ffffff, #f9fafb); }
    .emoji-group.group-3 { background: linear-gradient(180deg, #ffffff, #f0fdfa); }

    .emoji-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(40px, 1fr));
      gap: 6px;
    }

    .emoji-btn {
      font-family: var(--emoji-font);
      font-size: 22px;
      line-height: 1;
      padding: 8px 6px;
      min-height: 40px;
      display: grid;
      place-items: center;
    }

    .vars-panel[hidden] {
      display: none !important;
    }

    @media (max-width: 1040px) {
      .switchers {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <main class="app">
    <header class="topbar">
      <h1 class="title">–≠–º–æ–¥–∑–∏-–ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ</h1>
      <a href="../index.html" class="back-link">–ù–∞ –≥–ª–∞–≤–Ω—É—é</a>
    </header>

    <section class="blocks">
      <section class="panel">
        <h2 class="block-title"><span class="block-num">0</span>–ü–µ—Ä–µ–∫–ª—é—á–∞–ª–∫–∏</h2>
        <div class="switchers">
          <section>
            <div class="mini-title">–ü—Ä–∏–º–µ—Ä—ã</div>
            <div class="examples">
              <button id="example1Btn" type="button" aria-pressed="false">–ü—Ä–∏–º–µ—Ä ‚Ññ1</button>
              <button id="example2Btn" type="button" aria-pressed="false">–ü—Ä–∏–º–µ—Ä ‚Ññ2</button>
              <button id="example3Btn" type="button" aria-pressed="false">–ü—Ä–∏–º–µ—Ä ‚Ññ3</button>
              <button id="example4Btn" type="button" aria-pressed="false">–ü—Ä–∏–º–µ—Ä ‚Ññ4</button>
              <button id="example5Btn" type="button" aria-pressed="false">–ü—Ä–∏–º–µ—Ä ‚Ññ5</button>
            </div>
          </section>
          <section>
            <div class="mini-title">–ó–∞–¥–∞–Ω–∏—è</div>
            <div id="taskButtons" class="task-grid">
              <button type="button" data-task="1" aria-pressed="false">–ó–∞–¥–∞–Ω–∏–µ 1</button>
              <button type="button" data-task="2" aria-pressed="false">–ó–∞–¥–∞–Ω–∏–µ 2</button>
              <button type="button" data-task="3" aria-pressed="false">–ó–∞–¥–∞–Ω–∏–µ 3</button>
              <button type="button" data-task="4" aria-pressed="false">–ó–∞–¥–∞–Ω–∏–µ 4</button>
            </div>
            <div id="taskSubtasks" class="subtask-grid" hidden></div>
          </section>
        </div>
      </section>

      <section class="panel">
        <h2 class="block-title"><span class="block-num">1</span>–†–µ–¥–∞–∫—Ç–æ—Ä –∫–æ–¥–∞</h2>
        <label for="codeInput">–ö–æ–¥</label>
        <textarea id="codeInput" class="emoji-field code-input" spellcheck="false" autocomplete="off" autocapitalize="off"></textarea>
      </section>

      <section class="panel">
        <h2 class="block-title"><span class="block-num">2</span>–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞</h2>
        <div id="emojiKeyboard" class="keyboard"></div>
      </section>

      <section class="panel">
        <h2 class="block-title"><span class="block-num">3</span>–¢–µ—Å—Ç—ã</h2>
        <div class="tests-toolbar">
          <button id="addTestBtn" type="button">–î–æ–±–∞–≤–∏—Ç—å —Ç–µ—Å—Ç</button>
          <button id="resetTestsBtn" type="button">–°–±—Ä–æ—Å–∏—Ç—å —Ç–µ—Å—Ç—ã</button>
        </div>
        <div id="testList" class="test-list"></div>
      </section>

      <section class="panel">
        <h2 class="block-title"><span class="block-num">4</span>–ó–∞–ø—É—Å–∫</h2>
        <div class="controls">
          <button id="runBtn" class="primary">–ó–∞–ø—É—Å—Ç–∏—Ç—å</button>
          <button id="resetBtn">–°–±—Ä–æ—Å</button>
        </div>
        <div id="statusBox" class="status-box">–û–∂–∏–¥–∞–Ω–∏–µ –∑–∞–ø—É—Å–∫–∞.</div>
        <div id="stepCount" class="step-count">–°—É–º–º–∞—Ä–Ω—ã–µ —à–∞–≥–∏: 0</div>
      </section>

      <section class="panel">
        <h2 class="block-title"><span class="block-num">5</span>–í—ã—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ø–æ —Ç–µ—Å—Ç–∞–º</h2>
        <div id="testOutputs" class="test-output-grid"></div>
      </section>

      <section id="codePhrasePanel" class="panel" hidden>
        <h2 class="block-title"><span class="block-num">6</span>–ö–æ–¥–æ–≤–∞—è —Ñ—Ä–∞–∑–∞</h2>
        <label for="codePhraseInput">–ö–æ–¥–æ–≤–∞—è —Ñ—Ä–∞–∑–∞</label>
        <input id="codePhraseInput" class="text-input" type="text" autocomplete="off" autocapitalize="off" spellcheck="false" placeholder="–í–≤–µ–¥–∏—Ç–µ –∫–æ–¥–æ–≤—É—é —Ñ—Ä–∞–∑—É">
        <p class="hint">–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –≤ –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö —Å—Ü–µ–Ω–∞—Ä–∏—è—Ö.</p>
        <p id="codePhraseStatus" class="hint"></p>
      </section>
    </section>

    <section class="vars-panel" hidden>
      <h2>–°–æ—Å—Ç–æ—è–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö</h2>
      <div id="varsGrid"></div>
    </section>
  </main>

  <script>
    const COMMAND_EMOJIS = ["üåû", "‚≠ê", "üé≤", "üòÄ", "‚ûï", "‚ûñ", "‚úñ", "‚ûó", "‚û∞", "ü§î", "üîÇ", "üîÅ", "üòê"];
    const VARIABLE_EMOJIS = [
      "‚ôà", "‚ôâ", "‚ôä", "‚ôã", "‚ôå", "‚ôç", "‚ôé", "‚ôè", "‚ôê", "‚ôë", "‚ôí", "‚ôì",
      "üïê", "üïë", "üïí", "üïì", "üïî", "üïï", "üïñ", "üïó", "üïò", "üïô", "üïö", "üïõ",
      "üö®"
    ];
    const DIGIT_EMOJIS = ["üÜö", "üìå", "‚úå", "ü§ü", "ü§û", "üñê", "ü§ò", "üëå", "üëç", "üëä"];
    const DIGIT_TO_VALUE = new Map(DIGIT_EMOJIS.map((emoji, idx) => [emoji, String(idx)]));

    const KEYBOARD_GROUPS = [COMMAND_EMOJIS, VARIABLE_EMOJIS, DIGIT_EMOJIS];

    const EXAMPLES = [
      {
        code: [
          "‚≠ê‚ôà",
          "üòÄ‚ôà"
        ].join("\n"),
        tests: ["7", "42", "105"]
      },
      {
        code: [
          "üåû‚ôàüìåüÜö",
          "üåû‚ôâ‚úå",
          "‚úñ‚ôà‚ôâ",
          "üåû‚ôäüìå",
          "‚ûñ‚ôà‚ôä",
          "üòÄ‚ôà"
        ].join("\n"),
        tests: ["", "1", "55"]
      },
      {
        code: [
          "‚≠ê‚ôà",
          "üåû‚ôâüìå",
          "ü§î‚ôà‚ôâ",
          "üåû‚ôäüëä",
          "üòÄ‚ôä",
          "üòê"
        ].join("\n"),
        tests: ["1", "2", "0", "10", "37"]
      },
      {
        code: [
          "‚≠ê‚ôà",
          "üåû‚ôâüÜö",
          "üåû‚ôäüìå",
          "üîÇ‚ôà",
          "‚ûï‚ôâ‚ôà",
          "‚ûñ‚ôà‚ôä",
          "üòê",
          "üòÄ‚ôâ"
        ].join("\n"),
        tests: ["1", "2", "4", "6", "8"]
      },
      {
        code: [
          "‚≠ê‚ôà",
          "üåû‚ôâüÜö",
          "üåû‚ôäüÜö",
          "üåû‚ôãüìå",
          "üîÅ‚ôä‚ôà",
          "‚ûï‚ôä‚ôã",
          "‚ûï‚ôâ‚ôä",
          "üòê",
          "üòÄ‚ôâ"
        ].join("\n"),
        tests: ["0", "1", "3", "4", "7"]
      }
    ];

    const HARD_STEP_LIMIT = 200000;
    const YIELD_EVERY = 1500;
    const CODE_PHRASE_VISIBLE_SCENARIOS = new Set([
      // "example:3",
      // "task:2.1",
    ]);
    const CODE_PHRASE_PEPPER = "secmod-2026-k0";
    const CODE_PHRASE_HASH_CONFIG = Object.freeze({
      // "task:2.1": { salt: "s_task_2_1_phrase_v1", hash: "..." },
      // "task:2.1": { salt: "s_task_2_1_phrase_v1", hashes: ["...", "..."] },
    });

    const codeInputEl = document.getElementById("codeInput");
    const runBtn = document.getElementById("runBtn");
    const resetBtn = document.getElementById("resetBtn");
    const addTestBtn = document.getElementById("addTestBtn");
    const resetTestsBtn = document.getElementById("resetTestsBtn");
    const testListEl = document.getElementById("testList");
    const testOutputsEl = document.getElementById("testOutputs");
    const example1Btn = document.getElementById("example1Btn");
    const example2Btn = document.getElementById("example2Btn");
    const example3Btn = document.getElementById("example3Btn");
    const example4Btn = document.getElementById("example4Btn");
    const example5Btn = document.getElementById("example5Btn");
    const taskButtonsEl = document.getElementById("taskButtons");
    const taskSubtasksEl = document.getElementById("taskSubtasks");
    const statusBoxEl = document.getElementById("statusBox");
    const stepCountEl = document.getElementById("stepCount");
    const emojiKeyboardEl = document.getElementById("emojiKeyboard");
    const codePhrasePanelEl = document.getElementById("codePhrasePanel");
    const codePhraseInputEl = document.getElementById("codePhraseInput");
    const codePhraseStatusEl = document.getElementById("codePhraseStatus");

    const VARIABLE_SET = new Set(VARIABLE_EMOJIS);
    const exampleButtons = [example1Btn, example2Btn, example3Btn, example4Btn, example5Btn];
    const taskButtons = Array.from(taskButtonsEl.querySelectorAll("[data-task]"));
    let lastFocusedField = codeInputEl;
    let currentScenarioKey = "";
    let selectedExampleIndex = -1;
    let selectedTaskKey = "";
    let selectedSubtaskKey = "";
    let codePhraseCheckNonce = 0;

    function makeError(kind, line, message) {
      const err = new Error(message);
      err.kind = kind;
      err.line = line;
      return err;
    }

    function normalizeCodeLine(line) {
      return String(line || "").replace(/\uFE0F/g, "").replace(/\s+/g, "");
    }

    function requireVariable(symbol, line) {
      if (!VARIABLE_SET.has(symbol)) {
        throw makeError("parse", line, `–û–∂–∏–¥–∞–ª–∞—Å—å –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è, –ø–æ–ª—É—á–µ–Ω–æ: ${symbol || "–ø—É—Å—Ç–æ"}.`);
      }
      return symbol;
    }

    function parseEmojiNumber(emojis, line) {
      if (!emojis.length) {
        throw makeError("parse", line, "–ö–æ–º–∞–Ω–¥–∞ üåû —Ç—Ä–µ–±—É–µ—Ç —Ö–æ—Ç—è –±—ã –æ–¥–Ω—É emoji-—Ü–∏—Ñ—Ä—É.");
      }
      let valueText = "";
      for (let i = 0; i < emojis.length; i++) {
        const value = DIGIT_TO_VALUE.get(emojis[i]);
        if (typeof value !== "string") {
          throw makeError("parse", line, `–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è emoji-—Ü–∏—Ñ—Ä–∞: ${emojis[i]}.`);
        }
        valueText += value;
      }
      const numeric = Number(valueText);
      if (!Number.isFinite(numeric)) {
        throw makeError("parse", line, `–ß–∏—Å–ª–æ –Ω–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å: ${valueText}.`);
      }
      return Math.trunc(numeric);
    }

    function parseProgram(source) {
      const lines = String(source || "").replace(/\r\n?/g, "\n").split("\n");
      const instructions = [];
      const blockStack = [];

      for (let idx = 0; idx < lines.length; idx++) {
        const lineNo = idx + 1;
        const compactLine = normalizeCodeLine(lines[idx]);
        if (!compactLine) continue;

        const tokens = Array.from(compactLine);
        const op = tokens[0];

        if (op === "üåû") {
          if (tokens.length < 3) {
            throw makeError("parse", lineNo, "–ö–æ–º–∞–Ω–¥–∞ üåû —Ç—Ä–µ–±—É–µ—Ç —Ñ–æ—Ä–º–∞—Ç: üåû<–ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è><emoji-—á–∏—Å–ª–æ>.");
          }
          const target = requireVariable(tokens[1], lineNo);
          const value = parseEmojiNumber(tokens.slice(2), lineNo);
          instructions.push({ type: "set", target, value, line: lineNo });
          continue;
        }

        if (op === "‚≠ê") {
          if (tokens.length !== 2) throw makeError("parse", lineNo, "–ö–æ–º–∞–Ω–¥–∞ ‚≠ê —Ç—Ä–µ–±—É–µ—Ç —Ñ–æ—Ä–º–∞—Ç: ‚≠ê<–ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è>.");
          instructions.push({ type: "readNumber", target: requireVariable(tokens[1], lineNo), line: lineNo });
          continue;
        }

        if (op === "üé≤") {
          if (tokens.length !== 4) throw makeError("parse", lineNo, "–ö–æ–º–∞–Ω–¥–∞ üé≤ —Ç—Ä–µ–±—É–µ—Ç —Ñ–æ—Ä–º–∞—Ç: üé≤<–ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è><lowVar><highVar>.");
          instructions.push({
            type: "random",
            target: requireVariable(tokens[1], lineNo),
            low: requireVariable(tokens[2], lineNo),
            high: requireVariable(tokens[3], lineNo),
            line: lineNo
          });
          continue;
        }

        if (op === "üòÄ") {
          if (tokens.length !== 2) throw makeError("parse", lineNo, "–ö–æ–º–∞–Ω–¥–∞ üòÄ —Ç—Ä–µ–±—É–µ—Ç —Ñ–æ—Ä–º–∞—Ç: üòÄ<–ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è>.");
          instructions.push({ type: "printNumber", target: requireVariable(tokens[1], lineNo), line: lineNo });
          continue;
        }

        if (op === "‚ûï" || op === "‚ûñ" || op === "‚úñ" || op === "‚ûó" || op === "‚û∞") {
          if (tokens.length !== 3) {
            throw makeError("parse", lineNo, `–ö–æ–º–∞–Ω–¥–∞ ${op} —Ç—Ä–µ–±—É–µ—Ç —Ñ–æ—Ä–º–∞—Ç: ${op}<–ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è><–ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è>.`);
          }
          instructions.push({
            type: "math",
            op,
            left: requireVariable(tokens[1], lineNo),
            right: requireVariable(tokens[2], lineNo),
            line: lineNo
          });
          continue;
        }

        if (op === "ü§î") {
          if (tokens.length !== 3) throw makeError("parse", lineNo, "–ö–æ–º–∞–Ω–¥–∞ ü§î —Ç—Ä–µ–±—É–µ—Ç —Ñ–æ—Ä–º–∞—Ç: ü§î<–ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è><–ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è>.");
          instructions.push({
            type: "ifEq",
            left: requireVariable(tokens[1], lineNo),
            right: requireVariable(tokens[2], lineNo),
            jumpTo: -1,
            line: lineNo
          });
          blockStack.push({ type: "if", index: instructions.length - 1 });
          continue;
        }

        if (op === "üîÇ") {
          if (tokens.length !== 2) throw makeError("parse", lineNo, "–ö–æ–º–∞–Ω–¥–∞ üîÇ —Ç—Ä–µ–±—É–µ—Ç —Ñ–æ—Ä–º–∞—Ç: üîÇ<–ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è>.");
          instructions.push({
            type: "loopCount",
            count: requireVariable(tokens[1], lineNo),
            jumpTo: -1,
            line: lineNo
          });
          blockStack.push({ type: "loopCount", index: instructions.length - 1 });
          continue;
        }

        if (op === "üîÅ") {
          if (tokens.length !== 3) throw makeError("parse", lineNo, "–ö–æ–º–∞–Ω–¥–∞ üîÅ —Ç—Ä–µ–±—É–µ—Ç —Ñ–æ—Ä–º–∞—Ç: üîÅ<–ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è><–ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è>.");
          instructions.push({
            type: "loopNeq",
            left: requireVariable(tokens[1], lineNo),
            right: requireVariable(tokens[2], lineNo),
            jumpTo: -1,
            line: lineNo
          });
          blockStack.push({ type: "loopNeq", index: instructions.length - 1 });
          continue;
        }

        if (op === "üòê") {
          if (tokens.length !== 1) throw makeError("parse", lineNo, "–ö–æ–º–∞–Ω–¥–∞ üòê –Ω–µ –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –∞—Ä–≥—É–º–µ–Ω—Ç—ã.");
          if (!blockStack.length) throw makeError("parse", lineNo, "–õ–∏—à–Ω–∏–π üòê –±–µ–∑ –æ—Ç–∫—Ä—ã–≤–∞—é—â–µ–≥–æ ü§î, üîÇ –∏–ª–∏ üîÅ.");
          const block = blockStack.pop();
          if (block.type === "if") {
            instructions.push({ type: "ifEnd", ifIndex: block.index, line: lineNo });
          } else if (block.type === "loopCount") {
            instructions.push({ type: "loopCountEnd", loopIndex: block.index, line: lineNo });
          } else {
            instructions.push({ type: "loopEnd", loopIndex: block.index, line: lineNo });
          }
          const endIndex = instructions.length - 1;
          instructions[block.index].jumpTo = endIndex + 1;
          continue;
        }

        throw makeError("parse", lineNo, `–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞: ${op}.`);
      }

      if (blockStack.length) {
        const firstBlock = blockStack[0];
        const firstUnclosed = instructions[firstBlock.index];
        const opener = firstBlock.type === "if" ? "ü§î" : (firstBlock.type === "loopCount" ? "üîÇ" : "üîÅ");
        throw makeError("parse", firstUnclosed.line, `–ë–ª–æ–∫ ${opener} –Ω–µ –∑–∞–∫—Ä—ã—Ç –∫–æ–º–∞–Ω–¥–æ–π üòê.`);
      }

      return instructions;
    }

    function initialVariables() {
      const out = {};
      for (let i = 0; i < VARIABLE_EMOJIS.length; i++) out[VARIABLE_EMOJIS[i]] = 0;
      return out;
    }

    function assertFiniteNumber(value, line, context) {
      if (!Number.isFinite(value)) {
        throw makeError("runtime", line, `${context}: –ø–æ–ª—É—á–µ–Ω–æ –Ω–µ—á–∏—Å–ª–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ.`);
      }
      return Math.trunc(value);
    }

    function isAsciiDigit(ch) {
      return ch >= "0" && ch <= "9";
    }

    function readNextInputNumber(inputText, state, line) {
      let idx = state.index;
      while (idx < inputText.length && /\s/u.test(inputText[idx])) idx += 1;

      if (idx >= inputText.length) {
        throw makeError("runtime", line, "–ö–æ–º–∞–Ω–¥–∞ ‚≠ê –Ω–µ –º–æ–∂–µ—Ç —á–∏—Ç–∞—Ç—å –∏–∑ –ø—É—Å—Ç—ã—Ö –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö.");
      }

      let valueText = "";
      while (idx < inputText.length && isAsciiDigit(inputText[idx])) {
        valueText += inputText[idx];
        idx += 1;
      }

      if (!valueText) {
        const got = inputText[idx];
        throw makeError("runtime", line, `–ö–æ–º–∞–Ω–¥–∞ ‚≠ê –æ–∂–∏–¥–∞–µ—Ç —á–∏—Å–ª–æ, –ø–æ–ª—É—á–µ–Ω–æ: ${got}.`);
      }

      state.index = idx;
      const parsed = Number(valueText);
      return assertFiniteNumber(parsed, line, "–ö–æ–º–∞–Ω–¥–∞ ‚≠ê");
    }

    function setStatus(kind, message) {
      statusBoxEl.className = `status-box ${kind}`;
      statusBoxEl.textContent = message;
    }

    async function sha256Hex(text) {
      const data = new TextEncoder().encode(String(text || ""));
      const digest = await crypto.subtle.digest("SHA-256", data);
      const bytes = new Uint8Array(digest);
      let out = "";
      for (let i = 0; i < bytes.length; i++) out += bytes[i].toString(16).padStart(2, "0");
      return out;
    }

    function safeEqual(a, b) {
      if (typeof a !== "string" || typeof b !== "string" || a.length !== b.length) return false;
      let diff = 0;
      for (let i = 0; i < a.length; i++) diff |= a.charCodeAt(i) ^ b.charCodeAt(i);
      return diff === 0;
    }

    function getCodePhraseRule(scenarioKey) {
      const raw = CODE_PHRASE_HASH_CONFIG[scenarioKey];
      if (!raw || typeof raw !== "object") return null;
      const salt = typeof raw.salt === "string" ? raw.salt : "";
      if (!salt) return null;
      const hashes = [];
      if (typeof raw.hash === "string" && raw.hash) hashes.push(raw.hash);
      if (Array.isArray(raw.hashes)) {
        for (const h of raw.hashes) {
          if (typeof h === "string" && h) hashes.push(h);
        }
      }
      if (!hashes.length) return null;
      return { salt, hashes };
    }

    function clearCodePhraseValidation() {
      if (!codePhraseInputEl) return;
      codePhraseInputEl.classList.remove("is-valid", "is-invalid");
      if (codePhraseStatusEl) codePhraseStatusEl.textContent = "";
    }

    async function validateCodePhraseInput() {
      if (!codePhraseInputEl || !codePhrasePanelEl || codePhrasePanelEl.hidden) return;
      const rule = getCodePhraseRule(currentScenarioKey);
      const entered = String(codePhraseInputEl.value || "");

      clearCodePhraseValidation();
      if (!rule || !entered) return;

      const nonce = ++codePhraseCheckNonce;
      const hash = await sha256Hex(`${currentScenarioKey}|${rule.salt}|${entered}|${CODE_PHRASE_PEPPER}`);
      if (nonce !== codePhraseCheckNonce) return;

      let matched = false;
      for (const allowedHash of rule.hashes) {
        if (safeEqual(hash, allowedHash)) {
          matched = true;
          break;
        }
      }

      codePhraseInputEl.classList.toggle("is-valid", matched);
      codePhraseInputEl.classList.toggle("is-invalid", !matched);
      if (codePhraseStatusEl) {
        codePhraseStatusEl.textContent = matched ? "–ö–æ–¥–æ–≤–∞—è —Ñ—Ä–∞–∑–∞ –≤–µ—Ä–Ω–∞." : "–ö–æ–¥–æ–≤–∞—è —Ñ—Ä–∞–∑–∞ –Ω–µ —Å–æ–≤–ø–∞–¥–∞–µ—Ç.";
      }
    }

    function setPressedState(button, isPressed) {
      if (!button) return;
      button.setAttribute("aria-pressed", isPressed ? "true" : "false");
    }

    function syncExampleButtons() {
      for (let i = 0; i < exampleButtons.length; i++) {
        setPressedState(exampleButtons[i], i === selectedExampleIndex);
      }
    }

    function syncTaskButtons() {
      for (const btn of taskButtons) {
        const taskKey = String(btn.dataset.task || "");
        setPressedState(btn, taskKey === selectedTaskKey && selectedTaskKey !== "");
      }
    }

    function syncSubtaskButtons() {
      const subtaskButtons = Array.from(taskSubtasksEl.querySelectorAll("[data-subtask]"));
      for (const btn of subtaskButtons) {
        const key = String(btn.dataset.subtask || "");
        setPressedState(btn, key === selectedSubtaskKey && selectedSubtaskKey !== "");
      }
    }

    function clearSubtasks() {
      selectedSubtaskKey = "";
      taskSubtasksEl.textContent = "";
      taskSubtasksEl.hidden = true;
    }

    function renderSubtasks(taskKey) {
      taskSubtasksEl.textContent = "";
      for (let i = 1; i <= 4; i++) {
        const subtaskKey = `${taskKey}.${i}`;
        const btn = document.createElement("button");
        btn.type = "button";
        btn.dataset.subtask = subtaskKey;
        btn.setAttribute("aria-pressed", "false");
        btn.textContent = `–ü–æ–¥–∑–∞–¥–∞—á–∞ ${subtaskKey}`;
        btn.addEventListener("click", () => {
          selectedSubtaskKey = subtaskKey;
          syncSubtaskButtons();
          setScenarioKey(`task:${subtaskKey}`);
        });
        taskSubtasksEl.appendChild(btn);
      }
      taskSubtasksEl.hidden = false;
      syncSubtaskButtons();
    }

    function setScenarioKey(key) {
      currentScenarioKey = String(key || "");
      const visible = CODE_PHRASE_VISIBLE_SCENARIOS.has(currentScenarioKey);
      if (codePhrasePanelEl) codePhrasePanelEl.hidden = !visible;
      codePhraseCheckNonce += 1;
      if (codePhraseInputEl) codePhraseInputEl.value = "";
      clearCodePhraseValidation();
    }

    function resetResultPanels() {
      setStatus("", "–û–∂–∏–¥–∞–Ω–∏–µ –∑–∞–ø—É—Å–∫–∞.");
      stepCountEl.textContent = "–°—É–º–º–∞—Ä–Ω—ã–µ —à–∞–≥–∏: 0";
      testOutputsEl.textContent = "";
    }

    function createTestItem(inputText = "") {
      const wrap = document.createElement("section");
      wrap.className = "test-item";

      const head = document.createElement("div");
      head.className = "test-head";

      const label = document.createElement("div");
      label.className = "test-label";
      label.dataset.testLabel = "1";

      const removeBtn = document.createElement("button");
      removeBtn.type = "button";
      removeBtn.textContent = "–£–¥–∞–ª–∏—Ç—å";
      removeBtn.dataset.testRemove = "1";
      removeBtn.addEventListener("click", () => {
        wrap.remove();
        renumberTests();
        resetResultPanels();
      });

      head.appendChild(label);
      head.appendChild(removeBtn);

      const input = document.createElement("textarea");
      input.className = "stdin-input";
      input.spellcheck = false;
      input.autocomplete = "off";
      input.autocapitalize = "off";
      input.dataset.testInput = "1";
      input.value = String(inputText || "");

      wrap.appendChild(head);
      wrap.appendChild(input);
      return wrap;
    }

    function renumberTests() {
      const tests = Array.from(testListEl.querySelectorAll(".test-item"));
      if (!tests.length) {
        testListEl.appendChild(createTestItem(""));
        return renumberTests();
      }
      for (let i = 0; i < tests.length; i++) {
        const item = tests[i];
        const label = item.querySelector("[data-test-label]");
        const removeBtn = item.querySelector("[data-test-remove]");
        if (label) label.textContent = `–¢–µ—Å—Ç ${i + 1}`;
        if (removeBtn) removeBtn.disabled = tests.length === 1;
      }
    }

    function getTestsFromUi() {
      const fields = Array.from(testListEl.querySelectorAll("[data-test-input]"));
      return fields.map((field) => String(field.value || ""));
    }

    function setTestsToUi(inputs) {
      testListEl.textContent = "";
      const list = Array.isArray(inputs) && inputs.length ? inputs : [""];
      for (const text of list) {
        testListEl.appendChild(createTestItem(text));
      }
      renumberTests();
    }

    function renderOutputs(results) {
      testOutputsEl.textContent = "";
      for (let i = 0; i < results.length; i++) {
        const result = results[i];
        const card = document.createElement("section");
        card.className = `test-output-card ${result.kind}`;

        const title = document.createElement("div");
        title.className = "test-label";
        title.textContent = `–¢–µ—Å—Ç ${i + 1}`;

        const meta = document.createElement("div");
        meta.className = "test-output-meta";
        meta.textContent = result.meta;

        const out = document.createElement("textarea");
        out.className = "output-box";
        out.readOnly = true;
        out.value = result.value;

        card.appendChild(title);
        card.appendChild(meta);
        card.appendChild(out);
        testOutputsEl.appendChild(card);
      }
    }

    function initTaskPlaceholders() {
      syncExampleButtons();
      syncTaskButtons();
      clearSubtasks();

      for (const btn of taskButtons) {
        btn.addEventListener("click", () => {
          const taskKey = String(btn.dataset.task || "");
          if (!taskKey) return;
          selectedExampleIndex = -1;
          selectedTaskKey = taskKey;
          selectedSubtaskKey = "";
          syncExampleButtons();
          syncTaskButtons();
          renderSubtasks(taskKey);
          setScenarioKey(`task:${taskKey}`);
        });
      }
    }

    async function executeProgram(instructions, inputText) {
      const vars = initialVariables();
      const normalizedInput = String(inputText || "");
      const inputState = { index: 0 };
      const loopCountState = new Map();
      let output = "";
      let pc = 0;
      let steps = 0;

      while (pc < instructions.length) {
        if (steps >= HARD_STEP_LIMIT) {
          return {
            status: "limit",
            message: `–ü—Ä–µ–≤—ã—à–µ–Ω –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –ª–∏–º–∏—Ç —à–∞–≥–æ–≤ (${HARD_STEP_LIMIT}).`,
            steps,
            output,
            vars
          };
        }

        const ins = instructions[pc];
        steps += 1;

        if (ins.type === "set") {
          vars[ins.target] = ins.value;
          pc += 1;
        } else if (ins.type === "readNumber") {
          vars[ins.target] = readNextInputNumber(normalizedInput, inputState, ins.line);
          pc += 1;
        } else if (ins.type === "random") {
          const low = assertFiniteNumber(vars[ins.low], ins.line, "–ö–æ–º–∞–Ω–¥–∞ üé≤ (–Ω–∏–∂–Ω—è—è –≥—Ä–∞–Ω–∏—Ü–∞)");
          const high = assertFiniteNumber(vars[ins.high], ins.line, "–ö–æ–º–∞–Ω–¥–∞ üé≤ (–≤–µ—Ä—Ö–Ω—è—è –≥—Ä–∞–Ω–∏—Ü–∞)");
          if (low > high) {
            throw makeError("runtime", ins.line, `–ö–æ–º–∞–Ω–¥–∞ üé≤: low (${low}) –±–æ–ª—å—à–µ high (${high}).`);
          }
          const value = low + Math.floor(Math.random() * (high - low + 1));
          vars[ins.target] = assertFiniteNumber(value, ins.line, "–ö–æ–º–∞–Ω–¥–∞ üé≤ (—Ä–µ–∑—É–ª—å—Ç–∞—Ç)");
          pc += 1;
        } else if (ins.type === "printNumber") {
          const value = assertFiniteNumber(vars[ins.target], ins.line, "–ö–æ–º–∞–Ω–¥–∞ üòÄ");
          output += String(value);
          pc += 1;
        } else if (ins.type === "math") {
          const left = assertFiniteNumber(vars[ins.left], ins.line, `–ö–æ–º–∞–Ω–¥–∞ ${ins.op}`);
          const right = assertFiniteNumber(vars[ins.right], ins.line, `–ö–æ–º–∞–Ω–¥–∞ ${ins.op}`);
          let result = 0;

          if (ins.op === "‚ûï") result = left + right;
          else if (ins.op === "‚ûñ") result = left - right;
          else if (ins.op === "‚úñ") result = left * right;
          else if (ins.op === "‚ûó") {
            if (right === 0) throw makeError("runtime", ins.line, "–ö–æ–º–∞–Ω–¥–∞ ‚ûó: –¥–µ–ª–µ–Ω–∏–µ –Ω–∞ –Ω–æ–ª—å.");
            result = Math.trunc(left / right);
          } else if (ins.op === "‚û∞") {
            if (right === 0) throw makeError("runtime", ins.line, "–ö–æ–º–∞–Ω–¥–∞ ‚û∞: –¥–µ–ª–µ–Ω–∏–µ –Ω–∞ –Ω–æ–ª—å.");
            result = left % right;
          }

          vars[ins.left] = assertFiniteNumber(result, ins.line, `–ö–æ–º–∞–Ω–¥–∞ ${ins.op}`);
          pc += 1;
        } else if (ins.type === "ifEq") {
          const left = assertFiniteNumber(vars[ins.left], ins.line, "–ö–æ–º–∞–Ω–¥–∞ ü§î");
          const right = assertFiniteNumber(vars[ins.right], ins.line, "–ö–æ–º–∞–Ω–¥–∞ ü§î");
          if (left === right) pc += 1;
          else pc = ins.jumpTo;
        } else if (ins.type === "loopCount") {
          if (!loopCountState.has(pc)) {
            const total = assertFiniteNumber(vars[ins.count], ins.line, "–ö–æ–º–∞–Ω–¥–∞ üîÇ");
            loopCountState.set(pc, total);
          }
          const remaining = loopCountState.get(pc);
          if (remaining > 0) {
            loopCountState.set(pc, remaining - 1);
            pc += 1;
          } else {
            loopCountState.delete(pc);
            pc = ins.jumpTo;
          }
        } else if (ins.type === "loopNeq") {
          const left = assertFiniteNumber(vars[ins.left], ins.line, "–ö–æ–º–∞–Ω–¥–∞ üîÅ");
          const right = assertFiniteNumber(vars[ins.right], ins.line, "–ö–æ–º–∞–Ω–¥–∞ üîÅ");
          if (left !== right) pc += 1;
          else pc = ins.jumpTo;
        } else if (ins.type === "ifEnd") {
          pc += 1;
        } else if (ins.type === "loopCountEnd") {
          pc = ins.loopIndex;
        } else if (ins.type === "loopEnd") {
          pc = ins.loopIndex;
        } else {
          throw makeError("runtime", ins.line, `–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è —Ç–∏–ø–∞ ${ins.type}.`);
        }

        if (steps % YIELD_EVERY === 0) {
          await new Promise((resolve) => setTimeout(resolve, 0));
        }
      }

      return {
        status: "ok",
        message: "–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ.",
        steps,
        output,
        vars
      };
    }

    function updateFocusTarget(target) {
      if (target === codeInputEl) lastFocusedField = target;
    }

    function resolveInsertTarget() {
      if (lastFocusedField === codeInputEl) return lastFocusedField;
      return codeInputEl;
    }

    function insertEmoji(emoji) {
      const target = resolveInsertTarget();
      target.focus();
      const start = typeof target.selectionStart === "number" ? target.selectionStart : target.value.length;
      const end = typeof target.selectionEnd === "number" ? target.selectionEnd : target.value.length;
      target.setRangeText(emoji, start, end, "end");
      updateFocusTarget(target);
    }

    function renderKeyboard() {
      emojiKeyboardEl.textContent = "";
      for (let i = 0; i < KEYBOARD_GROUPS.length; i++) {
        const group = KEYBOARD_GROUPS[i];
        const groupEl = document.createElement("section");
        groupEl.className = `emoji-group group-${i + 1}`;

        const gridEl = document.createElement("div");
        gridEl.className = "emoji-grid";

        for (let j = 0; j < group.length; j++) {
          const emoji = group[j];
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "emoji-btn";
          btn.textContent = emoji;
          btn.title = `–í—Å—Ç–∞–≤–∏—Ç—å ${emoji}`;
          btn.addEventListener("mousedown", (event) => {
            event.preventDefault();
          });
          btn.addEventListener("click", () => {
            insertEmoji(emoji);
          });
          gridEl.appendChild(btn);
        }

        groupEl.appendChild(gridEl);
        emojiKeyboardEl.appendChild(groupEl);
      }
    }

    async function handleRun() {
      runBtn.disabled = true;
      setStatus("", "–ü–∞—Ä—Å–∏–Ω–≥ –ø—Ä–æ–≥—Ä–∞–º–º—ã...");
      stepCountEl.textContent = "–°—É–º–º–∞—Ä–Ω—ã–µ —à–∞–≥–∏: 0";

      const tests = getTestsFromUi();
      const hasAtLeastOneTest = tests.length > 0;
      if (!hasAtLeastOneTest) {
        setTestsToUi([""]);
      }
      const safeTests = hasAtLeastOneTest ? tests : [""];

      let instructions = [];
      try {
        instructions = parseProgram(codeInputEl.value);
      } catch (err) {
        const msg = err && (err.kind === "parse" || err.kind === "runtime")
          ? `–°—Ç—Ä–æ–∫–∞ ${err.line}: ${err.message}`
          : "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞.";
        const failResults = safeTests.map(() => ({
          kind: "error",
          meta: "–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –ø—Ä–æ–≥—Ä–∞–º–º—ã",
          value: msg
        }));
        renderOutputs(failResults);
        setStatus("error", msg);
        runBtn.disabled = false;
        return;
      }

      setStatus("", `–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏–π: ${instructions.length}. –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —Ç–µ—Å—Ç–æ–≤...`);

      const results = [];
      let totalSteps = 0;
      let okCount = 0;
      let warnCount = 0;
      let errCount = 0;

      for (let i = 0; i < safeTests.length; i++) {
        try {
          const result = await executeProgram(instructions, safeTests[i]);
          totalSteps += result.steps;
          if (result.status === "ok") {
            okCount += 1;
            results.push({
              kind: "ok",
              meta: `–£—Å–ø–µ—Ö. –®–∞–≥–∏: ${result.steps}`,
              value: result.output
            });
          } else if (result.status === "limit") {
            warnCount += 1;
            results.push({
              kind: "warn",
              meta: `–õ–∏–º–∏—Ç —à–∞–≥–æ–≤. –®–∞–≥–∏: ${result.steps}`,
              value: result.output
            });
          } else {
            warnCount += 1;
            results.push({
              kind: "warn",
              meta: `–ù–µ–æ–±—ã—á–Ω—ã–π —Å—Ç–∞—Ç—É—Å. –®–∞–≥–∏: ${result.steps}`,
              value: result.output
            });
          }
        } catch (err) {
          errCount += 1;
          const msg = err && (err.kind === "parse" || err.kind === "runtime")
            ? `–°—Ç—Ä–æ–∫–∞ ${err.line}: ${err.message}`
            : "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è.";
          results.push({
            kind: "error",
            meta: "–û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è",
            value: msg
          });
        }
      }

      renderOutputs(results);
      stepCountEl.textContent = `–°—É–º–º–∞—Ä–Ω—ã–µ —à–∞–≥–∏: ${totalSteps}`;
      if (errCount > 0) {
        setStatus("error", `–ì–æ—Ç–æ–≤–æ: —É—Å–ø–µ—Ö ${okCount}, –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è ${warnCount}, –æ—à–∏–±–∫–∏ ${errCount}.`);
      } else if (warnCount > 0) {
        setStatus("warn", `–ì–æ—Ç–æ–≤–æ: —É—Å–ø–µ—Ö ${okCount}, –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è ${warnCount}.`);
      } else {
        setStatus("ok", `–ì–æ—Ç–æ–≤–æ: –≤—Å–µ ${okCount} —Ç–µ—Å—Ç(–∞/–æ–≤) –≤—ã–ø–æ–ª–Ω–µ–Ω—ã —É—Å–ø–µ—à–Ω–æ.`);
      }
      runBtn.disabled = false;
    }

    function handleReset() {
      resetResultPanels();
    }

    function applyExample(index) {
      const item = EXAMPLES[index];
      if (!item) return;
      selectedExampleIndex = index;
      selectedTaskKey = "";
      syncExampleButtons();
      syncTaskButtons();
      clearSubtasks();
      codeInputEl.value = item.code;
      setTestsToUi(item.tests);
      setScenarioKey(`example:${index + 1}`);
      codeInputEl.focus();
      updateFocusTarget(codeInputEl);
      resetResultPanels();
    }

    for (const el of [codeInputEl]) {
      el.addEventListener("focus", () => updateFocusTarget(el));
      el.addEventListener("click", () => updateFocusTarget(el));
      el.addEventListener("keyup", () => updateFocusTarget(el));
    }

    runBtn.addEventListener("click", () => {
      handleRun();
    });
    resetBtn.addEventListener("click", handleReset);
    for (let i = 0; i < exampleButtons.length; i++) {
      exampleButtons[i].addEventListener("click", () => applyExample(i));
    }
    addTestBtn.addEventListener("click", () => {
      testListEl.appendChild(createTestItem(""));
      renumberTests();
      resetResultPanels();
    });
    resetTestsBtn.addEventListener("click", () => {
      setTestsToUi([""]);
      resetResultPanels();
    });
    if (codePhraseInputEl) {
      codePhraseInputEl.addEventListener("input", () => {
        validateCodePhraseInput();
      });
    }

    renderKeyboard();
    initTaskPlaceholders();
    setTestsToUi([""]);
    setScenarioKey("");
    resetResultPanels();
    codeInputEl.focus();
    updateFocusTarget(codeInputEl);
  </script>
</body>
</html>
