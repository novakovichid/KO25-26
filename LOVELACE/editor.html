<!doctype html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22%3E%3Ctext y=%22.9em%22 font-size=%2290%22%3E%F0%9F%A7%91%E2%80%8D%F0%9F%94%AC%3C/text%3E%3C/svg%3E">
  <title>–≠–º–æ–¥–∑–∏-–ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ</title>
  <script src="../section-auth.js"></script>
  <script>window.SectionAuth && window.SectionAuth.guardPage("LOVELACE", { requiredProfile: "CLASSIC" });</script>
  <style>
    @font-face {
      font-family: "Noto Color Emoji";
      font-style: normal;
      font-weight: 400;
      font-display: swap;
      src:
        url("https://cdn.jsdelivr.net/fontsource/fonts/noto-color-emoji@latest/emoji-400-normal.woff2") format("woff2"),
        url("https://cdn.jsdelivr.net/fontsource/fonts/noto-color-emoji@latest/emoji-400-normal.ttf") format("truetype");
    }

    :root {
      --bg: #f3f4f6;
      --panel: #ffffff;
      --text: #111827;
      --muted: #6b7280;
      --border: #d1d5db;
      --accent: #2563eb;
      --accent-strong: #1d4ed8;
      --danger-bg: #fee2e2;
      --danger-fg: #991b1b;
      --ok-bg: #dcfce7;
      --ok-fg: #166534;
      --warn-bg: #fef3c7;
      --warn-fg: #92400e;
      --emoji-font: "Noto Color Emoji", "Twemoji Mozilla", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Sans", "Segoe UI", sans-serif;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at 20% 0%, #ffffff, var(--bg));
      color: var(--text);
      font-family: "Segoe UI", "Noto Sans", sans-serif;
      padding: 8px;
    }

    .app {
      width: min(1800px, 100%);
      margin: 0 auto;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 18px;
      padding: 12px;
      box-shadow: 0 14px 30px rgba(17, 24, 39, 0.09);
      display: grid;
      gap: 12px;
    }

    .topbar {
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
    }

    .title {
      margin: 0;
      font-size: clamp(1.35rem, 2vw, 1.8rem);
      font-weight: 900;
      letter-spacing: -0.02em;
    }

    .back-link {
      text-decoration: none;
      border: 1px solid #93c5fd;
      border-radius: 10px;
      color: #1d4ed8;
      background: #dbeafe;
      padding: 8px 12px;
      font-weight: 700;
      transition: 120ms ease;
    }

    .back-link:hover {
      border-color: #60a5fa;
      background: #bfdbfe;
      transform: translateY(-1px);
    }

    .blocks {
      display: grid;
      gap: 12px;
      grid-template-columns: minmax(250px, 18%) minmax(520px, 1fr) minmax(320px, 28%);
      align-items: start;
    }

    .blocks-col {
      min-width: 0;
      display: grid;
      gap: 12px;
      align-content: start;
    }

    .panel {
      border: 1px solid var(--border);
      border-radius: 14px;
      background: #fcfcfd;
      padding: 12px;
      display: grid;
      gap: 10px;
    }

    .panel[hidden] {
      display: none !important;
    }

    h2 {
      margin: 0;
      font-size: 1rem;
      font-weight: 800;
    }

    .block-title {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .block-num {
      display: none;
      width: 24px;
      height: 24px;
      border-radius: 999px;
      display: inline-grid;
      place-items: center;
      font-size: 12px;
      font-weight: 900;
      background: #dbeafe;
      color: #1d4ed8;
      border: 1px solid #93c5fd;
      flex: 0 0 auto;
    }

    .switchers {
      display: grid;
      gap: 10px;
      grid-template-columns: 1fr 1fr;
    }

    .switchers-main {
      min-width: 0;
    }

    .switchers-row {
      grid-column: 1 / -1;
      min-width: 0;
      border-top: 1px solid #e5e7eb;
      padding-top: 10px;
    }

    .mini-title {
      font-size: 12px;
      font-weight: 800;
      letter-spacing: 0.02em;
      text-transform: uppercase;
      color: #475569;
      margin-bottom: 6px;
    }

    label {
      font-weight: 700;
      font-size: 14px;
    }

    textarea {
      width: 100%;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #fff;
      color: var(--text);
      padding: 10px 12px;
      outline: none;
      transition: 120ms ease;
      resize: vertical;
    }

    .text-input {
      width: 100%;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #fff;
      color: var(--text);
      padding: 10px 12px;
      outline: none;
      transition: 120ms ease;
      font: inherit;
    }

    .text-input:focus {
      border-color: #3b82f6;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
    }

    textarea:focus {
      border-color: #3b82f6;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
    }

    .emoji-field {
      font-family: var(--emoji-font);
      font-size: 18px;
      line-height: 1.45;
    }

    .code-editor {
      display: grid;
      grid-template-columns: auto 1fr;
      border: 1px solid var(--border);
      border-radius: 10px;
      overflow: hidden;
      background: #fff;
      min-height: clamp(360px, 58vh, 760px);
    }

    .code-editor:focus-within {
      border-color: #3b82f6;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
    }

    .editor-workspace {
      display: grid;
      grid-template-columns: minmax(220px, 30%) minmax(0, 1fr);
      gap: 12px;
      align-items: start;
    }

    .editor-pane,
    .keyboard-pane {
      min-width: 0;
      display: grid;
      gap: 8px;
      align-content: start;
    }

    .code-lines {
      width: 84px;
      min-width: 84px;
      min-height: clamp(360px, 58vh, 760px);
      border: none;
      border-right: 1px solid #e5e7eb;
      border-radius: 0;
      background: #f8fafc;
      color: #64748b;
      text-align: right;
      resize: none;
      overflow: hidden;
      padding: 10px 8px;
      letter-spacing: 0;
      word-spacing: 0;
      font-variant-ligatures: none;
      user-select: none;
      pointer-events: none;
    }

    .code-lines:focus {
      box-shadow: none;
      border-color: #e5e7eb;
    }

    .code-input {
      min-height: clamp(360px, 58vh, 760px);
      border: none;
      border-radius: 0;
      background: transparent;
    }

    .code-input:focus {
      border-color: transparent;
      box-shadow: none;
    }

    .stdin-input {
      min-height: 60px;
      font-family: "Noto Sans", "Segoe UI", "Noto Color Emoji", "Twemoji Mozilla", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", sans-serif;
      font-size: 18px;
      line-height: 1.35;
      letter-spacing: 0;
      word-spacing: 0;
      font-variant-ligatures: none;
    }

    .output-box {
      min-height: 60px;
      font-family: "Noto Sans", "Segoe UI", "Noto Color Emoji", "Twemoji Mozilla", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", sans-serif;
      font-size: 18px;
      line-height: 1.35;
      letter-spacing: 0;
      word-spacing: 0;
      font-variant-ligatures: none;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .run-panel-top {
      display: grid;
      grid-template-columns: auto minmax(0, 1fr);
      gap: 8px;
      align-items: center;
    }

    .run-controls {
      gap: 6px;
    }

    .run-controls > button {
      padding: 6px 10px;
      min-height: 34px;
      font-size: 13px;
      border-radius: 8px;
      line-height: 1.15;
    }

    .examples {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .task-grid,
    .subtask-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .subtask-grid {
      margin-top: 8px;
      min-height: 40px;
    }

    .subtask-grid[hidden] {
      display: none !important;
    }

    .task-text-wrap[hidden] {
      display: none !important;
    }

    .task-text-wrap {
      margin-top: 8px;
      display: grid;
      gap: 6px;
    }

    .task-text-label {
      font-size: 14px;
      font-weight: 700;
    }

    .task-text {
      min-height: 72px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #fff;
      padding: 10px 12px;
      font-size: 16px;
      line-height: 1.35;
      letter-spacing: 0;
      word-spacing: 0;
      font-variant-ligatures: none;
    }

    .task-text p {
      margin: 0;
    }

    .task-text p + p {
      margin-top: 6px;
    }

    .tests-toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .test-list {
      display: grid;
      gap: 10px;
      grid-template-columns: repeat(auto-fit, minmax(170px, 1fr));
    }

    .test-item {
      border: 1px solid #dbeafe;
      background: #f8fafc;
      border-radius: 10px;
      padding: 8px;
      display: grid;
      gap: 6px;
      min-height: 150px;
      align-content: start;
    }

    .test-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }

    .test-label {
      font-size: 13px;
      font-weight: 800;
      color: #334155;
    }

    .icon-btn {
      min-width: 34px;
      min-height: 34px;
      padding: 4px 6px;
      display: inline-grid;
      place-items: center;
      font-size: 16px;
      line-height: 1;
      border-radius: 8px;
    }

    .test-output-grid {
      display: grid;
      gap: 10px;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
    }

    .test-output-card {
      border: 1px solid #e5e7eb;
      border-radius: 10px;
      background: #ffffff;
      padding: 10px;
      display: grid;
      gap: 8px;
    }

    .test-output-card.ok {
      border-color: #86efac;
      background: #f0fdf4;
    }

    .test-output-card.error {
      border-color: #fca5a5;
      background: #fef2f2;
    }

    .test-output-card.warn {
      border-color: #fcd34d;
      background: #fffbeb;
    }

    .test-output-meta {
      font-size: 12px;
      font-weight: 700;
      color: #475569;
    }

    button {
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #fff;
      color: var(--text);
      font: inherit;
      font-weight: 700;
      padding: 9px 12px;
      cursor: pointer;
      transition: 120ms ease;
    }

    button:hover {
      border-color: #9ca3af;
      transform: translateY(-1px);
    }

    button:disabled {
      opacity: 0.65;
      cursor: not-allowed;
      transform: none;
    }

    .switchers button[aria-pressed="true"] {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2);
    }

    .switchers button[aria-pressed="true"]:hover {
      background: var(--accent-strong);
      border-color: var(--accent-strong);
    }

    button.primary {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
    }

    button.primary:hover {
      background: var(--accent-strong);
      border-color: var(--accent-strong);
    }

    .status-box {
      border-radius: 10px;
      border: 1px solid var(--border);
      padding: 10px 12px;
      font-weight: 700;
      background: #f3f4f6;
      color: #1f2937;
      min-height: 44px;
      display: flex;
      align-items: center;
    }

    .status-box.ok {
      background: var(--ok-bg);
      color: var(--ok-fg);
      border-color: #86efac;
    }

    .status-box.error {
      background: var(--danger-bg);
      color: var(--danger-fg);
      border-color: #fca5a5;
    }

    .status-box.warn {
      background: var(--warn-bg);
      color: var(--warn-fg);
      border-color: #fcd34d;
    }

    .run-panel-top .status-box {
      min-height: 34px;
      padding: 6px 10px;
      font-size: 13px;
      line-height: 1.15;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .step-count {
      font-weight: 700;
      color: #1f2937;
      font-size: 14px;
    }

    .keyboard {
      display: grid;
      gap: 10px;
    }

    .keyboard-layout {
      display: grid;
      grid-template-columns: minmax(0, 1fr) 220px;
      gap: 10px;
      align-items: start;
    }

    .keyboard-left {
      display: grid;
      gap: 10px;
      min-width: 0;
    }

    .emoji-group {
      border: 1px solid #e5e7eb;
      border-radius: 10px;
      background: #fff;
      padding: 10px;
    }

    .emoji-group.group-1 { background: linear-gradient(180deg, #ffffff, #f8fafc); }
    .emoji-group.group-2 { background: linear-gradient(180deg, #ffffff, #f9fafb); }
    .emoji-group.group-3 { background: linear-gradient(180deg, #ffffff, #eff6ff); }

    .emoji-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(40px, 1fr));
      gap: 6px;
    }

    .emoji-btn {
      font-family: var(--emoji-font);
      font-size: 22px;
      line-height: 1;
      padding: 8px 6px;
      min-height: 40px;
      display: grid;
      place-items: center;
    }

    .editor-nav {
      border: 1px solid #d1d5db;
      border-radius: 10px;
      background: linear-gradient(180deg, #ffffff, #f8fafc);
      padding: 10px;
      display: grid;
      gap: 8px;
    }

    .nav-title {
      margin: 0;
      font-size: 12px;
      font-weight: 800;
      text-transform: uppercase;
      letter-spacing: 0.02em;
      color: #475569;
    }

    .nav-arrows {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      grid-template-areas:
        ". up ."
        "left down right";
      gap: 6px;
    }

    .nav-actions {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 6px;
    }

    .nav-btn {
      min-height: 42px;
      padding: 7px 8px;
      display: grid;
      place-items: center;
      font-weight: 800;
      border-radius: 10px;
      user-select: none;
    }

    .nav-btn.up { grid-area: up; }
    .nav-btn.left { grid-area: left; }
    .nav-btn.down { grid-area: down; }
    .nav-btn.right { grid-area: right; }
    .nav-btn.enter { grid-column: 1 / -1; }

    .vars-panel[hidden] {
      display: none !important;
    }

    @media (max-width: 1040px) {
      .switchers {
        grid-template-columns: 1fr;
      }

      .keyboard-layout {
        grid-template-columns: 1fr;
      }

      .editor-workspace {
        grid-template-columns: 1fr;
      }

      .blocks {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <main class="app">
    <header class="topbar">
      <h1 class="title">–≠–º–æ–¥–∑–∏-–ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ</h1>
      <a href="../index.html" class="back-link">–ù–∞ –≥–ª–∞–≤–Ω—É—é</a>
    </header>

    <section class="blocks">
      <aside class="blocks-col">
      <section class="panel">
        <h2 class="block-title"><span class="block-num">0</span>–ü—Ä–∏–º–µ—Ä—ã –∏ –ó–∞–¥–∞–Ω–∏—è</h2>
        <div class="switchers">
          <section class="switchers-main">
            <div class="mini-title">–ü—Ä–∏–º–µ—Ä—ã</div>
            <div class="examples">
              <button id="example1Btn" type="button" aria-pressed="false">–ü—Ä–∏–º–µ—Ä ‚Ññ1</button>
              <button id="example2Btn" type="button" aria-pressed="false">–ü—Ä–∏–º–µ—Ä ‚Ññ2</button>
              <button id="example3Btn" type="button" aria-pressed="false">–ü—Ä–∏–º–µ—Ä ‚Ññ3</button>
              <button id="example4Btn" type="button" aria-pressed="false">–ü—Ä–∏–º–µ—Ä ‚Ññ4</button>
              <button id="example5Btn" type="button" aria-pressed="false">–ü—Ä–∏–º–µ—Ä ‚Ññ5</button>
            </div>
          </section>
          <section class="switchers-main">
            <div class="mini-title">–ó–∞–¥–∞–Ω–∏—è</div>
            <div id="taskButtons" class="task-grid">
              <button type="button" data-task="1" aria-pressed="false">–ó–∞–¥–∞–Ω–∏–µ 1</button>
              <button type="button" data-task="2" aria-pressed="false">–ó–∞–¥–∞–Ω–∏–µ 2</button>
              <button type="button" data-task="3" aria-pressed="false">–ó–∞–¥–∞–Ω–∏–µ 3</button>
              <button type="button" data-task="4" aria-pressed="false">–ó–∞–¥–∞–Ω–∏–µ 4</button>
            </div>
          </section>
          <section class="switchers-row">
            <div class="mini-title">–ü–æ–¥–∑–∞–¥–∞—á–∏</div>
            <div id="taskSubtasks" class="subtask-grid" hidden></div>
          </section>
          <section id="taskTextWrap" class="task-text-wrap switchers-row" hidden>
            <div class="task-text-label">–¢–µ–∫—Å—Ç –∑–∞–¥–∞–Ω–∏—è</div>
            <div id="taskText" class="task-text"></div>
          </section>
        </div>
      </section>
      </aside>

      <section class="blocks-col">
      <section class="panel">
        <h2 class="block-title"><span class="block-num">1</span>–†–µ–¥–∞–∫—Ç–æ—Ä –∫–æ–¥–∞</h2>
        <div class="editor-workspace">
          <div class="editor-pane">
            <label for="codeInput">–ö–æ–¥</label>
            <div class="code-editor">
              <textarea id="codeLineNumbers" class="emoji-field code-lines" readonly tabindex="-1" aria-hidden="true">üìå</textarea>
              <textarea id="codeInput" class="emoji-field code-input" spellcheck="false" autocomplete="off" autocapitalize="off"></textarea>
            </div>
          </div>
          <div class="keyboard-pane">
            <div class="mini-title">–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞</div>
            <div id="emojiKeyboard" class="keyboard"></div>
          </div>
        </div>
      </section>
      </section>

      <section class="blocks-col">
      <section class="panel">
        <h2 class="block-title"><span class="block-num">3</span>–ó–∞–ø—É—Å–∫</h2>
        <div class="run-panel-top">
          <div class="controls run-controls">
            <button id="runBtn" class="primary">–ó–∞–ø—É—Å—Ç–∏—Ç—å</button>
            <button id="resetBtn">–°–±—Ä–æ—Å</button>
          </div>
          <div id="statusBox" class="status-box">–û–∂–∏–¥–∞–Ω–∏–µ –∑–∞–ø—É—Å–∫–∞.</div>
        </div>
        <div id="stepCount" class="step-count">–°—É–º–º–∞—Ä–Ω—ã–µ —à–∞–≥–∏: 0</div>
      </section>

      <section id="codePhrasePanel" class="panel" hidden>
        <h2 class="block-title"><span class="block-num">5</span>–ö–æ–¥–æ–≤–∞—è —Ñ—Ä–∞–∑–∞</h2>
        <label for="codePhraseInput">–ö–æ–¥–æ–≤–∞—è —Ñ—Ä–∞–∑–∞</label>
        <input id="codePhraseInput" class="text-input" type="text" autocomplete="off" autocapitalize="off" spellcheck="false" placeholder="–ö–æ–¥–æ–≤–∞—è —Ñ—Ä–∞–∑–∞" readonly>
        <div class="controls">
          <button id="copyCodePhraseBtn" type="button">–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
        </div>
      </section>

      <section class="panel">
        <h2 class="block-title"><span class="block-num">4</span>–í—ã—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ø–æ —Ç–µ—Å—Ç–∞–º</h2>
        <div id="testOutputs" class="test-output-grid"></div>
      </section>

      <section class="panel">
        <h2 class="block-title"><span class="block-num">2</span>–¢–µ—Å—Ç—ã</h2>
        <div class="tests-toolbar">
          <button id="addTestBtn" type="button">–î–æ–±–∞–≤–∏—Ç—å —Ç–µ—Å—Ç</button>
          <button id="resetTestsBtn" type="button">–°–±—Ä–æ—Å–∏—Ç—å —Ç–µ—Å—Ç—ã</button>
        </div>
        <div id="testList" class="test-list"></div>
      </section>
      </section>
    </section>

    <section class="vars-panel" hidden>
      <h2>–°–æ—Å—Ç–æ—è–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö</h2>
      <div id="varsGrid"></div>
    </section>
  </main>

  <script>
    const COMMAND_EMOJIS = ["üåû", "‚≠ê", "üé≤", "üòÄ", "‚ûï", "‚ûñ", "‚úñ", "‚ûó", "‚û∞", "ü§î", "üîÇ", "üîÅ", "üòê"];
    const VARIABLE_EMOJIS = [
      "üê∂", "üê±", "üê≠", "üêπ", "üê∞", "ü¶ä", "üêª", "üêº", "üê®", "üêØ", "ü¶Å", "üêÆ",
      "üïê", "üïë", "üïí", "üïì", "üïî", "üïï", "üïñ", "üïó", "üïò", "üïô", "üïö", "üïõ",
      "üö®"
    ];
    const DIGIT_EMOJIS = ["üÜö", "üìå", "‚úå", "ü§ü", "ü§û", "üñê", "ü§ò", "üëå", "üëç", "üëä"];
    const DIGIT_TO_VALUE = new Map(DIGIT_EMOJIS.map((emoji, idx) => [emoji, String(idx)]));

    const KEYBOARD_GROUPS = [COMMAND_EMOJIS, VARIABLE_EMOJIS, DIGIT_EMOJIS];

    const EXAMPLES = [
      {
        code: [
          "‚≠êüê∂",
          "üòÄüê∂"
        ].join("\n"),
        tests: ["7", "42", "105"]
      },
      {
        code: [
          "‚≠êüê∂",
          "üåûüê±‚úå",
          "‚úñüê∂üê±",
          "üåûüê≠üìå",
          "‚ûñüê∂üê≠",
          "üòÄüê∂"
        ].join("\n"),
        tests: ["10", "1", "55"]
      },
      {
        code: [
          "‚≠êüê∂",
          "üåûüê±üìå",
          "ü§îüê∂üê±",
          "üåûüê≠üëä",
          "üòÄüê≠",
          "üòê"
        ].join("\n"),
        tests: ["1", "2", "0", "10", "37"]
      },
      {
        code: [
          "‚≠êüê∂",
          "üåûüê±üÜö",
          "üåûüê≠üìå",
          "üîÇüê∂",
          "‚ûïüê±üê∂",
          "‚ûñüê∂üê≠",
          "üòê",
          "üòÄüê±"
        ].join("\n"),
        tests: ["1", "2", "4", "6", "8"]
      },
      {
        code: [
          "‚≠êüê∂",
          "üåûüê±üÜö",
          "üåûüê≠üÜö",
          "üåûüêπüìå",
          "üîÅüê≠üê∂",
          "‚ûïüê≠üêπ",
          "‚ûïüê±üê≠",
          "üòê",
          "üòÄüê±"
        ].join("\n"),
        tests: ["0", "1", "3", "4", "7"]
      }
    ];

    const HARD_STEP_LIMIT = 200000;
    const YIELD_EVERY = 1500;
    const TASK4_SUBTASK_KEY = "4.1";
    const TASK4_DATA_BLOB = Object.freeze({
      seed: 3067421989,
      blob: "XmL8E1oRMORXs1x4mPI7W8GylWCI9HOk3QsXG6HYe85nzJ13MWQGBfntI9grHlrs+RK5i6oNEVp4+m2+0/ke40n7/dsHxPZyjxJFohHtq1/V4s+w2Tez5h9UVQ+5XP5d8UWbcLN2k4Th6vFTIhXJYnBSNVZr0dYLcWO1Y4+8zqqH+j3AmdT0ZthIn/pBPueMUGhfp1owtnJfgpWbI0D5CKwTVvCl8cHceXqyH+yQkGw83j8XLcbJlK9s934BONsqxTR/BskAI7YPhMV/ySxujQE1CyBDpiJ0kdqBgzLFedJggkW0aLhQQzBkfJi4klv74dK1gKsXE8L9rDe+QXgbagV0v0ILWGGjFZhCOYX5LwyPsp9gleYl/45RVUbkzmGYJIzMdzQ4GETk5jePZR5R7OUQ/8D1RhZObb00vsToWaRHsf2eS8LqdcRKC/8T5u0PmaOK/9V/sb9TCAIe4xa5D7wAxnK4dJaG+Oi3GH1eznZlFWxWfMCRTH8otSbDutKtzKJzl4vOpSeBG8KnXWfpx1tgWrYbfvElTZiEijdM6V70QAay/bTWxj0q61j0xJsrNsQqBnve0Ye/dPU8SH+SfIllfQiPVW/1SNXLYZM1ZZ4AJE04W7Unb53Jx8pznDuNNYBL4inhEwZ9aiuYtIRb6/aE6sa7HhHG/7Q1/Ag/UjxJJb1ITxUvtQiVCyHT9SVewOSNeJv1Y6bdAQ4KsMxr3GnC2mo5cQAS6OxlwDMNSeL3RqaRsAYfUz/iMavN/x7jOKz9wgHG4nXICl24YqnGQyV9PgAptENtDajKumX8IF9Vk8Vo2GPOlIPw9Q58rDDeq6C88qHPY8aNh6fbY/xrZOTtW5fFgKIe1FGW+SN0pJsXbQ=="
    });
    const CODE_PHRASE_UNLOCK_RULES = Object.freeze({
      "2.1": Object.freeze({
        tests: Object.freeze(["1", "14", "27"]),
        outputs: Object.freeze(["5", "18", "31"]),
        seed: 1374772855,
        blob: Object.freeze([45291, 28554, 60224, 46832, 56516, 56824, 52380, 31333, 31764, 33038, 59126, 9155, 18990, 1010])
      }),
      "2.2": Object.freeze({
        tests: Object.freeze(["4", "8", "16"]),
        outputs: Object.freeze(["2", "4", "8"]),
        seed: 2049653837,
        blob: Object.freeze([31843, 22378, 44959, 52419, 13656, 46847, 46763, 16078, 32805, 3142, 23581, 58072])
      }),
      "3.1": Object.freeze({
        tests: Object.freeze(["2", "5", "9"]),
        outputs: Object.freeze(["4", "10", "18"]),
        seed: 1619232841,
        blob: Object.freeze([55474, 44840, 46821, 31926, 30933, 65432, 12680, 49254, 48332, 51199, 32487, 5544, 6806])
      }),
      "3.2": Object.freeze({
        tests: Object.freeze(["3", "6", "8"]),
        outputs: Object.freeze(["6", "12", "16"]),
        seed: 998274563,
        blob: Object.freeze([37264, 4005, 1987, 52465, 36364, 3812, 59268, 23946, 37264, 4664, 40513, 44019])
      })
    });
    const TASK4_DATA = (() => {
      const empty = Object.freeze({ cases: Object.freeze([]), phrase: "" });
      const entry = TASK4_DATA_BLOB;
      if (!entry || typeof entry !== "object") return empty;
      const blob = String(entry.blob || "");
      const seed = Number(entry.seed) >>> 0;
      if (!blob) return empty;

      let encoded = "";
      try {
        encoded = atob(blob);
      } catch (_) {
        return empty;
      }

      const bytes = new Uint8Array(encoded.length);
      let state = seed;
      for (let i = 0; i < encoded.length; i++) {
        bytes[i] = (encoded.charCodeAt(i) & 0xff) ^ (state & 0xff);
        state = (state * 1664525 + 1013904223) >>> 0;
      }

      let text = "";
      try {
        text = new TextDecoder("utf-8").decode(bytes);
      } catch (_) {
        for (let i = 0; i < bytes.length; i++) text += String.fromCharCode(bytes[i]);
      }

      try {
        const raw = JSON.parse(text);
        const rawCases = Array.isArray(raw && raw.cases) ? raw.cases : [];
        const cases = [];
        for (let i = 0; i < rawCases.length; i++) {
          const item = rawCases[i];
          const input = String(item && item.input || "").trim();
          const expected = String(item && item.expected || "").trim();
          if (!input || (expected !== "0" && expected !== "1")) continue;
          cases.push(Object.freeze({
            input,
            expected,
            visible: Boolean(item && item.visible)
          }));
        }
        const phrase = String(raw && raw.phrase || "");
        return Object.freeze({
          cases: Object.freeze(cases),
          phrase
        });
      } catch (_) {
        return empty;
      }
    })();
    const TASK_SUBTASK_COUNTS = Object.freeze({
      "2": 2,
      "3": 2,
      "4": 1
    });
    const SUBTASK_PRESETS = Object.freeze({
      "1.1": {
        code: [
          "‚≠êüê∂",
          "üòÄüê∂"
        ].join("\n"),
        tests: ["7", "42", "105"]
      },
      "1.2": {
        code: [
          "‚≠êüê∂",
          "üåûüê±üìå",
          "‚ûïüê∂üê±",
          "üòÄüê∂"
        ].join("\n"),
        tests: ["0", "5", "99"]
      },
      "1.3": {
        code: [
          "‚≠êüê∂",
          "üåûüê±üìå",
          "üåûüê≠üÜö",
          "ü§îüê∂üê±",
          "üåûüê≠üëä",
          "üòê",
          "üòÄüê≠"
        ].join("\n"),
        tests: ["1", "2", "0"]
      },
      "1.4": {
        code: [
          "‚≠êüê∂",
          "üåûüê±üÜö",
          "üåûüê≠üìå",
          "üîÇüê∂",
          "‚ûïüê±üê∂",
          "‚ûñüê∂üê≠",
          "üòê",
          "üòÄüê±"
        ].join("\n"),
        tests: ["1", "3", "5"]
      },
      "2.1": {
        code: "",
        tests: ["1", "14", "27"]
      },
      "2.2": {
        code: "",
        tests: ["4", "8", "16"]
      },
      "3.1": {
        code: [
          "‚≠êüê∂",
          "üåûüê±üÜö",
          "üåûüê≠üÜö",
          "‚ûïüê≠üê∂",
          "‚ûïüê≠üê∂",
          "üåûüêπüìå",
          "üîÇüê∂",
          "‚ûïüê±üêπ",
          "üòê",
          "üòÄüê±"
        ].join("\n"),
        tests: ["2", "5", "9"]
      },
      "3.2": {
        code: [
          "‚≠êüê∂",
          "üåûüê±üÜö",
          "üåûüê≠üÜö",
          "üåûüêπüìå",
          "üåûüêÆüÜö",
          "‚ûïüêÆüê∂",
          "‚ûïüêÆüê∂",
          "üîÅüê≠üê∂",
          "‚ûïüê±üêπ",
          "‚ûïüê≠üêπ",
          "üòê",
          "üòÄüê±"
        ].join("\n"),
        tests: ["3", "6", "8"]
      },
      "4.1": {
        code: "",
        tests: []
      }
    });
    const SUBTASK_TEXTS = Object.freeze({
      "1.1": Object.freeze([
        "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –≤—ã—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –∑–Ω–∞—á–µ–Ω–∏—è 11."
      ]),
      "1.2": Object.freeze([
        "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –≤—ã—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –∑–Ω–∞—á–µ–Ω–∏—è 25."
      ]),
      "1.3": Object.freeze([
        "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –≤—ã—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –∑–Ω–∞—á–µ–Ω–∏—è 6."
      ]),
      "1.4": Object.freeze([
        "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –≤—ã—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –∑–Ω–∞—á–µ–Ω–∏—è 14."
      ]),
      "2.1": Object.freeze([
        "–î–ª—è –∑–Ω–∞—á–µ–Ω–∏—è 1 –Ω—É–∂–Ω–æ –ø–æ–ª—É—á–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ 5.",
        "–î–ª—è –∑–Ω–∞—á–µ–Ω–∏—è 14 –Ω—É–∂–Ω–æ –ø–æ–ª—É—á–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ 18.",
        "–î–ª—è –∑–Ω–∞—á–µ–Ω–∏—è 27 –Ω—É–∂–Ω–æ –ø–æ–ª—É—á–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ 31."
      ]),
      "2.2": Object.freeze([
        "–î–ª—è –∑–Ω–∞—á–µ–Ω–∏—è 4 –Ω—É–∂–Ω–æ –ø–æ–ª—É—á–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ 2.",
        "–î–ª—è –∑–Ω–∞—á–µ–Ω–∏—è 8 –Ω—É–∂–Ω–æ –ø–æ–ª—É—á–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ 4.",
        "–î–ª—è –∑–Ω–∞—á–µ–Ω–∏—è 16 –Ω—É–∂–Ω–æ –ø–æ–ª—É—á–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ 8."
      ]),
      "3.1": Object.freeze([
        "–î–ª—è –∑–Ω–∞—á–µ–Ω–∏—è 2 –Ω—É–∂–Ω–æ –ø–æ–ª—É—á–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ 4.",
        "–î–ª—è –∑–Ω–∞—á–µ–Ω–∏—è 5 –Ω—É–∂–Ω–æ –ø–æ–ª—É—á–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ 10.",
        "–î–ª—è –∑–Ω–∞—á–µ–Ω–∏—è 9 –Ω—É–∂–Ω–æ –ø–æ–ª—É—á–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ 18."
      ]),
      "3.2": Object.freeze([
        "–î–ª—è –∑–Ω–∞—á–µ–Ω–∏—è 3 –Ω—É–∂–Ω–æ –ø–æ–ª—É—á–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ 6.",
        "–î–ª—è –∑–Ω–∞—á–µ–Ω–∏—è 6 –Ω—É–∂–Ω–æ –ø–æ–ª—É—á–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ 12.",
        "–î–ª—è –∑–Ω–∞—á–µ–Ω–∏—è 8 –Ω—É–∂–Ω–æ –ø–æ–ª—É—á–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ 16."
      ]),
      "4.1": Object.freeze([
        "–í–≤–æ–¥–∏—Ç—Å—è —ç—Ç–∞–ª–æ–Ω E, –∑–∞—Ç–µ–º –≤–≤–æ–¥—è—Ç—Å—è —á–∏—Å–ª–∞, –ø–æ–∫–∞ –Ω–µ –±—É–¥–µ—Ç –≤–≤–µ–¥—ë–Ω –Ω–æ–ª—å.",
        "–ù—É–∂–Ω–æ –ø–æ—Å—á–∏—Ç–∞—Ç—å —Å—É–º–º—É –≤–≤–µ–¥—ë–Ω–Ω—ã—Ö –ø–æ—Å–ª–µ —ç—Ç–∞–ª–æ–Ω–∞ —á–∏—Å–µ–ª –∏ —Å—Ä–∞–≤–Ω–∏—Ç—å —Å —ç—Ç–∞–ª–æ–Ω–æ–º.",
        "–ï—Å–ª–∏ —Å—É–º–º–∞ —Ä–∞–≤–Ω–∞ —ç—Ç–∞–ª–æ–Ω—É - –≤—ã–≤–µ—Å—Ç–∏ 1. –ò–Ω–∞—á–µ - –≤—ã–≤–µ—Å—Ç–∏ 0."
      ])
    });

    const codeInputEl = document.getElementById("codeInput");
    const codeLineNumbersEl = document.getElementById("codeLineNumbers");
    const runBtn = document.getElementById("runBtn");
    const resetBtn = document.getElementById("resetBtn");
    const addTestBtn = document.getElementById("addTestBtn");
    const resetTestsBtn = document.getElementById("resetTestsBtn");
    const testListEl = document.getElementById("testList");
    const testOutputsEl = document.getElementById("testOutputs");
    const example1Btn = document.getElementById("example1Btn");
    const example2Btn = document.getElementById("example2Btn");
    const example3Btn = document.getElementById("example3Btn");
    const example4Btn = document.getElementById("example4Btn");
    const example5Btn = document.getElementById("example5Btn");
    const taskButtonsEl = document.getElementById("taskButtons");
    const taskSubtasksEl = document.getElementById("taskSubtasks");
    const taskTextWrapEl = document.getElementById("taskTextWrap");
    const taskTextEl = document.getElementById("taskText");
    const statusBoxEl = document.getElementById("statusBox");
    const stepCountEl = document.getElementById("stepCount");
    const emojiKeyboardEl = document.getElementById("emojiKeyboard");
    const codePhrasePanelEl = document.getElementById("codePhrasePanel");
    const codePhraseInputEl = document.getElementById("codePhraseInput");
    const copyCodePhraseBtn = document.getElementById("copyCodePhraseBtn");

    const VARIABLE_SET = new Set(VARIABLE_EMOJIS);
    const exampleButtons = [example1Btn, example2Btn, example3Btn, example4Btn, example5Btn];
    const taskButtons = Array.from(taskButtonsEl.querySelectorAll("[data-task]"));
    const GRAPHEME_SEGMENTER = (typeof Intl !== "undefined" && typeof Intl.Segmenter === "function")
      ? new Intl.Segmenter("ru", { granularity: "grapheme" })
      : null;
    let lastFocusedField = codeInputEl;
    let currentScenarioKey = "";
    let selectedExampleIndex = -1;
    let selectedTaskKey = "";
    let selectedSubtaskKey = "";
    let codeInputResizeObserver = null;

    function isTask4Subtask(subtaskKey = selectedSubtaskKey) {
      return String(subtaskKey || "") === TASK4_SUBTASK_KEY;
    }

    function getTask4Cases() {
      const cases = TASK4_DATA && Array.isArray(TASK4_DATA.cases) ? TASK4_DATA.cases : [];
      return cases;
    }

    function getTask4VisibleCases() {
      return getTask4Cases().filter((item) => item && item.visible);
    }

    function getTask4VisibleInputs() {
      return getTask4VisibleCases().map((item) => String(item.input || ""));
    }

    function getTask4Phrase() {
      return TASK4_DATA && typeof TASK4_DATA.phrase === "string" ? TASK4_DATA.phrase : "";
    }

    function syncTask4TestsUi() {
      const lockTests = isTask4Subtask();
      if (addTestBtn) addTestBtn.hidden = lockTests;
      if (resetTestsBtn) resetTestsBtn.hidden = lockTests;
    }

    function makeError(kind, line, message) {
      const err = new Error(message);
      err.kind = kind;
      err.line = line;
      return err;
    }

    function normalizeCodeLine(line) {
      return String(line || "").replace(/\uFE0F/g, "").replace(/\s+/g, "");
    }

    function requireVariable(symbol, line) {
      if (!VARIABLE_SET.has(symbol)) {
        throw makeError("parse", line, `–û–∂–∏–¥–∞–ª–∞—Å—å –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è, –ø–æ–ª—É—á–µ–Ω–æ: ${symbol || "–ø—É—Å—Ç–æ"}.`);
      }
      return symbol;
    }

    function parseEmojiNumber(emojis, line) {
      if (!emojis.length) {
        throw makeError("parse", line, "–ö–æ–º–∞–Ω–¥–∞ üåû —Ç—Ä–µ–±—É–µ—Ç —Ö–æ—Ç—è –±—ã –æ–¥–Ω—É emoji-—Ü–∏—Ñ—Ä—É.");
      }
      let valueText = "";
      for (let i = 0; i < emojis.length; i++) {
        const value = DIGIT_TO_VALUE.get(emojis[i]);
        if (typeof value !== "string") {
          throw makeError("parse", line, `–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è emoji-—Ü–∏—Ñ—Ä–∞: ${emojis[i]}.`);
        }
        valueText += value;
      }
      const numeric = Number(valueText);
      if (!Number.isFinite(numeric)) {
        throw makeError("parse", line, `–ß–∏—Å–ª–æ –Ω–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å: ${valueText}.`);
      }
      return Math.trunc(numeric);
    }

    function toEmojiNumberText(value) {
      const safe = Math.max(0, Math.trunc(value));
      const text = String(safe);
      let out = "";
      for (let i = 0; i < text.length; i++) {
        const code = text.charCodeAt(i) - 48;
        if (code >= 0 && code <= 9) out += DIGIT_EMOJIS[code];
      }
      return out || DIGIT_EMOJIS[0];
    }

    function editorLineCount() {
      const source = String(codeInputEl.value || "").replace(/\r\n?/g, "\n");
      return source.split("\n").length;
    }

    function syncCodeLineNumbersScroll() {
      if (!codeLineNumbersEl) return;
      codeLineNumbersEl.scrollTop = codeInputEl.scrollTop;
    }

    function syncCodeLineNumbersHeight() {
      if (!codeLineNumbersEl) return;
      const nextHeight = codeInputEl.offsetHeight;
      if (nextHeight > 0) codeLineNumbersEl.style.height = `${nextHeight}px`;
    }

    function refreshCodeLineNumbers() {
      if (!codeLineNumbersEl) return;
      const lines = [];
      const total = editorLineCount();
      for (let i = 1; i <= total; i++) lines.push(toEmojiNumberText(i));
      const content = lines.join("\n");
      if (codeLineNumbersEl.value !== content) codeLineNumbersEl.value = content;
      syncCodeLineNumbersHeight();
      syncCodeLineNumbersScroll();
    }

    function parseProgram(source) {
      const lines = String(source || "").replace(/\r\n?/g, "\n").split("\n");
      const instructions = [];
      const blockStack = [];

      for (let idx = 0; idx < lines.length; idx++) {
        const lineNo = idx + 1;
        const compactLine = normalizeCodeLine(lines[idx]);
        if (!compactLine) continue;

        const tokens = Array.from(compactLine);
        const op = tokens[0];

        if (op === "üåû") {
          if (tokens.length < 3) {
            throw makeError("parse", lineNo, "–ö–æ–º–∞–Ω–¥–∞ üåû —Ç—Ä–µ–±—É–µ—Ç —Ñ–æ—Ä–º–∞—Ç: üåû<–ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è><emoji-—á–∏—Å–ª–æ>.");
          }
          const target = requireVariable(tokens[1], lineNo);
          const value = parseEmojiNumber(tokens.slice(2), lineNo);
          instructions.push({ type: "set", target, value, line: lineNo });
          continue;
        }

        if (op === "‚≠ê") {
          if (tokens.length !== 2) throw makeError("parse", lineNo, "–ö–æ–º–∞–Ω–¥–∞ ‚≠ê —Ç—Ä–µ–±—É–µ—Ç —Ñ–æ—Ä–º–∞—Ç: ‚≠ê<–ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è>.");
          instructions.push({ type: "readNumber", target: requireVariable(tokens[1], lineNo), line: lineNo });
          continue;
        }

        if (op === "üé≤") {
          if (tokens.length !== 4) throw makeError("parse", lineNo, "–ö–æ–º–∞–Ω–¥–∞ üé≤ —Ç—Ä–µ–±—É–µ—Ç —Ñ–æ—Ä–º–∞—Ç: üé≤<–ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è><lowVar><highVar>.");
          instructions.push({
            type: "random",
            target: requireVariable(tokens[1], lineNo),
            low: requireVariable(tokens[2], lineNo),
            high: requireVariable(tokens[3], lineNo),
            line: lineNo
          });
          continue;
        }

        if (op === "üòÄ") {
          if (tokens.length !== 2) throw makeError("parse", lineNo, "–ö–æ–º–∞–Ω–¥–∞ üòÄ —Ç—Ä–µ–±—É–µ—Ç —Ñ–æ—Ä–º–∞—Ç: üòÄ<–ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è>.");
          instructions.push({ type: "printNumber", target: requireVariable(tokens[1], lineNo), line: lineNo });
          continue;
        }

        if (op === "‚ûï" || op === "‚ûñ" || op === "‚úñ" || op === "‚ûó" || op === "‚û∞") {
          if (tokens.length !== 3) {
            throw makeError("parse", lineNo, `–ö–æ–º–∞–Ω–¥–∞ ${op} —Ç—Ä–µ–±—É–µ—Ç —Ñ–æ—Ä–º–∞—Ç: ${op}<–ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è><–ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è>.`);
          }
          instructions.push({
            type: "math",
            op,
            left: requireVariable(tokens[1], lineNo),
            right: requireVariable(tokens[2], lineNo),
            line: lineNo
          });
          continue;
        }

        if (op === "ü§î") {
          if (tokens.length !== 3) throw makeError("parse", lineNo, "–ö–æ–º–∞–Ω–¥–∞ ü§î —Ç—Ä–µ–±—É–µ—Ç —Ñ–æ—Ä–º–∞—Ç: ü§î<–ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è><–ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è>.");
          instructions.push({
            type: "ifEq",
            left: requireVariable(tokens[1], lineNo),
            right: requireVariable(tokens[2], lineNo),
            jumpTo: -1,
            line: lineNo
          });
          blockStack.push({ type: "if", index: instructions.length - 1 });
          continue;
        }

        if (op === "üîÇ") {
          if (tokens.length !== 2) throw makeError("parse", lineNo, "–ö–æ–º–∞–Ω–¥–∞ üîÇ —Ç—Ä–µ–±—É–µ—Ç —Ñ–æ—Ä–º–∞—Ç: üîÇ<–ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è>.");
          instructions.push({
            type: "loopCount",
            count: requireVariable(tokens[1], lineNo),
            jumpTo: -1,
            line: lineNo
          });
          blockStack.push({ type: "loopCount", index: instructions.length - 1 });
          continue;
        }

        if (op === "üîÅ") {
          if (tokens.length !== 3) throw makeError("parse", lineNo, "–ö–æ–º–∞–Ω–¥–∞ üîÅ —Ç—Ä–µ–±—É–µ—Ç —Ñ–æ—Ä–º–∞—Ç: üîÅ<–ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è><–ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è>.");
          instructions.push({
            type: "loopNeq",
            left: requireVariable(tokens[1], lineNo),
            right: requireVariable(tokens[2], lineNo),
            jumpTo: -1,
            line: lineNo
          });
          blockStack.push({ type: "loopNeq", index: instructions.length - 1 });
          continue;
        }

        if (op === "üòê") {
          if (tokens.length !== 1) throw makeError("parse", lineNo, "–ö–æ–º–∞–Ω–¥–∞ üòê –Ω–µ –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –∞—Ä–≥—É–º–µ–Ω—Ç—ã.");
          if (!blockStack.length) throw makeError("parse", lineNo, "–õ–∏—à–Ω–∏–π üòê –±–µ–∑ –æ—Ç–∫—Ä—ã–≤–∞—é—â–µ–≥–æ ü§î, üîÇ –∏–ª–∏ üîÅ.");
          const block = blockStack.pop();
          if (block.type === "if") {
            instructions.push({ type: "ifEnd", ifIndex: block.index, line: lineNo });
          } else if (block.type === "loopCount") {
            instructions.push({ type: "loopCountEnd", loopIndex: block.index, line: lineNo });
          } else {
            instructions.push({ type: "loopEnd", loopIndex: block.index, line: lineNo });
          }
          const endIndex = instructions.length - 1;
          instructions[block.index].jumpTo = endIndex + 1;
          continue;
        }

        throw makeError("parse", lineNo, `–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞: ${op}.`);
      }

      if (blockStack.length) {
        const firstBlock = blockStack[0];
        const firstUnclosed = instructions[firstBlock.index];
        const opener = firstBlock.type === "if" ? "ü§î" : (firstBlock.type === "loopCount" ? "üîÇ" : "üîÅ");
        throw makeError("parse", firstUnclosed.line, `–ë–ª–æ–∫ ${opener} –Ω–µ –∑–∞–∫—Ä—ã—Ç –∫–æ–º–∞–Ω–¥–æ–π üòê.`);
      }

      return instructions;
    }

    function initialVariables() {
      const out = {};
      for (let i = 0; i < VARIABLE_EMOJIS.length; i++) out[VARIABLE_EMOJIS[i]] = 0;
      return out;
    }

    function assertFiniteNumber(value, line, context) {
      if (!Number.isFinite(value)) {
        throw makeError("runtime", line, `${context}: –ø–æ–ª—É—á–µ–Ω–æ –Ω–µ—á–∏—Å–ª–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ.`);
      }
      return Math.trunc(value);
    }

    function isAsciiDigit(ch) {
      return ch >= "0" && ch <= "9";
    }

    function readNextInputNumber(inputText, state, line) {
      let idx = state.index;
      while (idx < inputText.length && /\s/u.test(inputText[idx])) idx += 1;

      if (idx >= inputText.length) {
        throw makeError("runtime", line, "–ö–æ–º–∞–Ω–¥–∞ ‚≠ê –Ω–µ –º–æ–∂–µ—Ç —á–∏—Ç–∞—Ç—å –∏–∑ –ø—É—Å—Ç—ã—Ö –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö.");
      }

      let valueText = "";
      while (idx < inputText.length && isAsciiDigit(inputText[idx])) {
        valueText += inputText[idx];
        idx += 1;
      }

      if (!valueText) {
        const got = inputText[idx];
        throw makeError("runtime", line, `–ö–æ–º–∞–Ω–¥–∞ ‚≠ê –æ–∂–∏–¥–∞–µ—Ç —á–∏—Å–ª–æ, –ø–æ–ª—É—á–µ–Ω–æ: ${got}.`);
      }

      state.index = idx;
      const parsed = Number(valueText);
      return assertFiniteNumber(parsed, line, "–ö–æ–º–∞–Ω–¥–∞ ‚≠ê");
    }

    function setStatus(kind, message) {
      statusBoxEl.className = `status-box ${kind}`;
      statusBoxEl.textContent = message;
    }

    function formatLineOnlyError(err) {
      const line = err && Number.isInteger(err.line) ? err.line : 0;
      if (line > 0) return `–û—à–∏–±–∫–∞ –≤ —Å—Ç—Ä–æ–∫–µ ${line}.`;
      return "–û—à–∏–±–∫–∞.";
    }

    function setPressedState(button, isPressed) {
      if (!button) return;
      button.setAttribute("aria-pressed", isPressed ? "true" : "false");
    }

    function syncExampleButtons() {
      for (let i = 0; i < exampleButtons.length; i++) {
        setPressedState(exampleButtons[i], i === selectedExampleIndex);
      }
    }

    function syncTaskButtons() {
      for (const btn of taskButtons) {
        const taskKey = String(btn.dataset.task || "");
        setPressedState(btn, taskKey === selectedTaskKey && selectedTaskKey !== "");
      }
    }

    function syncSubtaskButtons() {
      const subtaskButtons = Array.from(taskSubtasksEl.querySelectorAll("[data-subtask]"));
      for (const btn of subtaskButtons) {
        const key = String(btn.dataset.subtask || "");
        setPressedState(btn, key === selectedSubtaskKey && selectedSubtaskKey !== "");
      }
    }

    function setTaskText(subtaskKey) {
      if (!taskTextWrapEl || !taskTextEl) return;
      const raw = SUBTASK_TEXTS[subtaskKey];
      const lines = Array.isArray(raw)
        ? raw.map((item) => String(item || "").trim()).filter((item) => item.length > 0)
        : [];
      if (!lines.length) {
        taskTextEl.textContent = "";
        taskTextWrapEl.hidden = true;
        return;
      }
      taskTextEl.textContent = "";
      for (const line of lines) {
        const p = document.createElement("p");
        p.textContent = line;
        taskTextEl.appendChild(p);
      }
      taskTextWrapEl.hidden = false;
    }

    function applySubtaskPreset(subtaskKey) {
      const preset = SUBTASK_PRESETS[subtaskKey];
      if (!preset || typeof preset !== "object") return;
      codeInputEl.value = String(preset.code || "");
      refreshCodeLineNumbers();
      let tests = Array.isArray(preset.tests) && preset.tests.length ? preset.tests : [""];
      if (isTask4Subtask(subtaskKey)) {
        const visibleInputs = getTask4VisibleInputs();
        tests = visibleInputs.length ? visibleInputs : [""];
      }
      setTestsToUi(tests);
      resetResultPanels();
    }

    function selectSubtask(subtaskKey) {
      selectedSubtaskKey = subtaskKey;
      syncSubtaskButtons();
      setTaskText(subtaskKey);
      setScenarioKey(`task:${subtaskKey}`);
      applySubtaskPreset(subtaskKey);
    }

    function clearSubtasks() {
      selectedSubtaskKey = "";
      taskSubtasksEl.textContent = "";
      taskSubtasksEl.hidden = true;
      setTaskText("");
      syncTask4TestsUi();
    }

    function renderSubtasks(taskKey) {
      taskSubtasksEl.textContent = "";
      const rawCount = TASK_SUBTASK_COUNTS[taskKey];
      const count = Number.isInteger(rawCount) && rawCount > 0 ? rawCount : 4;
      if (count === 1) {
        taskSubtasksEl.hidden = true;
        return;
      }
      for (let i = 1; i <= count; i++) {
        const subtaskKey = `${taskKey}.${i}`;
        const btn = document.createElement("button");
        btn.type = "button";
        btn.dataset.subtask = subtaskKey;
        btn.setAttribute("aria-pressed", "false");
        btn.textContent = `–ü–æ–¥–∑–∞–¥–∞—á–∞ ${subtaskKey}`;
        btn.addEventListener("click", () => {
          selectSubtask(subtaskKey);
        });
        taskSubtasksEl.appendChild(btn);
      }
      taskSubtasksEl.hidden = false;
      syncSubtaskButtons();
    }

    function hideCodePhrasePanel() {
      if (!codePhrasePanelEl) return;
      codePhrasePanelEl.hidden = true;
      if (codePhraseInputEl) codePhraseInputEl.value = "";
    }

    function showCodePhrasePanel(phrase) {
      if (!codePhrasePanelEl || !codePhraseInputEl) return;
      const text = String(phrase || "");
      if (!text) {
        hideCodePhrasePanel();
        return;
      }
      codePhraseInputEl.value = text;
      codePhrasePanelEl.hidden = false;
    }

    function normalizeUnlockToken(value) {
      return String(value || "").trim();
    }

    function createRunNonce() {
      if (typeof crypto !== "undefined" && crypto && typeof crypto.getRandomValues === "function") {
        const bytes = new Uint32Array(2);
        crypto.getRandomValues(bytes);
        return `${Date.now().toString(36)}:${bytes[0].toString(36)}:${bytes[1].toString(36)}`;
      }
      return `${Date.now().toString(36)}:${Math.random().toString(36).slice(2)}`;
    }

    function hashTextFNV1a32(text) {
      const src = String(text || "");
      let hash = 0x811c9dc5;
      for (let i = 0; i < src.length; i++) {
        hash ^= src.charCodeAt(i);
        hash = Math.imul(hash, 0x01000193);
      }
      return (hash >>> 0).toString(16).padStart(8, "0");
    }

    function buildRunResultProof(nonce, testIndex, testInput, kind, value) {
      return hashTextFNV1a32([
        String(nonce || ""),
        String(testIndex),
        normalizeUnlockToken(testInput),
        String(kind || ""),
        normalizeUnlockToken(value)
      ].join("::"));
    }

    function makeUnlockProof(subtaskKey, tests, outputs) {
      return `${subtaskKey}::${tests.join("|")}::${outputs.join("|")}::LOVELACE`;
    }

    function deriveUnlockMasks(length, proof, seed) {
      let state = seed >>> 0;
      for (let i = 0; i < proof.length; i++) {
        state ^= proof.charCodeAt(i);
        state = (Math.imul((state + 0x9e3779b9) >>> 0, 1664525) + 1013904223) >>> 0;
      }

      const masks = [];
      for (let i = 0; i < length; i++) {
        state = (Math.imul((state ^ ((i + 1) * 0x45d9f3b)) >>> 0, 1597334677) + 12345) >>> 0;
        masks.push((state >>> 8) & 0xffff);
      }
      return masks;
    }

    function decodeUnlockPhrase(subtaskKey, rule) {
      if (!rule || !Array.isArray(rule.blob) || !rule.blob.length) return "";
      const proof = makeUnlockProof(subtaskKey, rule.tests, rule.outputs);
      const masks = deriveUnlockMasks(rule.blob.length, proof, rule.seed);
      let text = "";
      for (let i = 0; i < rule.blob.length; i++) {
        text += String.fromCharCode(rule.blob[i] ^ masks[i]);
      }
      return text;
    }

    function isCodePhraseSolved(subtaskKey, tests, results, runNonce) {
      const key = String(subtaskKey || "");
      const rule = CODE_PHRASE_UNLOCK_RULES[key];
      if (!rule) return false;
      if (!Array.isArray(tests) || !Array.isArray(results)) return false;
      if (!runNonce) return false;
      if (tests.length !== rule.tests.length) return false;
      if (results.length !== rule.outputs.length) return false;

      for (let i = 0; i < rule.tests.length; i++) {
        if (normalizeUnlockToken(tests[i]) !== rule.tests[i]) return false;
        const result = results[i];
        if (!result || result.kind !== "ok" || result.source !== "runtime") return false;
        const expectedProof = buildRunResultProof(runNonce, i, tests[i], result.kind, result.value);
        if (result.proof !== expectedProof) return false;
        if (normalizeUnlockToken(result.value) !== rule.outputs[i]) return false;
      }

      return true;
    }

    function pickTask4VisibleResults(cases, results) {
      if (!Array.isArray(cases) || !Array.isArray(results)) return [];
      const out = [];
      for (let i = 0; i < cases.length; i++) {
        if (!cases[i] || !cases[i].visible) continue;
        const result = results[i];
        if (!result) continue;
        out.push(result);
      }
      return out;
    }

    function countTask4Matches(cases, results) {
      if (!Array.isArray(cases) || !Array.isArray(results) || results.length !== cases.length) return 0;
      let matched = 0;
      for (let i = 0; i < cases.length; i++) {
        const result = results[i];
        const expected = normalizeUnlockToken(cases[i] && cases[i].expected);
        if (!result || result.kind !== "ok" || result.source !== "runtime") continue;
        if (normalizeUnlockToken(result.value) === expected) matched += 1;
      }
      return matched;
    }

    function isTask4Solved(cases, results) {
      return Array.isArray(cases) && cases.length > 0 && countTask4Matches(cases, results) === cases.length;
    }

    function setScenarioKey(key) {
      currentScenarioKey = String(key || "");
      hideCodePhrasePanel();
    }

    function resetResultPanels() {
      hideCodePhrasePanel();
      setStatus("", "–û–∂–∏–¥–∞–Ω–∏–µ –∑–∞–ø—É—Å–∫–∞.");
      stepCountEl.textContent = "–°—É–º–º–∞—Ä–Ω—ã–µ —à–∞–≥–∏: 0";
      testOutputsEl.textContent = "";
    }

    function createTestItem(inputText = "") {
      const wrap = document.createElement("section");
      wrap.className = "test-item";

      const head = document.createElement("div");
      head.className = "test-head";

      const label = document.createElement("div");
      label.className = "test-label";
      label.dataset.testLabel = "1";

      const removeBtn = document.createElement("button");
      removeBtn.type = "button";
      removeBtn.textContent = "üóëÔ∏è";
      removeBtn.className = "icon-btn";
      removeBtn.title = "–£–¥–∞–ª–∏—Ç—å —Ç–µ—Å—Ç";
      removeBtn.setAttribute("aria-label", "–£–¥–∞–ª–∏—Ç—å —Ç–µ—Å—Ç");
      removeBtn.dataset.testRemove = "1";
      removeBtn.addEventListener("click", () => {
        if (isTask4Subtask()) return;
        wrap.remove();
        renumberTests();
        resetResultPanels();
      });

      head.appendChild(label);
      head.appendChild(removeBtn);

      const input = document.createElement("textarea");
      input.className = "stdin-input";
      input.spellcheck = false;
      input.autocomplete = "off";
      input.autocapitalize = "off";
      input.dataset.testInput = "1";
      input.value = String(inputText || "");
      input.rows = 2;

      wrap.appendChild(head);
      wrap.appendChild(input);
      return wrap;
    }

    function renumberTests() {
      const tests = Array.from(testListEl.querySelectorAll(".test-item"));
      const lockTests = isTask4Subtask();
      if (!tests.length) {
        testListEl.appendChild(createTestItem(""));
        return renumberTests();
      }
      for (let i = 0; i < tests.length; i++) {
        const item = tests[i];
        const label = item.querySelector("[data-test-label]");
        const removeBtn = item.querySelector("[data-test-remove]");
        const input = item.querySelector("[data-test-input]");
        if (label) label.textContent = `–¢–µ—Å—Ç ${i + 1}`;
        if (removeBtn) {
          removeBtn.disabled = lockTests || tests.length === 1;
          removeBtn.hidden = lockTests;
        }
        if (input) input.readOnly = lockTests;
      }
      syncTask4TestsUi();
    }

    function getTestsFromUi() {
      const fields = Array.from(testListEl.querySelectorAll("[data-test-input]"));
      return fields.map((field) => String(field.value || ""));
    }

    function setTestsToUi(inputs) {
      testListEl.textContent = "";
      const list = Array.isArray(inputs) && inputs.length ? inputs : [""];
      for (const text of list) {
        testListEl.appendChild(createTestItem(text));
      }
      renumberTests();
    }

    function renderOutputs(results) {
      testOutputsEl.textContent = "";
      for (let i = 0; i < results.length; i++) {
        const result = results[i];
        const card = document.createElement("section");
        card.className = `test-output-card ${result.kind}`;

        const title = document.createElement("div");
        title.className = "test-label";
        title.textContent = `–¢–µ—Å—Ç ${i + 1}`;

        const meta = document.createElement("div");
        meta.className = "test-output-meta";
        meta.textContent = result.meta;

        const out = document.createElement("textarea");
        out.className = "output-box";
        out.readOnly = true;
        out.value = result.value;

        card.appendChild(title);
        card.appendChild(meta);
        card.appendChild(out);
        testOutputsEl.appendChild(card);
      }
    }

    function initTaskPlaceholders() {
      syncExampleButtons();
      syncTaskButtons();
      clearSubtasks();

      for (const btn of taskButtons) {
        btn.addEventListener("click", () => {
          const taskKey = String(btn.dataset.task || "");
          if (!taskKey) return;
          selectedExampleIndex = -1;
          selectedTaskKey = taskKey;
          selectedSubtaskKey = "";
          syncExampleButtons();
          syncTaskButtons();
          renderSubtasks(taskKey);
          selectSubtask(`${taskKey}.1`);
        });
      }
    }

    async function executeProgram(instructions, inputText) {
      const vars = initialVariables();
      const normalizedInput = String(inputText || "");
      const inputState = { index: 0 };
      const loopCountState = new Map();
      let output = "";
      let pc = 0;
      let steps = 0;

      while (pc < instructions.length) {
        if (steps >= HARD_STEP_LIMIT) {
          return {
            status: "limit",
            message: `–ü—Ä–µ–≤—ã—à–µ–Ω –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –ª–∏–º–∏—Ç —à–∞–≥–æ–≤ (${HARD_STEP_LIMIT}).`,
            steps,
            output,
            vars
          };
        }

        const ins = instructions[pc];
        steps += 1;

        if (ins.type === "set") {
          vars[ins.target] = ins.value;
          pc += 1;
        } else if (ins.type === "readNumber") {
          vars[ins.target] = readNextInputNumber(normalizedInput, inputState, ins.line);
          pc += 1;
        } else if (ins.type === "random") {
          const low = assertFiniteNumber(vars[ins.low], ins.line, "–ö–æ–º–∞–Ω–¥–∞ üé≤ (–Ω–∏–∂–Ω—è—è –≥—Ä–∞–Ω–∏—Ü–∞)");
          const high = assertFiniteNumber(vars[ins.high], ins.line, "–ö–æ–º–∞–Ω–¥–∞ üé≤ (–≤–µ—Ä—Ö–Ω—è—è –≥—Ä–∞–Ω–∏—Ü–∞)");
          if (low > high) {
            throw makeError("runtime", ins.line, `–ö–æ–º–∞–Ω–¥–∞ üé≤: low (${low}) –±–æ–ª—å—à–µ high (${high}).`);
          }
          const value = low + Math.floor(Math.random() * (high - low + 1));
          vars[ins.target] = assertFiniteNumber(value, ins.line, "–ö–æ–º–∞–Ω–¥–∞ üé≤ (—Ä–µ–∑—É–ª—å—Ç–∞—Ç)");
          pc += 1;
        } else if (ins.type === "printNumber") {
          const value = assertFiniteNumber(vars[ins.target], ins.line, "–ö–æ–º–∞–Ω–¥–∞ üòÄ");
          output += String(value);
          pc += 1;
        } else if (ins.type === "math") {
          const left = assertFiniteNumber(vars[ins.left], ins.line, `–ö–æ–º–∞–Ω–¥–∞ ${ins.op}`);
          const right = assertFiniteNumber(vars[ins.right], ins.line, `–ö–æ–º–∞–Ω–¥–∞ ${ins.op}`);
          let result = 0;

          if (ins.op === "‚ûï") result = left + right;
          else if (ins.op === "‚ûñ") result = left - right;
          else if (ins.op === "‚úñ") result = left * right;
          else if (ins.op === "‚ûó") {
            if (right === 0) throw makeError("runtime", ins.line, "–ö–æ–º–∞–Ω–¥–∞ ‚ûó: –¥–µ–ª–µ–Ω–∏–µ –Ω–∞ –Ω–æ–ª—å.");
            result = Math.trunc(left / right);
          } else if (ins.op === "‚û∞") {
            if (right === 0) throw makeError("runtime", ins.line, "–ö–æ–º–∞–Ω–¥–∞ ‚û∞: –¥–µ–ª–µ–Ω–∏–µ –Ω–∞ –Ω–æ–ª—å.");
            result = left % right;
          }

          vars[ins.left] = assertFiniteNumber(result, ins.line, `–ö–æ–º–∞–Ω–¥–∞ ${ins.op}`);
          pc += 1;
        } else if (ins.type === "ifEq") {
          const left = assertFiniteNumber(vars[ins.left], ins.line, "–ö–æ–º–∞–Ω–¥–∞ ü§î");
          const right = assertFiniteNumber(vars[ins.right], ins.line, "–ö–æ–º–∞–Ω–¥–∞ ü§î");
          if (left === right) pc += 1;
          else pc = ins.jumpTo;
        } else if (ins.type === "loopCount") {
          if (!loopCountState.has(pc)) {
            const total = assertFiniteNumber(vars[ins.count], ins.line, "–ö–æ–º–∞–Ω–¥–∞ üîÇ");
            loopCountState.set(pc, total);
          }
          const remaining = loopCountState.get(pc);
          if (remaining > 0) {
            loopCountState.set(pc, remaining - 1);
            pc += 1;
          } else {
            loopCountState.delete(pc);
            pc = ins.jumpTo;
          }
        } else if (ins.type === "loopNeq") {
          const left = assertFiniteNumber(vars[ins.left], ins.line, "–ö–æ–º–∞–Ω–¥–∞ üîÅ");
          const right = assertFiniteNumber(vars[ins.right], ins.line, "–ö–æ–º–∞–Ω–¥–∞ üîÅ");
          if (left !== right) pc += 1;
          else pc = ins.jumpTo;
        } else if (ins.type === "ifEnd") {
          pc += 1;
        } else if (ins.type === "loopCountEnd") {
          pc = ins.loopIndex;
        } else if (ins.type === "loopEnd") {
          pc = ins.loopIndex;
        } else {
          throw makeError("runtime", ins.line, `–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è —Ç–∏–ø–∞ ${ins.type}.`);
        }

        if (steps % YIELD_EVERY === 0) {
          await new Promise((resolve) => setTimeout(resolve, 0));
        }
      }

      return {
        status: "ok",
        message: "–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ.",
        steps,
        output,
        vars
      };
    }

    function updateFocusTarget(target) {
      if (target === codeInputEl) lastFocusedField = target;
    }

    function resolveInsertTarget() {
      if (lastFocusedField === codeInputEl) return lastFocusedField;
      return codeInputEl;
    }

    function insertEmoji(emoji) {
      const target = resolveInsertTarget();
      target.focus();
      const start = typeof target.selectionStart === "number" ? target.selectionStart : target.value.length;
      const end = typeof target.selectionEnd === "number" ? target.selectionEnd : target.value.length;
      target.setRangeText(emoji, start, end, "end");
      updateFocusTarget(target);
      if (target === codeInputEl) refreshCodeLineNumbers();
    }

    function focusCodeInput() {
      codeInputEl.focus();
      updateFocusTarget(codeInputEl);
      return codeInputEl;
    }

    function getSelectionRange(target) {
      const start = typeof target.selectionStart === "number" ? target.selectionStart : target.value.length;
      const end = typeof target.selectionEnd === "number" ? target.selectionEnd : start;
      return { start, end };
    }

    function findLineStart(text, pos) {
      if (pos <= 0) return 0;
      const idx = text.lastIndexOf("\n", pos - 1);
      return idx === -1 ? 0 : idx + 1;
    }

    function findLineEnd(text, pos) {
      const idx = text.indexOf("\n", pos);
      return idx === -1 ? text.length : idx;
    }

    function getGraphemeBoundaries(text) {
      const src = String(text || "");
      const boundaries = [0];
      if (!src.length) return boundaries;

      if (GRAPHEME_SEGMENTER) {
        const segments = GRAPHEME_SEGMENTER.segment(src);
        for (const item of segments) {
          const end = item.index + item.segment.length;
          if (end > boundaries[boundaries.length - 1]) boundaries.push(end);
        }
      } else {
        let idx = 0;
        for (const ch of src) {
          idx += ch.length;
          boundaries.push(idx);
        }
      }

      if (boundaries[boundaries.length - 1] !== src.length) boundaries.push(src.length);
      return boundaries;
    }

    function boundaryAtOrBefore(text, pos) {
      const src = String(text || "");
      const clamped = Math.max(0, Math.min(src.length, pos));
      const boundaries = getGraphemeBoundaries(src);
      let out = 0;
      for (let i = 0; i < boundaries.length; i++) {
        const b = boundaries[i];
        if (b <= clamped) out = b;
        else break;
      }
      return out;
    }

    function boundaryAtOrAfter(text, pos) {
      const src = String(text || "");
      const clamped = Math.max(0, Math.min(src.length, pos));
      const boundaries = getGraphemeBoundaries(src);
      for (let i = 0; i < boundaries.length; i++) {
        const b = boundaries[i];
        if (b >= clamped) return b;
      }
      return src.length;
    }

    function previousBoundary(text, pos) {
      const src = String(text || "");
      const clamped = Math.max(0, Math.min(src.length, pos));
      const boundaries = getGraphemeBoundaries(src);
      let out = 0;
      for (let i = 0; i < boundaries.length; i++) {
        const b = boundaries[i];
        if (b < clamped) out = b;
        else break;
      }
      return out;
    }

    function nextBoundary(text, pos) {
      const src = String(text || "");
      const clamped = Math.max(0, Math.min(src.length, pos));
      const boundaries = getGraphemeBoundaries(src);
      for (let i = 0; i < boundaries.length; i++) {
        const b = boundaries[i];
        if (b > clamped) return b;
      }
      return src.length;
    }

    function graphemeIndexAtPosition(text, pos) {
      const src = String(text || "");
      const clamped = Math.max(0, Math.min(src.length, pos));
      const boundaries = getGraphemeBoundaries(src);
      let idx = 0;
      for (let i = 0; i < boundaries.length; i++) {
        if (boundaries[i] <= clamped) idx = i;
        else break;
      }
      return idx;
    }

    function positionAtGraphemeIndex(text, index) {
      const boundaries = getGraphemeBoundaries(text);
      const safeIdx = Math.max(0, Math.min(index, boundaries.length - 1));
      return boundaries[safeIdx];
    }

    function graphemeRangeContaining(text, pos) {
      const src = String(text || "");
      if (!src.length) return { start: 0, end: 0 };
      const clamped = Math.max(0, Math.min(src.length - 1, pos));
      const boundaries = getGraphemeBoundaries(src);
      for (let i = 0; i < boundaries.length - 1; i++) {
        const start = boundaries[i];
        const end = boundaries[i + 1];
        if (clamped >= start && clamped < end) return { start, end };
      }
      const last = boundaries[boundaries.length - 1];
      return { start: last, end: last };
    }

    function moveCaretHorizontal(delta) {
      const target = focusCodeInput();
      const text = target.value;
      const { start, end } = getSelectionRange(target);
      let next = start;
      if (delta < 0) {
        if (start !== end) {
          next = boundaryAtOrBefore(text, Math.min(start, end));
        } else {
          next = previousBoundary(text, start);
        }
      } else {
        if (start !== end) {
          next = boundaryAtOrAfter(text, Math.max(start, end));
        } else {
          next = nextBoundary(text, end);
        }
      }
      target.setSelectionRange(next, next);
      updateFocusTarget(target);
    }

    function moveCaretVertical(delta) {
      const target = focusCodeInput();
      const text = target.value;
      const { start, end } = getSelectionRange(target);
      const base = delta < 0 ? Math.min(start, end) : Math.max(start, end);
      const currStart = findLineStart(text, base);
      const currEnd = findLineEnd(text, base);
      const currLine = text.slice(currStart, currEnd);
      const currRel = Math.max(0, Math.min(currLine.length, base - currStart));
      const currCol = graphemeIndexAtPosition(currLine, currRel);
      let next = base;

      if (delta < 0) {
        if (currStart === 0) {
          next = 0;
        } else {
          const prevEnd = currStart - 1;
          const prevStart = findLineStart(text, prevEnd);
          const prevLine = text.slice(prevStart, prevEnd);
          const prevRel = positionAtGraphemeIndex(prevLine, currCol);
          next = prevStart + prevRel;
        }
      } else {
        if (currEnd >= text.length) {
          next = text.length;
        } else {
          const nextStart = currEnd + 1;
          const nextEnd = findLineEnd(text, nextStart);
          const nextLine = text.slice(nextStart, nextEnd);
          const nextRel = positionAtGraphemeIndex(nextLine, currCol);
          next = nextStart + nextRel;
        }
      }

      target.setSelectionRange(next, next);
      updateFocusTarget(target);
    }

    function insertCodeText(text) {
      const target = focusCodeInput();
      const { start, end } = getSelectionRange(target);
      target.setRangeText(text, start, end, "end");
      updateFocusTarget(target);
      refreshCodeLineNumbers();
    }

    function backspaceInCodeInput() {
      const target = focusCodeInput();
      const text = target.value;
      const { start, end } = getSelectionRange(target);
      if (start !== end) {
        const delStart = boundaryAtOrBefore(text, Math.min(start, end));
        const delEnd = boundaryAtOrAfter(text, Math.max(start, end));
        target.setRangeText("", delStart, delEnd, "end");
      } else if (start > 0) {
        const range = graphemeRangeContaining(text, start - 1);
        target.setRangeText("", range.start, range.end, "end");
      }
      updateFocusTarget(target);
      refreshCodeLineNumbers();
    }

    function deleteInCodeInput() {
      const target = focusCodeInput();
      const text = target.value;
      const { start, end } = getSelectionRange(target);
      if (start !== end) {
        const delStart = boundaryAtOrBefore(text, Math.min(start, end));
        const delEnd = boundaryAtOrAfter(text, Math.max(start, end));
        target.setRangeText("", delStart, delEnd, "end");
      } else if (start < text.length) {
        const range = graphemeRangeContaining(text, start);
        target.setRangeText("", range.start, range.end, "end");
      }
      updateFocusTarget(target);
      refreshCodeLineNumbers();
    }

    function createNavButton(text, title, className, onClick) {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = `nav-btn ${className}`;
      btn.textContent = text;
      btn.title = title;
      btn.addEventListener("mousedown", (event) => {
        event.preventDefault();
      });
      btn.addEventListener("click", onClick);
      return btn;
    }

    function renderKeyboard() {
      emojiKeyboardEl.textContent = "";
      const layoutEl = document.createElement("div");
      layoutEl.className = "keyboard-layout";

      const leftEl = document.createElement("div");
      leftEl.className = "keyboard-left";

      for (let i = 0; i < KEYBOARD_GROUPS.length; i++) {
        const group = KEYBOARD_GROUPS[i];
        const groupEl = document.createElement("section");
        groupEl.className = `emoji-group group-${i + 1}`;

        const gridEl = document.createElement("div");
        gridEl.className = "emoji-grid";

        for (let j = 0; j < group.length; j++) {
          const emoji = group[j];
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "emoji-btn";
          btn.textContent = emoji;
          btn.title = `–í—Å—Ç–∞–≤–∏—Ç—å ${emoji}`;
          btn.addEventListener("mousedown", (event) => {
            event.preventDefault();
          });
          btn.addEventListener("click", () => {
            insertEmoji(emoji);
          });
          gridEl.appendChild(btn);
        }

        groupEl.appendChild(gridEl);
        leftEl.appendChild(groupEl);
      }

      const navEl = document.createElement("section");
      navEl.className = "editor-nav";

      const navTitleEl = document.createElement("p");
      navTitleEl.className = "nav-title";
      navTitleEl.textContent = "–ù–∞–≤–∏–≥–∞—Ü–∏—è";

      const arrowsEl = document.createElement("div");
      arrowsEl.className = "nav-arrows";
      arrowsEl.appendChild(createNavButton("‚Üë", "–°—Ç—Ä–µ–ª–∫–∞ –≤–≤–µ—Ä—Ö", "up", () => moveCaretVertical(-1)));
      arrowsEl.appendChild(createNavButton("‚Üê", "–°—Ç—Ä–µ–ª–∫–∞ –≤–ª–µ–≤–æ", "left", () => moveCaretHorizontal(-1)));
      arrowsEl.appendChild(createNavButton("‚Üì", "–°—Ç—Ä–µ–ª–∫–∞ –≤–Ω–∏–∑", "down", () => moveCaretVertical(1)));
      arrowsEl.appendChild(createNavButton("‚Üí", "–°—Ç—Ä–µ–ª–∫–∞ –≤–ø—Ä–∞–≤–æ", "right", () => moveCaretHorizontal(1)));

      const actionsEl = document.createElement("div");
      actionsEl.className = "nav-actions";
      actionsEl.appendChild(createNavButton("Enter", "–í—Å—Ç–∞–≤–∏—Ç—å –ø–µ—Ä–µ–Ω–æ—Å —Å—Ç—Ä–æ–∫–∏", "enter", () => insertCodeText("\n")));
      actionsEl.appendChild(createNavButton("Backspace", "–£–¥–∞–ª–∏—Ç—å —Å–∏–º–≤–æ–ª —Å–ª–µ–≤–∞", "backspace", () => backspaceInCodeInput()));
      actionsEl.appendChild(createNavButton("Delete", "–£–¥–∞–ª–∏—Ç—å —Å–∏–º–≤–æ–ª —Å–ø—Ä–∞–≤–∞", "delete", () => deleteInCodeInput()));

      navEl.appendChild(navTitleEl);
      navEl.appendChild(arrowsEl);
      navEl.appendChild(actionsEl);

      layoutEl.appendChild(leftEl);
      layoutEl.appendChild(navEl);
      emojiKeyboardEl.appendChild(layoutEl);
    }

    async function handleRun() {
      runBtn.disabled = true;
      hideCodePhrasePanel();
      setStatus("", "–ü–∞—Ä—Å–∏–Ω–≥ –ø—Ä–æ–≥—Ä–∞–º–º—ã...");
      stepCountEl.textContent = "–°—É–º–º–∞—Ä–Ω—ã–µ —à–∞–≥–∏: 0";
      const runNonce = createRunNonce();
      const task4Mode = isTask4Subtask();
      const task4Cases = task4Mode ? getTask4Cases() : [];
      if (task4Mode && !task4Cases.length) {
        renderOutputs([]);
        setStatus("error", "–û—à–∏–±–∫–∞.");
        runBtn.disabled = false;
        return;
      }

      const tests = task4Mode
        ? task4Cases.map((item) => String(item.input || ""))
        : getTestsFromUi();
      const hasAtLeastOneTest = tests.length > 0;
      if (!hasAtLeastOneTest && !task4Mode) {
        setTestsToUi([""]);
      }
      const safeTests = hasAtLeastOneTest ? tests : [""];

      let instructions = [];
      try {
        instructions = parseProgram(codeInputEl.value);
      } catch (err) {
        const msg = formatLineOnlyError(err);
        const failResults = safeTests.map(() => ({
          kind: "error",
          meta: "–û—à–∏–±–∫–∞",
          value: msg,
          source: "runtime",
          proof: ""
        }));
        const displayFailResults = task4Mode
          ? pickTask4VisibleResults(task4Cases, failResults)
          : failResults;
        renderOutputs(displayFailResults);
        setStatus("error", msg);
        runBtn.disabled = false;
        return;
      }

      setStatus("", `–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏–π: ${instructions.length}. –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —Ç–µ—Å—Ç–æ–≤...`);

      const results = [];
      let totalSteps = 0;
      let okCount = 0;
      let warnCount = 0;
      let errCount = 0;

      for (let i = 0; i < safeTests.length; i++) {
        try {
          const result = await executeProgram(instructions, safeTests[i]);
          totalSteps += result.steps;
          if (result.status === "ok") {
            okCount += 1;
            results.push({
              kind: "ok",
              meta: `–£—Å–ø–µ—Ö. –®–∞–≥–∏: ${result.steps}`,
              value: result.output,
              source: "runtime",
              proof: buildRunResultProof(runNonce, i, safeTests[i], "ok", result.output)
            });
          } else if (result.status === "limit") {
            warnCount += 1;
            results.push({
              kind: "warn",
              meta: `–õ–∏–º–∏—Ç —à–∞–≥–æ–≤. –®–∞–≥–∏: ${result.steps}`,
              value: result.output,
              source: "runtime",
              proof: buildRunResultProof(runNonce, i, safeTests[i], "warn", result.output)
            });
          } else {
            warnCount += 1;
            results.push({
              kind: "warn",
              meta: `–ù–µ–æ–±—ã—á–Ω—ã–π —Å—Ç–∞—Ç—É—Å. –®–∞–≥–∏: ${result.steps}`,
              value: result.output,
              source: "runtime",
              proof: buildRunResultProof(runNonce, i, safeTests[i], "warn", result.output)
            });
          }
        } catch (err) {
          errCount += 1;
          const msg = formatLineOnlyError(err);
          results.push({
            kind: "error",
            meta: "–û—à–∏–±–∫–∞",
            value: msg,
            source: "runtime",
            proof: buildRunResultProof(runNonce, i, safeTests[i], "error", msg)
          });
        }
      }

      const displayResults = task4Mode
        ? pickTask4VisibleResults(task4Cases, results)
        : results;
      renderOutputs(displayResults);
      stepCountEl.textContent = `–°—É–º–º–∞—Ä–Ω—ã–µ —à–∞–≥–∏: ${totalSteps}`;
      const hasUnlockRule = Boolean(selectedSubtaskKey && CODE_PHRASE_UNLOCK_RULES[selectedSubtaskKey]);
      const solvedByRule = hasUnlockRule
        ? isCodePhraseSolved(selectedSubtaskKey, safeTests, results, runNonce)
        : false;
      const solvedByTask4 = task4Mode
        ? isTask4Solved(task4Cases, results)
        : false;
      if (errCount > 0) {
        setStatus("error", `–ì–æ—Ç–æ–≤–æ: —É—Å–ø–µ—Ö ${okCount}, –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è ${warnCount}, –æ—à–∏–±–∫–∏ ${errCount}.`);
      } else if (warnCount > 0) {
        setStatus("warn", `–ì–æ—Ç–æ–≤–æ: —É—Å–ø–µ—Ö ${okCount}, –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è ${warnCount}.`);
      } else if (task4Mode && !solvedByTask4) {
        const matched = countTask4Matches(task4Cases, results);
        setStatus("warn", `–ì–æ—Ç–æ–≤–æ: —Å–æ–≤–ø–∞–ª–æ —Å —ç—Ç–∞–ª–æ–Ω–æ–º ${matched} –∏–∑ ${task4Cases.length} —Ç–µ—Å—Ç(–∞/–æ–≤).`);
      } else if (hasUnlockRule && !solvedByRule) {
        setStatus("warn", `–ì–æ—Ç–æ–≤–æ: –≤—Å–µ ${okCount} —Ç–µ—Å—Ç(–∞/–æ–≤) –≤—ã–ø–æ–ª–Ω–µ–Ω—ã, –Ω–æ —ç—Ç–∞–ª–æ–Ω –Ω–µ —Å–æ–≤–ø–∞–ª.`);
      } else {
        setStatus("ok", `–ì–æ—Ç–æ–≤–æ: –≤—Å–µ ${okCount} —Ç–µ—Å—Ç(–∞/–æ–≤) –≤—ã–ø–æ–ª–Ω–µ–Ω—ã —É—Å–ø–µ—à–Ω–æ.`);
      }

      if (task4Mode && solvedByTask4) {
        showCodePhrasePanel(getTask4Phrase());
      } else if (solvedByRule && selectedSubtaskKey) {
        const rule = CODE_PHRASE_UNLOCK_RULES[selectedSubtaskKey];
        const phrase = decodeUnlockPhrase(selectedSubtaskKey, rule);
        showCodePhrasePanel(phrase);
      }

      runBtn.disabled = false;
    }

    function handleReset() {
      resetResultPanels();
    }

    function applyExample(index) {
      const item = EXAMPLES[index];
      if (!item) return;
      selectedExampleIndex = index;
      selectedTaskKey = "";
      syncExampleButtons();
      syncTaskButtons();
      clearSubtasks();
      codeInputEl.value = item.code;
      refreshCodeLineNumbers();
      setTestsToUi(item.tests);
      setScenarioKey(`example:${index + 1}`);
      codeInputEl.focus();
      updateFocusTarget(codeInputEl);
      resetResultPanels();
    }

    for (const el of [codeInputEl]) {
      el.addEventListener("focus", () => updateFocusTarget(el));
      el.addEventListener("click", () => updateFocusTarget(el));
      el.addEventListener("keyup", () => updateFocusTarget(el));
    }
    codeInputEl.addEventListener("input", refreshCodeLineNumbers);
    codeInputEl.addEventListener("scroll", syncCodeLineNumbersScroll);
    if (typeof ResizeObserver === "function") {
      codeInputResizeObserver = new ResizeObserver(() => {
        syncCodeLineNumbersHeight();
      });
      codeInputResizeObserver.observe(codeInputEl);
    } else {
      window.addEventListener("resize", syncCodeLineNumbersHeight);
    }

    runBtn.addEventListener("click", () => {
      handleRun();
    });
    resetBtn.addEventListener("click", handleReset);
    for (let i = 0; i < exampleButtons.length; i++) {
      exampleButtons[i].addEventListener("click", () => applyExample(i));
    }
    addTestBtn.addEventListener("click", () => {
      if (isTask4Subtask()) return;
      testListEl.appendChild(createTestItem(""));
      renumberTests();
      resetResultPanels();
    });
    resetTestsBtn.addEventListener("click", () => {
      if (isTask4Subtask()) return;
      setTestsToUi([""]);
      resetResultPanels();
    });
    if (copyCodePhraseBtn && codePhraseInputEl) {
      copyCodePhraseBtn.addEventListener("click", async () => {
        const text = String(codePhraseInputEl.value || "");
        if (!text) {
          setStatus("warn", "–ö–æ–¥–æ–≤–∞—è —Ñ—Ä–∞–∑–∞ –ø—É—Å—Ç–∞.");
          return;
        }
        try {
          await navigator.clipboard.writeText(text);
          setStatus("ok", "–ö–æ–¥–æ–≤–∞—è —Ñ—Ä–∞–∑–∞ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞.");
        } catch (_) {
          codePhraseInputEl.focus();
          codePhraseInputEl.select();
          setStatus("warn", "–ö–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ —á–µ—Ä–µ–∑ –±—É—Ñ–µ—Ä –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ. –¢–µ–∫—Å—Ç –≤—ã–¥–µ–ª–µ–Ω –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è.");
        }
      });
    }

    renderKeyboard();
    initTaskPlaceholders();
    setTestsToUi([""]);
    setScenarioKey("");
    resetResultPanels();
    refreshCodeLineNumbers();
    codeInputEl.focus();
    updateFocusTarget(codeInputEl);
  </script>
</body>
</html>
