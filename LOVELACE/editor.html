<!doctype html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22%3E%3Ctext y=%22.9em%22 font-size=%2290%22%3E%F0%9F%A7%91%E2%80%8D%F0%9F%94%AC%3C/text%3E%3C/svg%3E">
  <title>Ğ­Ğ¼Ğ¾Ğ´Ğ·Ğ¸-Ğ¿Ñ€Ğ¾Ğ³Ñ€Ğ°Ğ¼Ğ¼Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ</title>
  <script src="../section-auth.js"></script>
  <script>window.SectionAuth && window.SectionAuth.guardPage("LOVELACE");</script>
  <style>
    @font-face {
      font-family: "Noto Color Emoji";
      font-style: normal;
      font-weight: 400;
      font-display: swap;
      src:
        url("https://cdn.jsdelivr.net/fontsource/fonts/noto-color-emoji@latest/emoji-400-normal.woff2") format("woff2"),
        url("https://cdn.jsdelivr.net/fontsource/fonts/noto-color-emoji@latest/emoji-400-normal.ttf") format("truetype");
    }

    :root {
      --bg: #f3f4f6;
      --panel: #ffffff;
      --text: #111827;
      --muted: #6b7280;
      --border: #d1d5db;
      --accent: #2563eb;
      --accent-strong: #1d4ed8;
      --danger-bg: #fee2e2;
      --danger-fg: #991b1b;
      --ok-bg: #dcfce7;
      --ok-fg: #166534;
      --warn-bg: #fef3c7;
      --warn-fg: #92400e;
      --emoji-font: "Noto Color Emoji", "Twemoji Mozilla", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Sans", "Segoe UI", sans-serif;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at 20% 0%, #ffffff, var(--bg));
      color: var(--text);
      font-family: "Segoe UI", "Noto Sans", sans-serif;
      padding: 20px;
    }

    .app {
      width: min(1320px, 100%);
      margin: 0 auto;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 18px;
      padding: 16px;
      box-shadow: 0 14px 30px rgba(17, 24, 39, 0.09);
      display: grid;
      gap: 12px;
    }

    .topbar {
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
    }

    .title {
      margin: 0;
      font-size: clamp(1.35rem, 2vw, 1.8rem);
      font-weight: 900;
      letter-spacing: -0.02em;
    }

    .back-link {
      text-decoration: none;
      border: 1px solid var(--border);
      border-radius: 10px;
      color: var(--text);
      background: #fff;
      padding: 8px 12px;
      font-weight: 700;
      transition: 120ms ease;
    }

    .back-link:hover {
      border-color: #9ca3af;
      transform: translateY(-1px);
    }

    .blocks {
      display: grid;
      gap: 12px;
    }

    .panel {
      border: 1px solid var(--border);
      border-radius: 14px;
      background: #fcfcfd;
      padding: 12px;
      display: grid;
      gap: 10px;
    }

    .panel[hidden] {
      display: none !important;
    }

    h2 {
      margin: 0;
      font-size: 1rem;
      font-weight: 800;
    }

    .block-title {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .block-num {
      width: 24px;
      height: 24px;
      border-radius: 999px;
      display: inline-grid;
      place-items: center;
      font-size: 12px;
      font-weight: 900;
      background: #dbeafe;
      color: #1d4ed8;
      border: 1px solid #93c5fd;
      flex: 0 0 auto;
    }

    .switchers {
      display: grid;
      gap: 10px;
      grid-template-columns: 1fr 1fr;
    }

    .mini-title {
      font-size: 12px;
      font-weight: 800;
      letter-spacing: 0.02em;
      text-transform: uppercase;
      color: #475569;
      margin-bottom: 6px;
    }

    label {
      font-weight: 700;
      font-size: 14px;
    }

    textarea {
      width: 100%;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #fff;
      color: var(--text);
      padding: 10px 12px;
      outline: none;
      transition: 120ms ease;
      resize: vertical;
    }

    .text-input {
      width: 100%;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #fff;
      color: var(--text);
      padding: 10px 12px;
      outline: none;
      transition: 120ms ease;
      font: inherit;
    }

    .text-input:focus {
      border-color: #3b82f6;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
    }

    textarea:focus {
      border-color: #3b82f6;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
    }

    .emoji-field {
      font-family: var(--emoji-font);
      font-size: 18px;
      line-height: 1.45;
    }

    .code-editor {
      display: grid;
      grid-template-columns: auto 1fr;
      border: 1px solid var(--border);
      border-radius: 10px;
      overflow: hidden;
      background: #fff;
    }

    .code-editor:focus-within {
      border-color: #3b82f6;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
    }

    .code-lines {
      width: 84px;
      min-width: 84px;
      border: none;
      border-right: 1px solid #e5e7eb;
      border-radius: 0;
      background: #f8fafc;
      color: #64748b;
      text-align: right;
      resize: none;
      overflow: hidden;
      padding: 10px 8px;
      letter-spacing: 0;
      word-spacing: 0;
      font-variant-ligatures: none;
      user-select: none;
      pointer-events: none;
    }

    .code-lines:focus {
      box-shadow: none;
      border-color: #e5e7eb;
    }

    .code-input {
      min-height: 320px;
      border: none;
      border-radius: 0;
      background: transparent;
    }

    .code-input:focus {
      border-color: transparent;
      box-shadow: none;
    }

    .stdin-input {
      min-height: 84px;
      font-family: "Noto Sans", "Segoe UI", "Noto Color Emoji", "Twemoji Mozilla", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", sans-serif;
      font-size: 18px;
      line-height: 1.35;
      letter-spacing: 0;
      word-spacing: 0;
      font-variant-ligatures: none;
    }

    .output-box {
      min-height: 140px;
      font-family: "Noto Sans", "Segoe UI", "Noto Color Emoji", "Twemoji Mozilla", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", sans-serif;
      font-size: 18px;
      line-height: 1.35;
      letter-spacing: 0;
      word-spacing: 0;
      font-variant-ligatures: none;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .examples {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .task-grid,
    .subtask-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .subtask-grid {
      margin-top: 8px;
      min-height: 40px;
    }

    .subtask-grid[hidden] {
      display: none !important;
    }

    .task-text-wrap[hidden] {
      display: none !important;
    }

    .task-text-wrap {
      margin-top: 8px;
      display: grid;
      gap: 6px;
    }

    .task-text-label {
      font-size: 14px;
      font-weight: 700;
    }

    .task-text {
      min-height: 72px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #fff;
      padding: 10px 12px;
      font-size: 16px;
      line-height: 1.35;
      letter-spacing: 0;
      word-spacing: 0;
      font-variant-ligatures: none;
    }

    .task-text p {
      margin: 0;
    }

    .task-text p + p {
      margin-top: 6px;
    }

    .tests-toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .test-list {
      display: grid;
      gap: 10px;
    }

    .test-item {
      border: 1px solid #dbeafe;
      background: #f8fafc;
      border-radius: 10px;
      padding: 10px;
      display: grid;
      gap: 8px;
    }

    .test-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }

    .test-label {
      font-size: 13px;
      font-weight: 800;
      color: #334155;
    }

    .test-output-grid {
      display: grid;
      gap: 10px;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
    }

    .test-output-card {
      border: 1px solid #e5e7eb;
      border-radius: 10px;
      background: #ffffff;
      padding: 10px;
      display: grid;
      gap: 8px;
    }

    .test-output-card.ok {
      border-color: #86efac;
      background: #f0fdf4;
    }

    .test-output-card.error {
      border-color: #fca5a5;
      background: #fef2f2;
    }

    .test-output-card.warn {
      border-color: #fcd34d;
      background: #fffbeb;
    }

    .test-output-meta {
      font-size: 12px;
      font-weight: 700;
      color: #475569;
    }

    button {
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #fff;
      color: var(--text);
      font: inherit;
      font-weight: 700;
      padding: 9px 12px;
      cursor: pointer;
      transition: 120ms ease;
    }

    button:hover {
      border-color: #9ca3af;
      transform: translateY(-1px);
    }

    button:disabled {
      opacity: 0.65;
      cursor: not-allowed;
      transform: none;
    }

    .switchers button[aria-pressed="true"] {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2);
    }

    .switchers button[aria-pressed="true"]:hover {
      background: var(--accent-strong);
      border-color: var(--accent-strong);
    }

    button.primary {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
    }

    button.primary:hover {
      background: var(--accent-strong);
      border-color: var(--accent-strong);
    }

    .status-box {
      border-radius: 10px;
      border: 1px solid var(--border);
      padding: 10px 12px;
      font-weight: 700;
      background: #f3f4f6;
      color: #1f2937;
      min-height: 44px;
      display: flex;
      align-items: center;
    }

    .status-box.ok {
      background: var(--ok-bg);
      color: var(--ok-fg);
      border-color: #86efac;
    }

    .status-box.error {
      background: var(--danger-bg);
      color: var(--danger-fg);
      border-color: #fca5a5;
    }

    .status-box.warn {
      background: var(--warn-bg);
      color: var(--warn-fg);
      border-color: #fcd34d;
    }

    .step-count {
      font-weight: 700;
      color: #1f2937;
      font-size: 14px;
    }

    .keyboard {
      display: grid;
      gap: 10px;
    }

    .keyboard-layout {
      display: grid;
      grid-template-columns: minmax(0, 1fr) 220px;
      gap: 10px;
      align-items: start;
    }

    .keyboard-left {
      display: grid;
      gap: 10px;
      min-width: 0;
    }

    .emoji-group {
      border: 1px solid #e5e7eb;
      border-radius: 10px;
      background: #fff;
      padding: 10px;
    }

    .emoji-group.group-1 { background: linear-gradient(180deg, #ffffff, #f8fafc); }
    .emoji-group.group-2 { background: linear-gradient(180deg, #ffffff, #f9fafb); }
    .emoji-group.group-3 { background: linear-gradient(180deg, #ffffff, #eff6ff); }

    .emoji-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(40px, 1fr));
      gap: 6px;
    }

    .emoji-btn {
      font-family: var(--emoji-font);
      font-size: 22px;
      line-height: 1;
      padding: 8px 6px;
      min-height: 40px;
      display: grid;
      place-items: center;
    }

    .editor-nav {
      border: 1px solid #d1d5db;
      border-radius: 10px;
      background: linear-gradient(180deg, #ffffff, #f8fafc);
      padding: 10px;
      display: grid;
      gap: 8px;
    }

    .nav-title {
      margin: 0;
      font-size: 12px;
      font-weight: 800;
      text-transform: uppercase;
      letter-spacing: 0.02em;
      color: #475569;
    }

    .nav-arrows {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      grid-template-areas:
        ". up ."
        "left down right";
      gap: 6px;
    }

    .nav-actions {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 6px;
    }

    .nav-btn {
      min-height: 42px;
      padding: 7px 8px;
      display: grid;
      place-items: center;
      font-weight: 800;
      border-radius: 10px;
      user-select: none;
    }

    .nav-btn.up { grid-area: up; }
    .nav-btn.left { grid-area: left; }
    .nav-btn.down { grid-area: down; }
    .nav-btn.right { grid-area: right; }
    .nav-btn.enter { grid-column: 1 / -1; }

    .vars-panel[hidden] {
      display: none !important;
    }

    @media (max-width: 1040px) {
      .switchers {
        grid-template-columns: 1fr;
      }

      .keyboard-layout {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <main class="app">
    <header class="topbar">
      <h1 class="title">Ğ­Ğ¼Ğ¾Ğ´Ğ·Ğ¸-Ğ¿Ñ€Ğ¾Ğ³Ñ€Ğ°Ğ¼Ğ¼Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ</h1>
      <a href="../index.html" class="back-link">ĞĞ° Ğ³Ğ»Ğ°Ğ²Ğ½ÑƒÑ</a>
    </header>

    <section class="blocks">
      <section class="panel">
        <h2 class="block-title"><span class="block-num">0</span>ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹ Ğ¸ Ğ—Ğ°Ğ´Ğ°Ğ½Ğ¸Ñ</h2>
        <div class="switchers">
          <section>
            <div class="mini-title">ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹</div>
            <div class="examples">
              <button id="example1Btn" type="button" aria-pressed="false">ĞŸÑ€Ğ¸Ğ¼ĞµÑ€ â„–1</button>
              <button id="example2Btn" type="button" aria-pressed="false">ĞŸÑ€Ğ¸Ğ¼ĞµÑ€ â„–2</button>
              <button id="example3Btn" type="button" aria-pressed="false">ĞŸÑ€Ğ¸Ğ¼ĞµÑ€ â„–3</button>
              <button id="example4Btn" type="button" aria-pressed="false">ĞŸÑ€Ğ¸Ğ¼ĞµÑ€ â„–4</button>
              <button id="example5Btn" type="button" aria-pressed="false">ĞŸÑ€Ğ¸Ğ¼ĞµÑ€ â„–5</button>
            </div>
          </section>
          <section>
            <div class="mini-title">Ğ—Ğ°Ğ´Ğ°Ğ½Ğ¸Ñ</div>
            <div id="taskButtons" class="task-grid">
              <button type="button" data-task="1" aria-pressed="false">Ğ—Ğ°Ğ´Ğ°Ğ½Ğ¸Ğµ 1</button>
              <button type="button" data-task="2" aria-pressed="false">Ğ—Ğ°Ğ´Ğ°Ğ½Ğ¸Ğµ 2</button>
              <button type="button" data-task="3" aria-pressed="false">Ğ—Ğ°Ğ´Ğ°Ğ½Ğ¸Ğµ 3</button>
              <button type="button" data-task="4" aria-pressed="false">Ğ—Ğ°Ğ´Ğ°Ğ½Ğ¸Ğµ 4</button>
            </div>
            <div id="taskSubtasks" class="subtask-grid" hidden></div>
            <section id="taskTextWrap" class="task-text-wrap" hidden>
              <div class="task-text-label">Ğ¢ĞµĞºÑÑ‚ Ğ·Ğ°Ğ´Ğ°Ğ½Ğ¸Ñ</div>
              <div id="taskText" class="task-text"></div>
            </section>
          </section>
        </div>
      </section>

      <section class="panel">
        <h2 class="block-title"><span class="block-num">1</span>Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¾Ñ€ ĞºĞ¾Ğ´Ğ°</h2>
        <label for="codeInput">ĞšĞ¾Ğ´</label>
        <div class="code-editor">
          <textarea id="codeLineNumbers" class="emoji-field code-lines" readonly tabindex="-1" aria-hidden="true">ğŸ“Œ</textarea>
          <textarea id="codeInput" class="emoji-field code-input" spellcheck="false" autocomplete="off" autocapitalize="off"></textarea>
        </div>
      </section>

      <section class="panel">
        <h2 class="block-title"><span class="block-num">2</span>ĞšĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ğ°</h2>
        <div id="emojiKeyboard" class="keyboard"></div>
      </section>

      <section class="panel">
        <h2 class="block-title"><span class="block-num">3</span>Ğ¢ĞµÑÑ‚Ñ‹</h2>
        <div class="tests-toolbar">
          <button id="addTestBtn" type="button">Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ñ‚ĞµÑÑ‚</button>
          <button id="resetTestsBtn" type="button">Ğ¡Ğ±Ñ€Ğ¾ÑĞ¸Ñ‚ÑŒ Ñ‚ĞµÑÑ‚Ñ‹</button>
        </div>
        <div id="testList" class="test-list"></div>
      </section>

      <section class="panel">
        <h2 class="block-title"><span class="block-num">4</span>Ğ—Ğ°Ğ¿ÑƒÑĞº</h2>
        <div class="controls">
          <button id="runBtn" class="primary">Ğ—Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ</button>
          <button id="resetBtn">Ğ¡Ğ±Ñ€Ğ¾Ñ</button>
        </div>
        <div id="statusBox" class="status-box">ĞĞ¶Ğ¸Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ·Ğ°Ğ¿ÑƒÑĞºĞ°.</div>
        <div id="stepCount" class="step-count">Ğ¡ÑƒĞ¼Ğ¼Ğ°Ñ€Ğ½Ñ‹Ğµ ÑˆĞ°Ğ³Ğ¸: 0</div>
      </section>

      <section class="panel">
        <h2 class="block-title"><span class="block-num">5</span>Ğ’Ñ‹Ñ…Ğ¾Ğ´Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¿Ğ¾ Ñ‚ĞµÑÑ‚Ğ°Ğ¼</h2>
        <div id="testOutputs" class="test-output-grid"></div>
      </section>

      <section id="codePhrasePanel" class="panel" hidden>
        <h2 class="block-title"><span class="block-num">6</span>ĞšĞ¾Ğ´Ğ¾Ğ²Ğ°Ñ Ñ„Ñ€Ğ°Ğ·Ğ°</h2>
        <label for="codePhraseInput">ĞšĞ¾Ğ´Ğ¾Ğ²Ğ°Ñ Ñ„Ñ€Ğ°Ğ·Ğ°</label>
        <input id="codePhraseInput" class="text-input" type="text" autocomplete="off" autocapitalize="off" spellcheck="false" placeholder="ĞšĞ¾Ğ´Ğ¾Ğ²Ğ°Ñ Ñ„Ñ€Ğ°Ğ·Ğ°" readonly>
        <div class="controls">
          <button id="copyCodePhraseBtn" type="button">ĞšĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ</button>
        </div>
      </section>
    </section>

    <section class="vars-panel" hidden>
      <h2>Ğ¡Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ñ…</h2>
      <div id="varsGrid"></div>
    </section>
  </main>

  <script>
    const COMMAND_EMOJIS = ["ğŸŒ", "â­", "ğŸ²", "ğŸ˜€", "â•", "â–", "âœ–", "â—", "â°", "ğŸ¤”", "ğŸ”‚", "ğŸ”", "ğŸ˜"];
    const VARIABLE_EMOJIS = [
      "ğŸ¶", "ğŸ±", "ğŸ­", "ğŸ¹", "ğŸ°", "ğŸ¦Š", "ğŸ»", "ğŸ¼", "ğŸ¨", "ğŸ¯", "ğŸ¦", "ğŸ®",
      "ğŸ•", "ğŸ•‘", "ğŸ•’", "ğŸ•“", "ğŸ•”", "ğŸ••", "ğŸ•–", "ğŸ•—", "ğŸ•˜", "ğŸ•™", "ğŸ•š", "ğŸ•›",
      "ğŸš¨"
    ];
    const DIGIT_EMOJIS = ["ğŸ†š", "ğŸ“Œ", "âœŒ", "ğŸ¤Ÿ", "ğŸ¤", "ğŸ–", "ğŸ¤˜", "ğŸ‘Œ", "ğŸ‘", "ğŸ‘Š"];
    const DIGIT_TO_VALUE = new Map(DIGIT_EMOJIS.map((emoji, idx) => [emoji, String(idx)]));

    const KEYBOARD_GROUPS = [COMMAND_EMOJIS, VARIABLE_EMOJIS, DIGIT_EMOJIS];

    const EXAMPLES = [
      {
        code: [
          "â­ğŸ¶",
          "ğŸ˜€ğŸ¶"
        ].join("\n"),
        tests: ["7", "42", "105"]
      },
      {
        code: [
          "â­ğŸ¶",
          "ğŸŒğŸ±âœŒ",
          "âœ–ğŸ¶ğŸ±",
          "ğŸŒğŸ­ğŸ“Œ",
          "â–ğŸ¶ğŸ­",
          "ğŸ˜€ğŸ¶"
        ].join("\n"),
        tests: ["10", "1", "55"]
      },
      {
        code: [
          "â­ğŸ¶",
          "ğŸŒğŸ±ğŸ“Œ",
          "ğŸ¤”ğŸ¶ğŸ±",
          "ğŸŒğŸ­ğŸ‘Š",
          "ğŸ˜€ğŸ­",
          "ğŸ˜"
        ].join("\n"),
        tests: ["1", "2", "0", "10", "37"]
      },
      {
        code: [
          "â­ğŸ¶",
          "ğŸŒğŸ±ğŸ†š",
          "ğŸŒğŸ­ğŸ“Œ",
          "ğŸ”‚ğŸ¶",
          "â•ğŸ±ğŸ¶",
          "â–ğŸ¶ğŸ­",
          "ğŸ˜",
          "ğŸ˜€ğŸ±"
        ].join("\n"),
        tests: ["1", "2", "4", "6", "8"]
      },
      {
        code: [
          "â­ğŸ¶",
          "ğŸŒğŸ±ğŸ†š",
          "ğŸŒğŸ­ğŸ†š",
          "ğŸŒğŸ¹ğŸ“Œ",
          "ğŸ”ğŸ­ğŸ¶",
          "â•ğŸ­ğŸ¹",
          "â•ğŸ±ğŸ­",
          "ğŸ˜",
          "ğŸ˜€ğŸ±"
        ].join("\n"),
        tests: ["0", "1", "3", "4", "7"]
      }
    ];

    const HARD_STEP_LIMIT = 200000;
    const YIELD_EVERY = 1500;
    const CODE_PHRASE_UNLOCK_RULES = Object.freeze({
      "2.1": Object.freeze({
        tests: Object.freeze(["1", "14", "27"]),
        outputs: Object.freeze(["5", "18", "31"]),
        seed: 1374772855,
        blob: Object.freeze([45291, 28554, 60224, 46832, 56516, 56824, 52380, 31333, 31764, 33038, 59126, 9155, 18990, 1010])
      }),
      "2.2": Object.freeze({
        tests: Object.freeze(["4", "8", "16"]),
        outputs: Object.freeze(["2", "4", "8"]),
        seed: 2049653837,
        blob: Object.freeze([31843, 22378, 44959, 52419, 13656, 46847, 46763, 16078, 32805, 3142, 23581, 58072])
      })
    });
    const TASK_SUBTASK_COUNTS = Object.freeze({
      "2": 2
    });
    const SUBTASK_PRESETS = Object.freeze({
      "1.1": {
        code: [
          "â­ğŸ¶",
          "ğŸ˜€ğŸ¶"
        ].join("\n"),
        tests: ["7", "42", "105"]
      },
      "1.2": {
        code: [
          "â­ğŸ¶",
          "ğŸŒğŸ±ğŸ“Œ",
          "â•ğŸ¶ğŸ±",
          "ğŸ˜€ğŸ¶"
        ].join("\n"),
        tests: ["0", "5", "99"]
      },
      "1.3": {
        code: [
          "â­ğŸ¶",
          "ğŸŒğŸ±ğŸ“Œ",
          "ğŸŒğŸ­ğŸ†š",
          "ğŸ¤”ğŸ¶ğŸ±",
          "ğŸŒğŸ­ğŸ‘Š",
          "ğŸ˜",
          "ğŸ˜€ğŸ­"
        ].join("\n"),
        tests: ["1", "2", "0"]
      },
      "1.4": {
        code: [
          "â­ğŸ¶",
          "ğŸŒğŸ±ğŸ†š",
          "ğŸŒğŸ­ğŸ“Œ",
          "ğŸ”‚ğŸ¶",
          "â•ğŸ±ğŸ¶",
          "â–ğŸ¶ğŸ­",
          "ğŸ˜",
          "ğŸ˜€ğŸ±"
        ].join("\n"),
        tests: ["1", "3", "5"]
      },
      "2.1": {
        code: "",
        tests: ["1", "14", "27"]
      },
      "2.2": {
        code: "",
        tests: ["4", "8", "16"]
      }
    });
    const SUBTASK_TEXTS = Object.freeze({
      "2.1": Object.freeze([
        "Ğ”Ğ»Ñ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ 1 Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ 5.",
        "Ğ”Ğ»Ñ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ 14 Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ 18.",
        "Ğ”Ğ»Ñ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ 27 Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ 31."
      ]),
      "2.2": Object.freeze([
        "Ğ”Ğ»Ñ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ 4 Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ 2.",
        "Ğ”Ğ»Ñ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ 8 Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ 4.",
        "Ğ”Ğ»Ñ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ 16 Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ 8."
      ])
    });

    const codeInputEl = document.getElementById("codeInput");
    const codeLineNumbersEl = document.getElementById("codeLineNumbers");
    const runBtn = document.getElementById("runBtn");
    const resetBtn = document.getElementById("resetBtn");
    const addTestBtn = document.getElementById("addTestBtn");
    const resetTestsBtn = document.getElementById("resetTestsBtn");
    const testListEl = document.getElementById("testList");
    const testOutputsEl = document.getElementById("testOutputs");
    const example1Btn = document.getElementById("example1Btn");
    const example2Btn = document.getElementById("example2Btn");
    const example3Btn = document.getElementById("example3Btn");
    const example4Btn = document.getElementById("example4Btn");
    const example5Btn = document.getElementById("example5Btn");
    const taskButtonsEl = document.getElementById("taskButtons");
    const taskSubtasksEl = document.getElementById("taskSubtasks");
    const taskTextWrapEl = document.getElementById("taskTextWrap");
    const taskTextEl = document.getElementById("taskText");
    const statusBoxEl = document.getElementById("statusBox");
    const stepCountEl = document.getElementById("stepCount");
    const emojiKeyboardEl = document.getElementById("emojiKeyboard");
    const codePhrasePanelEl = document.getElementById("codePhrasePanel");
    const codePhraseInputEl = document.getElementById("codePhraseInput");
    const copyCodePhraseBtn = document.getElementById("copyCodePhraseBtn");

    const VARIABLE_SET = new Set(VARIABLE_EMOJIS);
    const exampleButtons = [example1Btn, example2Btn, example3Btn, example4Btn, example5Btn];
    const taskButtons = Array.from(taskButtonsEl.querySelectorAll("[data-task]"));
    const GRAPHEME_SEGMENTER = (typeof Intl !== "undefined" && typeof Intl.Segmenter === "function")
      ? new Intl.Segmenter("ru", { granularity: "grapheme" })
      : null;
    let lastFocusedField = codeInputEl;
    let currentScenarioKey = "";
    let selectedExampleIndex = -1;
    let selectedTaskKey = "";
    let selectedSubtaskKey = "";
    let codeInputResizeObserver = null;

    function makeError(kind, line, message) {
      const err = new Error(message);
      err.kind = kind;
      err.line = line;
      return err;
    }

    function normalizeCodeLine(line) {
      return String(line || "").replace(/\uFE0F/g, "").replace(/\s+/g, "");
    }

    function requireVariable(symbol, line) {
      if (!VARIABLE_SET.has(symbol)) {
        throw makeError("parse", line, `ĞĞ¶Ğ¸Ğ´Ğ°Ğ»Ğ°ÑÑŒ Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ğ°Ñ, Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¾: ${symbol || "Ğ¿ÑƒÑÑ‚Ğ¾"}.`);
      }
      return symbol;
    }

    function parseEmojiNumber(emojis, line) {
      if (!emojis.length) {
        throw makeError("parse", line, "ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° ğŸŒ Ñ‚Ñ€ĞµĞ±ÑƒĞµÑ‚ Ñ…Ğ¾Ñ‚Ñ Ğ±Ñ‹ Ğ¾Ğ´Ğ½Ñƒ emoji-Ñ†Ğ¸Ñ„Ñ€Ñƒ.");
      }
      let valueText = "";
      for (let i = 0; i < emojis.length; i++) {
        const value = DIGIT_TO_VALUE.get(emojis[i]);
        if (typeof value !== "string") {
          throw makeError("parse", line, `ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ°Ñ emoji-Ñ†Ğ¸Ñ„Ñ€Ğ°: ${emojis[i]}.`);
        }
        valueText += value;
      }
      const numeric = Number(valueText);
      if (!Number.isFinite(numeric)) {
        throw makeError("parse", line, `Ğ§Ğ¸ÑĞ»Ğ¾ Ğ½Ğµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ñ€Ğ°ÑĞ¿Ğ¾Ğ·Ğ½Ğ°Ñ‚ÑŒ: ${valueText}.`);
      }
      return Math.trunc(numeric);
    }

    function toEmojiNumberText(value) {
      const safe = Math.max(0, Math.trunc(value));
      const text = String(safe);
      let out = "";
      for (let i = 0; i < text.length; i++) {
        const code = text.charCodeAt(i) - 48;
        if (code >= 0 && code <= 9) out += DIGIT_EMOJIS[code];
      }
      return out || DIGIT_EMOJIS[0];
    }

    function editorLineCount() {
      const source = String(codeInputEl.value || "").replace(/\r\n?/g, "\n");
      return source.split("\n").length;
    }

    function syncCodeLineNumbersScroll() {
      if (!codeLineNumbersEl) return;
      codeLineNumbersEl.scrollTop = codeInputEl.scrollTop;
    }

    function syncCodeLineNumbersHeight() {
      if (!codeLineNumbersEl) return;
      const nextHeight = codeInputEl.offsetHeight;
      if (nextHeight > 0) codeLineNumbersEl.style.height = `${nextHeight}px`;
    }

    function refreshCodeLineNumbers() {
      if (!codeLineNumbersEl) return;
      const lines = [];
      const total = editorLineCount();
      for (let i = 1; i <= total; i++) lines.push(toEmojiNumberText(i));
      const content = lines.join("\n");
      if (codeLineNumbersEl.value !== content) codeLineNumbersEl.value = content;
      syncCodeLineNumbersHeight();
      syncCodeLineNumbersScroll();
    }

    function parseProgram(source) {
      const lines = String(source || "").replace(/\r\n?/g, "\n").split("\n");
      const instructions = [];
      const blockStack = [];

      for (let idx = 0; idx < lines.length; idx++) {
        const lineNo = idx + 1;
        const compactLine = normalizeCodeLine(lines[idx]);
        if (!compactLine) continue;

        const tokens = Array.from(compactLine);
        const op = tokens[0];

        if (op === "ğŸŒ") {
          if (tokens.length < 3) {
            throw makeError("parse", lineNo, "ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° ğŸŒ Ñ‚Ñ€ĞµĞ±ÑƒĞµÑ‚ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚: ğŸŒ<Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ğ°Ñ><emoji-Ñ‡Ğ¸ÑĞ»Ğ¾>.");
          }
          const target = requireVariable(tokens[1], lineNo);
          const value = parseEmojiNumber(tokens.slice(2), lineNo);
          instructions.push({ type: "set", target, value, line: lineNo });
          continue;
        }

        if (op === "â­") {
          if (tokens.length !== 2) throw makeError("parse", lineNo, "ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° â­ Ñ‚Ñ€ĞµĞ±ÑƒĞµÑ‚ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚: â­<Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ğ°Ñ>.");
          instructions.push({ type: "readNumber", target: requireVariable(tokens[1], lineNo), line: lineNo });
          continue;
        }

        if (op === "ğŸ²") {
          if (tokens.length !== 4) throw makeError("parse", lineNo, "ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° ğŸ² Ñ‚Ñ€ĞµĞ±ÑƒĞµÑ‚ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚: ğŸ²<Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ğ°Ñ><lowVar><highVar>.");
          instructions.push({
            type: "random",
            target: requireVariable(tokens[1], lineNo),
            low: requireVariable(tokens[2], lineNo),
            high: requireVariable(tokens[3], lineNo),
            line: lineNo
          });
          continue;
        }

        if (op === "ğŸ˜€") {
          if (tokens.length !== 2) throw makeError("parse", lineNo, "ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° ğŸ˜€ Ñ‚Ñ€ĞµĞ±ÑƒĞµÑ‚ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚: ğŸ˜€<Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ğ°Ñ>.");
          instructions.push({ type: "printNumber", target: requireVariable(tokens[1], lineNo), line: lineNo });
          continue;
        }

        if (op === "â•" || op === "â–" || op === "âœ–" || op === "â—" || op === "â°") {
          if (tokens.length !== 3) {
            throw makeError("parse", lineNo, `ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° ${op} Ñ‚Ñ€ĞµĞ±ÑƒĞµÑ‚ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚: ${op}<Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ğ°Ñ><Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ğ°Ñ>.`);
          }
          instructions.push({
            type: "math",
            op,
            left: requireVariable(tokens[1], lineNo),
            right: requireVariable(tokens[2], lineNo),
            line: lineNo
          });
          continue;
        }

        if (op === "ğŸ¤”") {
          if (tokens.length !== 3) throw makeError("parse", lineNo, "ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° ğŸ¤” Ñ‚Ñ€ĞµĞ±ÑƒĞµÑ‚ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚: ğŸ¤”<Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ğ°Ñ><Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ğ°Ñ>.");
          instructions.push({
            type: "ifEq",
            left: requireVariable(tokens[1], lineNo),
            right: requireVariable(tokens[2], lineNo),
            jumpTo: -1,
            line: lineNo
          });
          blockStack.push({ type: "if", index: instructions.length - 1 });
          continue;
        }

        if (op === "ğŸ”‚") {
          if (tokens.length !== 2) throw makeError("parse", lineNo, "ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° ğŸ”‚ Ñ‚Ñ€ĞµĞ±ÑƒĞµÑ‚ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚: ğŸ”‚<Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ğ°Ñ>.");
          instructions.push({
            type: "loopCount",
            count: requireVariable(tokens[1], lineNo),
            jumpTo: -1,
            line: lineNo
          });
          blockStack.push({ type: "loopCount", index: instructions.length - 1 });
          continue;
        }

        if (op === "ğŸ”") {
          if (tokens.length !== 3) throw makeError("parse", lineNo, "ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° ğŸ” Ñ‚Ñ€ĞµĞ±ÑƒĞµÑ‚ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚: ğŸ”<Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ğ°Ñ><Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ğ°Ñ>.");
          instructions.push({
            type: "loopNeq",
            left: requireVariable(tokens[1], lineNo),
            right: requireVariable(tokens[2], lineNo),
            jumpTo: -1,
            line: lineNo
          });
          blockStack.push({ type: "loopNeq", index: instructions.length - 1 });
          continue;
        }

        if (op === "ğŸ˜") {
          if (tokens.length !== 1) throw makeError("parse", lineNo, "ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° ğŸ˜ Ğ½Ğµ Ğ¿Ñ€Ğ¸Ğ½Ğ¸Ğ¼Ğ°ĞµÑ‚ Ğ°Ñ€Ğ³ÑƒĞ¼ĞµĞ½Ñ‚Ñ‹.");
          if (!blockStack.length) throw makeError("parse", lineNo, "Ğ›Ğ¸ÑˆĞ½Ğ¸Ğ¹ ğŸ˜ Ğ±ĞµĞ· Ğ¾Ñ‚ĞºÑ€Ñ‹Ğ²Ğ°ÑÑ‰ĞµĞ³Ğ¾ ğŸ¤”, ğŸ”‚ Ğ¸Ğ»Ğ¸ ğŸ”.");
          const block = blockStack.pop();
          if (block.type === "if") {
            instructions.push({ type: "ifEnd", ifIndex: block.index, line: lineNo });
          } else if (block.type === "loopCount") {
            instructions.push({ type: "loopCountEnd", loopIndex: block.index, line: lineNo });
          } else {
            instructions.push({ type: "loopEnd", loopIndex: block.index, line: lineNo });
          }
          const endIndex = instructions.length - 1;
          instructions[block.index].jumpTo = endIndex + 1;
          continue;
        }

        throw makeError("parse", lineNo, `ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ°Ñ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ°: ${op}.`);
      }

      if (blockStack.length) {
        const firstBlock = blockStack[0];
        const firstUnclosed = instructions[firstBlock.index];
        const opener = firstBlock.type === "if" ? "ğŸ¤”" : (firstBlock.type === "loopCount" ? "ğŸ”‚" : "ğŸ”");
        throw makeError("parse", firstUnclosed.line, `Ğ‘Ğ»Ğ¾Ğº ${opener} Ğ½Ğµ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ¾Ğ¹ ğŸ˜.`);
      }

      return instructions;
    }

    function initialVariables() {
      const out = {};
      for (let i = 0; i < VARIABLE_EMOJIS.length; i++) out[VARIABLE_EMOJIS[i]] = 0;
      return out;
    }

    function assertFiniteNumber(value, line, context) {
      if (!Number.isFinite(value)) {
        throw makeError("runtime", line, `${context}: Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¾ Ğ½ĞµÑ‡Ğ¸ÑĞ»Ğ¾Ğ²Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ.`);
      }
      return Math.trunc(value);
    }

    function isAsciiDigit(ch) {
      return ch >= "0" && ch <= "9";
    }

    function readNextInputNumber(inputText, state, line) {
      let idx = state.index;
      while (idx < inputText.length && /\s/u.test(inputText[idx])) idx += 1;

      if (idx >= inputText.length) {
        throw makeError("runtime", line, "ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° â­ Ğ½Ğµ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ñ‡Ğ¸Ñ‚Ğ°Ñ‚ÑŒ Ğ¸Ğ· Ğ¿ÑƒÑÑ‚Ñ‹Ñ… Ğ²Ñ…Ğ¾Ğ´Ğ½Ñ‹Ñ… Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ….");
      }

      let valueText = "";
      while (idx < inputText.length && isAsciiDigit(inputText[idx])) {
        valueText += inputText[idx];
        idx += 1;
      }

      if (!valueText) {
        const got = inputText[idx];
        throw makeError("runtime", line, `ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° â­ Ğ¾Ğ¶Ğ¸Ğ´Ğ°ĞµÑ‚ Ñ‡Ğ¸ÑĞ»Ğ¾, Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¾: ${got}.`);
      }

      state.index = idx;
      const parsed = Number(valueText);
      return assertFiniteNumber(parsed, line, "ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° â­");
    }

    function setStatus(kind, message) {
      statusBoxEl.className = `status-box ${kind}`;
      statusBoxEl.textContent = message;
    }

    function formatLineOnlyError(err) {
      const line = err && Number.isInteger(err.line) ? err.line : 0;
      if (line > 0) return `ĞÑˆĞ¸Ğ±ĞºĞ° Ğ² ÑÑ‚Ñ€Ğ¾ĞºĞµ ${line}.`;
      return "ĞÑˆĞ¸Ğ±ĞºĞ°.";
    }

    function setPressedState(button, isPressed) {
      if (!button) return;
      button.setAttribute("aria-pressed", isPressed ? "true" : "false");
    }

    function syncExampleButtons() {
      for (let i = 0; i < exampleButtons.length; i++) {
        setPressedState(exampleButtons[i], i === selectedExampleIndex);
      }
    }

    function syncTaskButtons() {
      for (const btn of taskButtons) {
        const taskKey = String(btn.dataset.task || "");
        setPressedState(btn, taskKey === selectedTaskKey && selectedTaskKey !== "");
      }
    }

    function syncSubtaskButtons() {
      const subtaskButtons = Array.from(taskSubtasksEl.querySelectorAll("[data-subtask]"));
      for (const btn of subtaskButtons) {
        const key = String(btn.dataset.subtask || "");
        setPressedState(btn, key === selectedSubtaskKey && selectedSubtaskKey !== "");
      }
    }

    function setTaskText(subtaskKey) {
      if (!taskTextWrapEl || !taskTextEl) return;
      const raw = SUBTASK_TEXTS[subtaskKey];
      const lines = Array.isArray(raw)
        ? raw.map((item) => String(item || "").trim()).filter((item) => item.length > 0)
        : [];
      if (!lines.length) {
        taskTextEl.textContent = "";
        taskTextWrapEl.hidden = true;
        return;
      }
      taskTextEl.textContent = "";
      for (const line of lines) {
        const p = document.createElement("p");
        p.textContent = line;
        taskTextEl.appendChild(p);
      }
      taskTextWrapEl.hidden = false;
    }

    function applySubtaskPreset(subtaskKey) {
      const preset = SUBTASK_PRESETS[subtaskKey];
      if (!preset || typeof preset !== "object") return;
      codeInputEl.value = String(preset.code || "");
      refreshCodeLineNumbers();
      const tests = Array.isArray(preset.tests) && preset.tests.length ? preset.tests : [""];
      setTestsToUi(tests);
      resetResultPanels();
    }

    function selectSubtask(subtaskKey) {
      selectedSubtaskKey = subtaskKey;
      syncSubtaskButtons();
      setTaskText(subtaskKey);
      setScenarioKey(`task:${subtaskKey}`);
      applySubtaskPreset(subtaskKey);
    }

    function clearSubtasks() {
      selectedSubtaskKey = "";
      taskSubtasksEl.textContent = "";
      taskSubtasksEl.hidden = true;
      setTaskText("");
    }

    function renderSubtasks(taskKey) {
      taskSubtasksEl.textContent = "";
      const rawCount = TASK_SUBTASK_COUNTS[taskKey];
      const count = Number.isInteger(rawCount) && rawCount > 0 ? rawCount : 4;
      for (let i = 1; i <= count; i++) {
        const subtaskKey = `${taskKey}.${i}`;
        const btn = document.createElement("button");
        btn.type = "button";
        btn.dataset.subtask = subtaskKey;
        btn.setAttribute("aria-pressed", "false");
        btn.textContent = `ĞŸĞ¾Ğ´Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ° ${subtaskKey}`;
        btn.addEventListener("click", () => {
          selectSubtask(subtaskKey);
        });
        taskSubtasksEl.appendChild(btn);
      }
      taskSubtasksEl.hidden = false;
      syncSubtaskButtons();
    }

    function hideCodePhrasePanel() {
      if (!codePhrasePanelEl) return;
      codePhrasePanelEl.hidden = true;
      if (codePhraseInputEl) codePhraseInputEl.value = "";
    }

    function showCodePhrasePanel(phrase) {
      if (!codePhrasePanelEl || !codePhraseInputEl) return;
      const text = String(phrase || "");
      if (!text) {
        hideCodePhrasePanel();
        return;
      }
      codePhraseInputEl.value = text;
      codePhrasePanelEl.hidden = false;
    }

    function normalizeUnlockToken(value) {
      return String(value || "").trim();
    }

    function createRunNonce() {
      if (typeof crypto !== "undefined" && crypto && typeof crypto.getRandomValues === "function") {
        const bytes = new Uint32Array(2);
        crypto.getRandomValues(bytes);
        return `${Date.now().toString(36)}:${bytes[0].toString(36)}:${bytes[1].toString(36)}`;
      }
      return `${Date.now().toString(36)}:${Math.random().toString(36).slice(2)}`;
    }

    function hashTextFNV1a32(text) {
      const src = String(text || "");
      let hash = 0x811c9dc5;
      for (let i = 0; i < src.length; i++) {
        hash ^= src.charCodeAt(i);
        hash = Math.imul(hash, 0x01000193);
      }
      return (hash >>> 0).toString(16).padStart(8, "0");
    }

    function buildRunResultProof(nonce, testIndex, testInput, kind, value) {
      return hashTextFNV1a32([
        String(nonce || ""),
        String(testIndex),
        normalizeUnlockToken(testInput),
        String(kind || ""),
        normalizeUnlockToken(value)
      ].join("::"));
    }

    function makeUnlockProof(subtaskKey, tests, outputs) {
      return `${subtaskKey}::${tests.join("|")}::${outputs.join("|")}::LOVELACE`;
    }

    function deriveUnlockMasks(length, proof, seed) {
      let state = seed >>> 0;
      for (let i = 0; i < proof.length; i++) {
        state ^= proof.charCodeAt(i);
        state = (Math.imul((state + 0x9e3779b9) >>> 0, 1664525) + 1013904223) >>> 0;
      }

      const masks = [];
      for (let i = 0; i < length; i++) {
        state = (Math.imul((state ^ ((i + 1) * 0x45d9f3b)) >>> 0, 1597334677) + 12345) >>> 0;
        masks.push((state >>> 8) & 0xffff);
      }
      return masks;
    }

    function decodeUnlockPhrase(subtaskKey, rule) {
      if (!rule || !Array.isArray(rule.blob) || !rule.blob.length) return "";
      const proof = makeUnlockProof(subtaskKey, rule.tests, rule.outputs);
      const masks = deriveUnlockMasks(rule.blob.length, proof, rule.seed);
      let text = "";
      for (let i = 0; i < rule.blob.length; i++) {
        text += String.fromCharCode(rule.blob[i] ^ masks[i]);
      }
      return text;
    }

    function isCodePhraseSolved(subtaskKey, tests, results, runNonce) {
      const key = String(subtaskKey || "");
      const rule = CODE_PHRASE_UNLOCK_RULES[key];
      if (!rule) return false;
      if (!Array.isArray(tests) || !Array.isArray(results)) return false;
      if (!runNonce) return false;
      if (tests.length !== rule.tests.length) return false;
      if (results.length !== rule.outputs.length) return false;

      for (let i = 0; i < rule.tests.length; i++) {
        if (normalizeUnlockToken(tests[i]) !== rule.tests[i]) return false;
        const result = results[i];
        if (!result || result.kind !== "ok" || result.source !== "runtime") return false;
        const expectedProof = buildRunResultProof(runNonce, i, tests[i], result.kind, result.value);
        if (result.proof !== expectedProof) return false;
        if (normalizeUnlockToken(result.value) !== rule.outputs[i]) return false;
      }

      return true;
    }

    function setScenarioKey(key) {
      currentScenarioKey = String(key || "");
      hideCodePhrasePanel();
    }

    function resetResultPanels() {
      hideCodePhrasePanel();
      setStatus("", "ĞĞ¶Ğ¸Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ·Ğ°Ğ¿ÑƒÑĞºĞ°.");
      stepCountEl.textContent = "Ğ¡ÑƒĞ¼Ğ¼Ğ°Ñ€Ğ½Ñ‹Ğµ ÑˆĞ°Ğ³Ğ¸: 0";
      testOutputsEl.textContent = "";
    }

    function createTestItem(inputText = "") {
      const wrap = document.createElement("section");
      wrap.className = "test-item";

      const head = document.createElement("div");
      head.className = "test-head";

      const label = document.createElement("div");
      label.className = "test-label";
      label.dataset.testLabel = "1";

      const removeBtn = document.createElement("button");
      removeBtn.type = "button";
      removeBtn.textContent = "Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ";
      removeBtn.dataset.testRemove = "1";
      removeBtn.addEventListener("click", () => {
        wrap.remove();
        renumberTests();
        resetResultPanels();
      });

      head.appendChild(label);
      head.appendChild(removeBtn);

      const input = document.createElement("textarea");
      input.className = "stdin-input";
      input.spellcheck = false;
      input.autocomplete = "off";
      input.autocapitalize = "off";
      input.dataset.testInput = "1";
      input.value = String(inputText || "");

      wrap.appendChild(head);
      wrap.appendChild(input);
      return wrap;
    }

    function renumberTests() {
      const tests = Array.from(testListEl.querySelectorAll(".test-item"));
      if (!tests.length) {
        testListEl.appendChild(createTestItem(""));
        return renumberTests();
      }
      for (let i = 0; i < tests.length; i++) {
        const item = tests[i];
        const label = item.querySelector("[data-test-label]");
        const removeBtn = item.querySelector("[data-test-remove]");
        if (label) label.textContent = `Ğ¢ĞµÑÑ‚ ${i + 1}`;
        if (removeBtn) removeBtn.disabled = tests.length === 1;
      }
    }

    function getTestsFromUi() {
      const fields = Array.from(testListEl.querySelectorAll("[data-test-input]"));
      return fields.map((field) => String(field.value || ""));
    }

    function setTestsToUi(inputs) {
      testListEl.textContent = "";
      const list = Array.isArray(inputs) && inputs.length ? inputs : [""];
      for (const text of list) {
        testListEl.appendChild(createTestItem(text));
      }
      renumberTests();
    }

    function renderOutputs(results) {
      testOutputsEl.textContent = "";
      for (let i = 0; i < results.length; i++) {
        const result = results[i];
        const card = document.createElement("section");
        card.className = `test-output-card ${result.kind}`;

        const title = document.createElement("div");
        title.className = "test-label";
        title.textContent = `Ğ¢ĞµÑÑ‚ ${i + 1}`;

        const meta = document.createElement("div");
        meta.className = "test-output-meta";
        meta.textContent = result.meta;

        const out = document.createElement("textarea");
        out.className = "output-box";
        out.readOnly = true;
        out.value = result.value;

        card.appendChild(title);
        card.appendChild(meta);
        card.appendChild(out);
        testOutputsEl.appendChild(card);
      }
    }

    function initTaskPlaceholders() {
      syncExampleButtons();
      syncTaskButtons();
      clearSubtasks();

      for (const btn of taskButtons) {
        btn.addEventListener("click", () => {
          const taskKey = String(btn.dataset.task || "");
          if (!taskKey) return;
          selectedExampleIndex = -1;
          selectedTaskKey = taskKey;
          selectedSubtaskKey = "";
          syncExampleButtons();
          syncTaskButtons();
          renderSubtasks(taskKey);
          selectSubtask(`${taskKey}.1`);
        });
      }
    }

    async function executeProgram(instructions, inputText) {
      const vars = initialVariables();
      const normalizedInput = String(inputText || "");
      const inputState = { index: 0 };
      const loopCountState = new Map();
      let output = "";
      let pc = 0;
      let steps = 0;

      while (pc < instructions.length) {
        if (steps >= HARD_STEP_LIMIT) {
          return {
            status: "limit",
            message: `ĞŸÑ€ĞµĞ²Ñ‹ÑˆĞµĞ½ Ğ²Ğ½ÑƒÑ‚Ñ€ĞµĞ½Ğ½Ğ¸Ğ¹ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚ ÑˆĞ°Ğ³Ğ¾Ğ² (${HARD_STEP_LIMIT}).`,
            steps,
            output,
            vars
          };
        }

        const ins = instructions[pc];
        steps += 1;

        if (ins.type === "set") {
          vars[ins.target] = ins.value;
          pc += 1;
        } else if (ins.type === "readNumber") {
          vars[ins.target] = readNextInputNumber(normalizedInput, inputState, ins.line);
          pc += 1;
        } else if (ins.type === "random") {
          const low = assertFiniteNumber(vars[ins.low], ins.line, "ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° ğŸ² (Ğ½Ğ¸Ğ¶Ğ½ÑÑ Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ†Ğ°)");
          const high = assertFiniteNumber(vars[ins.high], ins.line, "ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° ğŸ² (Ğ²ĞµÑ€Ñ…Ğ½ÑÑ Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ†Ğ°)");
          if (low > high) {
            throw makeError("runtime", ins.line, `ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° ğŸ²: low (${low}) Ğ±Ğ¾Ğ»ÑŒÑˆĞµ high (${high}).`);
          }
          const value = low + Math.floor(Math.random() * (high - low + 1));
          vars[ins.target] = assertFiniteNumber(value, ins.line, "ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° ğŸ² (Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚)");
          pc += 1;
        } else if (ins.type === "printNumber") {
          const value = assertFiniteNumber(vars[ins.target], ins.line, "ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° ğŸ˜€");
          output += String(value);
          pc += 1;
        } else if (ins.type === "math") {
          const left = assertFiniteNumber(vars[ins.left], ins.line, `ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° ${ins.op}`);
          const right = assertFiniteNumber(vars[ins.right], ins.line, `ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° ${ins.op}`);
          let result = 0;

          if (ins.op === "â•") result = left + right;
          else if (ins.op === "â–") result = left - right;
          else if (ins.op === "âœ–") result = left * right;
          else if (ins.op === "â—") {
            if (right === 0) throw makeError("runtime", ins.line, "ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° â—: Ğ´ĞµĞ»ĞµĞ½Ğ¸Ğµ Ğ½Ğ° Ğ½Ğ¾Ğ»ÑŒ.");
            result = Math.trunc(left / right);
          } else if (ins.op === "â°") {
            if (right === 0) throw makeError("runtime", ins.line, "ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° â°: Ğ´ĞµĞ»ĞµĞ½Ğ¸Ğµ Ğ½Ğ° Ğ½Ğ¾Ğ»ÑŒ.");
            result = left % right;
          }

          vars[ins.left] = assertFiniteNumber(result, ins.line, `ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° ${ins.op}`);
          pc += 1;
        } else if (ins.type === "ifEq") {
          const left = assertFiniteNumber(vars[ins.left], ins.line, "ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° ğŸ¤”");
          const right = assertFiniteNumber(vars[ins.right], ins.line, "ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° ğŸ¤”");
          if (left === right) pc += 1;
          else pc = ins.jumpTo;
        } else if (ins.type === "loopCount") {
          if (!loopCountState.has(pc)) {
            const total = assertFiniteNumber(vars[ins.count], ins.line, "ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° ğŸ”‚");
            loopCountState.set(pc, total);
          }
          const remaining = loopCountState.get(pc);
          if (remaining > 0) {
            loopCountState.set(pc, remaining - 1);
            pc += 1;
          } else {
            loopCountState.delete(pc);
            pc = ins.jumpTo;
          }
        } else if (ins.type === "loopNeq") {
          const left = assertFiniteNumber(vars[ins.left], ins.line, "ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° ğŸ”");
          const right = assertFiniteNumber(vars[ins.right], ins.line, "ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° ğŸ”");
          if (left !== right) pc += 1;
          else pc = ins.jumpTo;
        } else if (ins.type === "ifEnd") {
          pc += 1;
        } else if (ins.type === "loopCountEnd") {
          pc = ins.loopIndex;
        } else if (ins.type === "loopEnd") {
          pc = ins.loopIndex;
        } else {
          throw makeError("runtime", ins.line, `ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ°Ñ Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞºÑ†Ğ¸Ñ Ñ‚Ğ¸Ğ¿Ğ° ${ins.type}.`);
        }

        if (steps % YIELD_EVERY === 0) {
          await new Promise((resolve) => setTimeout(resolve, 0));
        }
      }

      return {
        status: "ok",
        message: "Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¾.",
        steps,
        output,
        vars
      };
    }

    function updateFocusTarget(target) {
      if (target === codeInputEl) lastFocusedField = target;
    }

    function resolveInsertTarget() {
      if (lastFocusedField === codeInputEl) return lastFocusedField;
      return codeInputEl;
    }

    function insertEmoji(emoji) {
      const target = resolveInsertTarget();
      target.focus();
      const start = typeof target.selectionStart === "number" ? target.selectionStart : target.value.length;
      const end = typeof target.selectionEnd === "number" ? target.selectionEnd : target.value.length;
      target.setRangeText(emoji, start, end, "end");
      updateFocusTarget(target);
      if (target === codeInputEl) refreshCodeLineNumbers();
    }

    function focusCodeInput() {
      codeInputEl.focus();
      updateFocusTarget(codeInputEl);
      return codeInputEl;
    }

    function getSelectionRange(target) {
      const start = typeof target.selectionStart === "number" ? target.selectionStart : target.value.length;
      const end = typeof target.selectionEnd === "number" ? target.selectionEnd : start;
      return { start, end };
    }

    function findLineStart(text, pos) {
      if (pos <= 0) return 0;
      const idx = text.lastIndexOf("\n", pos - 1);
      return idx === -1 ? 0 : idx + 1;
    }

    function findLineEnd(text, pos) {
      const idx = text.indexOf("\n", pos);
      return idx === -1 ? text.length : idx;
    }

    function getGraphemeBoundaries(text) {
      const src = String(text || "");
      const boundaries = [0];
      if (!src.length) return boundaries;

      if (GRAPHEME_SEGMENTER) {
        const segments = GRAPHEME_SEGMENTER.segment(src);
        for (const item of segments) {
          const end = item.index + item.segment.length;
          if (end > boundaries[boundaries.length - 1]) boundaries.push(end);
        }
      } else {
        let idx = 0;
        for (const ch of src) {
          idx += ch.length;
          boundaries.push(idx);
        }
      }

      if (boundaries[boundaries.length - 1] !== src.length) boundaries.push(src.length);
      return boundaries;
    }

    function boundaryAtOrBefore(text, pos) {
      const src = String(text || "");
      const clamped = Math.max(0, Math.min(src.length, pos));
      const boundaries = getGraphemeBoundaries(src);
      let out = 0;
      for (let i = 0; i < boundaries.length; i++) {
        const b = boundaries[i];
        if (b <= clamped) out = b;
        else break;
      }
      return out;
    }

    function boundaryAtOrAfter(text, pos) {
      const src = String(text || "");
      const clamped = Math.max(0, Math.min(src.length, pos));
      const boundaries = getGraphemeBoundaries(src);
      for (let i = 0; i < boundaries.length; i++) {
        const b = boundaries[i];
        if (b >= clamped) return b;
      }
      return src.length;
    }

    function previousBoundary(text, pos) {
      const src = String(text || "");
      const clamped = Math.max(0, Math.min(src.length, pos));
      const boundaries = getGraphemeBoundaries(src);
      let out = 0;
      for (let i = 0; i < boundaries.length; i++) {
        const b = boundaries[i];
        if (b < clamped) out = b;
        else break;
      }
      return out;
    }

    function nextBoundary(text, pos) {
      const src = String(text || "");
      const clamped = Math.max(0, Math.min(src.length, pos));
      const boundaries = getGraphemeBoundaries(src);
      for (let i = 0; i < boundaries.length; i++) {
        const b = boundaries[i];
        if (b > clamped) return b;
      }
      return src.length;
    }

    function graphemeIndexAtPosition(text, pos) {
      const src = String(text || "");
      const clamped = Math.max(0, Math.min(src.length, pos));
      const boundaries = getGraphemeBoundaries(src);
      let idx = 0;
      for (let i = 0; i < boundaries.length; i++) {
        if (boundaries[i] <= clamped) idx = i;
        else break;
      }
      return idx;
    }

    function positionAtGraphemeIndex(text, index) {
      const boundaries = getGraphemeBoundaries(text);
      const safeIdx = Math.max(0, Math.min(index, boundaries.length - 1));
      return boundaries[safeIdx];
    }

    function graphemeRangeContaining(text, pos) {
      const src = String(text || "");
      if (!src.length) return { start: 0, end: 0 };
      const clamped = Math.max(0, Math.min(src.length - 1, pos));
      const boundaries = getGraphemeBoundaries(src);
      for (let i = 0; i < boundaries.length - 1; i++) {
        const start = boundaries[i];
        const end = boundaries[i + 1];
        if (clamped >= start && clamped < end) return { start, end };
      }
      const last = boundaries[boundaries.length - 1];
      return { start: last, end: last };
    }

    function moveCaretHorizontal(delta) {
      const target = focusCodeInput();
      const text = target.value;
      const { start, end } = getSelectionRange(target);
      let next = start;
      if (delta < 0) {
        if (start !== end) {
          next = boundaryAtOrBefore(text, Math.min(start, end));
        } else {
          next = previousBoundary(text, start);
        }
      } else {
        if (start !== end) {
          next = boundaryAtOrAfter(text, Math.max(start, end));
        } else {
          next = nextBoundary(text, end);
        }
      }
      target.setSelectionRange(next, next);
      updateFocusTarget(target);
    }

    function moveCaretVertical(delta) {
      const target = focusCodeInput();
      const text = target.value;
      const { start, end } = getSelectionRange(target);
      const base = delta < 0 ? Math.min(start, end) : Math.max(start, end);
      const currStart = findLineStart(text, base);
      const currEnd = findLineEnd(text, base);
      const currLine = text.slice(currStart, currEnd);
      const currRel = Math.max(0, Math.min(currLine.length, base - currStart));
      const currCol = graphemeIndexAtPosition(currLine, currRel);
      let next = base;

      if (delta < 0) {
        if (currStart === 0) {
          next = 0;
        } else {
          const prevEnd = currStart - 1;
          const prevStart = findLineStart(text, prevEnd);
          const prevLine = text.slice(prevStart, prevEnd);
          const prevRel = positionAtGraphemeIndex(prevLine, currCol);
          next = prevStart + prevRel;
        }
      } else {
        if (currEnd >= text.length) {
          next = text.length;
        } else {
          const nextStart = currEnd + 1;
          const nextEnd = findLineEnd(text, nextStart);
          const nextLine = text.slice(nextStart, nextEnd);
          const nextRel = positionAtGraphemeIndex(nextLine, currCol);
          next = nextStart + nextRel;
        }
      }

      target.setSelectionRange(next, next);
      updateFocusTarget(target);
    }

    function insertCodeText(text) {
      const target = focusCodeInput();
      const { start, end } = getSelectionRange(target);
      target.setRangeText(text, start, end, "end");
      updateFocusTarget(target);
      refreshCodeLineNumbers();
    }

    function backspaceInCodeInput() {
      const target = focusCodeInput();
      const text = target.value;
      const { start, end } = getSelectionRange(target);
      if (start !== end) {
        const delStart = boundaryAtOrBefore(text, Math.min(start, end));
        const delEnd = boundaryAtOrAfter(text, Math.max(start, end));
        target.setRangeText("", delStart, delEnd, "end");
      } else if (start > 0) {
        const range = graphemeRangeContaining(text, start - 1);
        target.setRangeText("", range.start, range.end, "end");
      }
      updateFocusTarget(target);
      refreshCodeLineNumbers();
    }

    function deleteInCodeInput() {
      const target = focusCodeInput();
      const text = target.value;
      const { start, end } = getSelectionRange(target);
      if (start !== end) {
        const delStart = boundaryAtOrBefore(text, Math.min(start, end));
        const delEnd = boundaryAtOrAfter(text, Math.max(start, end));
        target.setRangeText("", delStart, delEnd, "end");
      } else if (start < text.length) {
        const range = graphemeRangeContaining(text, start);
        target.setRangeText("", range.start, range.end, "end");
      }
      updateFocusTarget(target);
      refreshCodeLineNumbers();
    }

    function createNavButton(text, title, className, onClick) {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = `nav-btn ${className}`;
      btn.textContent = text;
      btn.title = title;
      btn.addEventListener("mousedown", (event) => {
        event.preventDefault();
      });
      btn.addEventListener("click", onClick);
      return btn;
    }

    function renderKeyboard() {
      emojiKeyboardEl.textContent = "";
      const layoutEl = document.createElement("div");
      layoutEl.className = "keyboard-layout";

      const leftEl = document.createElement("div");
      leftEl.className = "keyboard-left";

      for (let i = 0; i < KEYBOARD_GROUPS.length; i++) {
        const group = KEYBOARD_GROUPS[i];
        const groupEl = document.createElement("section");
        groupEl.className = `emoji-group group-${i + 1}`;

        const gridEl = document.createElement("div");
        gridEl.className = "emoji-grid";

        for (let j = 0; j < group.length; j++) {
          const emoji = group[j];
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "emoji-btn";
          btn.textContent = emoji;
          btn.title = `Ğ’ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ ${emoji}`;
          btn.addEventListener("mousedown", (event) => {
            event.preventDefault();
          });
          btn.addEventListener("click", () => {
            insertEmoji(emoji);
          });
          gridEl.appendChild(btn);
        }

        groupEl.appendChild(gridEl);
        leftEl.appendChild(groupEl);
      }

      const navEl = document.createElement("section");
      navEl.className = "editor-nav";

      const navTitleEl = document.createElement("p");
      navTitleEl.className = "nav-title";
      navTitleEl.textContent = "ĞĞ°Ğ²Ğ¸Ğ³Ğ°Ñ†Ğ¸Ñ";

      const arrowsEl = document.createElement("div");
      arrowsEl.className = "nav-arrows";
      arrowsEl.appendChild(createNavButton("â†‘", "Ğ¡Ñ‚Ñ€ĞµĞ»ĞºĞ° Ğ²Ğ²ĞµÑ€Ñ…", "up", () => moveCaretVertical(-1)));
      arrowsEl.appendChild(createNavButton("â†", "Ğ¡Ñ‚Ñ€ĞµĞ»ĞºĞ° Ğ²Ğ»ĞµĞ²Ğ¾", "left", () => moveCaretHorizontal(-1)));
      arrowsEl.appendChild(createNavButton("â†“", "Ğ¡Ñ‚Ñ€ĞµĞ»ĞºĞ° Ğ²Ğ½Ğ¸Ğ·", "down", () => moveCaretVertical(1)));
      arrowsEl.appendChild(createNavButton("â†’", "Ğ¡Ñ‚Ñ€ĞµĞ»ĞºĞ° Ğ²Ğ¿Ñ€Ğ°Ğ²Ğ¾", "right", () => moveCaretHorizontal(1)));

      const actionsEl = document.createElement("div");
      actionsEl.className = "nav-actions";
      actionsEl.appendChild(createNavButton("Enter", "Ğ’ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¿ĞµÑ€ĞµĞ½Ğ¾Ñ ÑÑ‚Ñ€Ğ¾ĞºĞ¸", "enter", () => insertCodeText("\n")));
      actionsEl.appendChild(createNavButton("Backspace", "Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ» ÑĞ»ĞµĞ²Ğ°", "backspace", () => backspaceInCodeInput()));
      actionsEl.appendChild(createNavButton("Delete", "Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ» ÑĞ¿Ñ€Ğ°Ğ²Ğ°", "delete", () => deleteInCodeInput()));

      navEl.appendChild(navTitleEl);
      navEl.appendChild(arrowsEl);
      navEl.appendChild(actionsEl);

      layoutEl.appendChild(leftEl);
      layoutEl.appendChild(navEl);
      emojiKeyboardEl.appendChild(layoutEl);
    }

    async function handleRun() {
      runBtn.disabled = true;
      hideCodePhrasePanel();
      setStatus("", "ĞŸĞ°Ñ€ÑĞ¸Ğ½Ğ³ Ğ¿Ñ€Ğ¾Ğ³Ñ€Ğ°Ğ¼Ğ¼Ñ‹...");
      stepCountEl.textContent = "Ğ¡ÑƒĞ¼Ğ¼Ğ°Ñ€Ğ½Ñ‹Ğµ ÑˆĞ°Ğ³Ğ¸: 0";
      const runNonce = createRunNonce();

      const tests = getTestsFromUi();
      const hasAtLeastOneTest = tests.length > 0;
      if (!hasAtLeastOneTest) {
        setTestsToUi([""]);
      }
      const safeTests = hasAtLeastOneTest ? tests : [""];

      let instructions = [];
      try {
        instructions = parseProgram(codeInputEl.value);
      } catch (err) {
        const msg = formatLineOnlyError(err);
        const failResults = safeTests.map(() => ({
          kind: "error",
          meta: "ĞÑˆĞ¸Ğ±ĞºĞ°",
          value: msg,
          source: "runtime",
          proof: ""
        }));
        renderOutputs(failResults);
        setStatus("error", msg);
        runBtn.disabled = false;
        return;
      }

      setStatus("", `Ğ˜Ğ½ÑÑ‚Ñ€ÑƒĞºÑ†Ğ¸Ğ¹: ${instructions.length}. Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ Ñ‚ĞµÑÑ‚Ğ¾Ğ²...`);

      const results = [];
      let totalSteps = 0;
      let okCount = 0;
      let warnCount = 0;
      let errCount = 0;

      for (let i = 0; i < safeTests.length; i++) {
        try {
          const result = await executeProgram(instructions, safeTests[i]);
          totalSteps += result.steps;
          if (result.status === "ok") {
            okCount += 1;
            results.push({
              kind: "ok",
              meta: `Ğ£ÑĞ¿ĞµÑ…. Ğ¨Ğ°Ğ³Ğ¸: ${result.steps}`,
              value: result.output,
              source: "runtime",
              proof: buildRunResultProof(runNonce, i, safeTests[i], "ok", result.output)
            });
          } else if (result.status === "limit") {
            warnCount += 1;
            results.push({
              kind: "warn",
              meta: `Ğ›Ğ¸Ğ¼Ğ¸Ñ‚ ÑˆĞ°Ğ³Ğ¾Ğ². Ğ¨Ğ°Ğ³Ğ¸: ${result.steps}`,
              value: result.output,
              source: "runtime",
              proof: buildRunResultProof(runNonce, i, safeTests[i], "warn", result.output)
            });
          } else {
            warnCount += 1;
            results.push({
              kind: "warn",
              meta: `ĞĞµĞ¾Ğ±Ñ‹Ñ‡Ğ½Ñ‹Ğ¹ ÑÑ‚Ğ°Ñ‚ÑƒÑ. Ğ¨Ğ°Ğ³Ğ¸: ${result.steps}`,
              value: result.output,
              source: "runtime",
              proof: buildRunResultProof(runNonce, i, safeTests[i], "warn", result.output)
            });
          }
        } catch (err) {
          errCount += 1;
          const msg = formatLineOnlyError(err);
          results.push({
            kind: "error",
            meta: "ĞÑˆĞ¸Ğ±ĞºĞ°",
            value: msg,
            source: "runtime",
            proof: buildRunResultProof(runNonce, i, safeTests[i], "error", msg)
          });
        }
      }

      renderOutputs(results);
      stepCountEl.textContent = `Ğ¡ÑƒĞ¼Ğ¼Ğ°Ñ€Ğ½Ñ‹Ğµ ÑˆĞ°Ğ³Ğ¸: ${totalSteps}`;
      if (errCount > 0) {
        setStatus("error", `Ğ“Ğ¾Ñ‚Ğ¾Ğ²Ğ¾: ÑƒÑĞ¿ĞµÑ… ${okCount}, Ğ¿Ñ€ĞµĞ´ÑƒĞ¿Ñ€ĞµĞ¶Ğ´ĞµĞ½Ğ¸Ñ ${warnCount}, Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸ ${errCount}.`);
      } else if (warnCount > 0) {
        setStatus("warn", `Ğ“Ğ¾Ñ‚Ğ¾Ğ²Ğ¾: ÑƒÑĞ¿ĞµÑ… ${okCount}, Ğ¿Ñ€ĞµĞ´ÑƒĞ¿Ñ€ĞµĞ¶Ğ´ĞµĞ½Ğ¸Ñ ${warnCount}.`);
      } else {
        setStatus("ok", `Ğ“Ğ¾Ñ‚Ğ¾Ğ²Ğ¾: Ğ²ÑĞµ ${okCount} Ñ‚ĞµÑÑ‚(Ğ°/Ğ¾Ğ²) Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ñ‹ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾.`);
      }

      if (selectedSubtaskKey && isCodePhraseSolved(selectedSubtaskKey, safeTests, results, runNonce)) {
        const rule = CODE_PHRASE_UNLOCK_RULES[selectedSubtaskKey];
        const phrase = decodeUnlockPhrase(selectedSubtaskKey, rule);
        showCodePhrasePanel(phrase);
      }

      runBtn.disabled = false;
    }

    function handleReset() {
      resetResultPanels();
    }

    function applyExample(index) {
      const item = EXAMPLES[index];
      if (!item) return;
      selectedExampleIndex = index;
      selectedTaskKey = "";
      syncExampleButtons();
      syncTaskButtons();
      clearSubtasks();
      codeInputEl.value = item.code;
      refreshCodeLineNumbers();
      setTestsToUi(item.tests);
      setScenarioKey(`example:${index + 1}`);
      codeInputEl.focus();
      updateFocusTarget(codeInputEl);
      resetResultPanels();
    }

    for (const el of [codeInputEl]) {
      el.addEventListener("focus", () => updateFocusTarget(el));
      el.addEventListener("click", () => updateFocusTarget(el));
      el.addEventListener("keyup", () => updateFocusTarget(el));
    }
    codeInputEl.addEventListener("input", refreshCodeLineNumbers);
    codeInputEl.addEventListener("scroll", syncCodeLineNumbersScroll);
    if (typeof ResizeObserver === "function") {
      codeInputResizeObserver = new ResizeObserver(() => {
        syncCodeLineNumbersHeight();
      });
      codeInputResizeObserver.observe(codeInputEl);
    } else {
      window.addEventListener("resize", syncCodeLineNumbersHeight);
    }

    runBtn.addEventListener("click", () => {
      handleRun();
    });
    resetBtn.addEventListener("click", handleReset);
    for (let i = 0; i < exampleButtons.length; i++) {
      exampleButtons[i].addEventListener("click", () => applyExample(i));
    }
    addTestBtn.addEventListener("click", () => {
      testListEl.appendChild(createTestItem(""));
      renumberTests();
      resetResultPanels();
    });
    resetTestsBtn.addEventListener("click", () => {
      setTestsToUi([""]);
      resetResultPanels();
    });
    if (copyCodePhraseBtn && codePhraseInputEl) {
      copyCodePhraseBtn.addEventListener("click", async () => {
        const text = String(codePhraseInputEl.value || "");
        if (!text) {
          setStatus("warn", "ĞšĞ¾Ğ´Ğ¾Ğ²Ğ°Ñ Ñ„Ñ€Ğ°Ğ·Ğ° Ğ¿ÑƒÑÑ‚Ğ°.");
          return;
        }
        try {
          await navigator.clipboard.writeText(text);
          setStatus("ok", "ĞšĞ¾Ğ´Ğ¾Ğ²Ğ°Ñ Ñ„Ñ€Ğ°Ğ·Ğ° ÑĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ°.");
        } catch (_) {
          codePhraseInputEl.focus();
          codePhraseInputEl.select();
          setStatus("warn", "ĞšĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ‡ĞµÑ€ĞµĞ· Ğ±ÑƒÑ„ĞµÑ€ Ğ½ĞµĞ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ¾. Ğ¢ĞµĞºÑÑ‚ Ğ²Ñ‹Ğ´ĞµĞ»ĞµĞ½ Ğ´Ğ»Ñ ĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ.");
        }
      });
    }

    renderKeyboard();
    initTaskPlaceholders();
    setTestsToUi([""]);
    setScenarioKey("");
    resetResultPanels();
    refreshCodeLineNumbers();
    codeInputEl.focus();
    updateFocusTarget(codeInputEl);
  </script>
</body>
</html>
