<!doctype html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22%3E%3Ctext y=%22.9em%22 font-size=%2290%22%3E%F0%9F%A7%91%E2%80%8D%F0%9F%94%AC%3C/text%3E%3C/svg%3E">
  <script src="../../section-auth.js"></script>
  <script>window.SectionAuth && window.SectionAuth.guardPage("DEV");</script>
  <title>Матрица 1-0: попытка решения</title>
  <style>
    :root {
      --ui-scale: 1.35;
      --bg: #f3f4f6;
      --panel: #ffffff;
      --text: #111827;
      --muted: #6b7280;
      --border: #d1d5db;
      --accent: #0f766e;
      --accent-strong: #115e59;
      --ok: #166534;
      --ok-bg: #dcfce7;
      --warn: #92400e;
      --warn-bg: #fef3c7;
      --cell-size: calc(42px * var(--ui-scale));
      --gap: calc(6px * var(--ui-scale));
      --coord-size: calc(var(--cell-size) + 4px);
      --zero: #ffffff;
      --one: #111827;
    }

    * { box-sizing: border-box; }
    [hidden] { display: none !important; }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: "Segoe UI", "Noto Sans", sans-serif;
      background: radial-gradient(circle at 20% 0%, #ffffff, var(--bg));
      color: var(--text);
      font-size: calc(16px * var(--ui-scale));
      display: grid;
      place-items: center;
      padding: 20px;
    }

    .app {
      width: min(1280px, 100%);
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 16px;
      box-shadow: 0 14px 30px rgba(17, 24, 39, 0.09);
      padding: 16px;
      display: grid;
      gap: 14px;
    }

    .toolbar {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 8px;
    }

    button {
      border: 1px solid var(--border);
      background: #fff;
      color: var(--text);
      border-radius: 10px;
      padding: 8px 12px;
      font: inherit;
      cursor: pointer;
      transition: 120ms ease;
    }

    button:hover {
      transform: translateY(-1px);
      border-color: #9ca3af;
    }

    button.primary {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
    }

    button.primary:hover {
      background: var(--accent-strong);
      border-color: var(--accent-strong);
    }

    button:disabled {
      opacity: 0.55;
      cursor: not-allowed;
      transform: none;
    }

    input[type="password"] {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 8px 10px;
      font: inherit;
      min-width: 220px;
    }

    .counter {
      font-weight: 700;
      margin-left: auto;
      padding: 8px 12px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #fff;
    }

    .status {
      border-radius: 10px;
      padding: 9px 12px;
      font-weight: 600;
    }

    .status.ok {
      color: var(--ok);
      background: var(--ok-bg);
      border: 1px solid #86efac;
    }

    .status.progress {
      color: var(--warn);
      background: var(--warn-bg);
      border: 1px solid #fcd34d;
    }

    .codeword {
      border: 1px dashed #86efac;
      border-radius: 10px;
      padding: 9px 12px;
      background: #f0fdf4;
      color: #166534;
      font-weight: 700;
    }

    .auth {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: #fcfcfd;
      padding: 14px;
      display: grid;
      gap: 10px;
      align-content: start;
    }

    .auth-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .auth-error {
      min-height: 20px;
      font-size: calc(12px * var(--ui-scale));
      color: #b91c1c;
      font-weight: 600;
    }

    .grid-wrap {
      overflow: auto;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: #fafafa;
      padding: 12px;
      min-height: 300px;
    }

    .game-layout {
      display: grid;
      gap: 12px;
      grid-template-columns: 1fr 290px;
      align-items: start;
    }

    .side {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: #fcfcfd;
      padding: 10px;
      display: grid;
      gap: 8px;
      align-content: start;
      min-height: 300px;
    }

    .side h3 {
      margin: 0;
      font-size: calc(15px * var(--ui-scale));
    }

    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: calc(12px * var(--ui-scale));
      background: #f3f4f6;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      padding: 8px;
      white-space: pre-wrap;
      word-break: break-word;
      max-height: calc(300px * var(--ui-scale));
      overflow: auto;
    }

    .board {
      width: max-content;
      margin: 0 auto;
      display: grid;
      gap: var(--gap);
    }

    .coords-top {
      display: grid;
      gap: var(--gap);
      margin-left: calc(var(--coord-size) + var(--gap));
    }

    .board-main {
      display: grid;
      grid-template-columns: var(--coord-size) auto;
      gap: var(--gap);
      align-items: start;
    }

    .coords-left {
      display: grid;
      gap: var(--gap);
      width: var(--coord-size);
    }

    .coord {
      width: var(--cell-size);
      height: var(--cell-size);
      color: #374151;
      display: grid;
      place-items: center;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 13px;
      font-weight: 700;
      user-select: none;
    }

    .coords-left .coord {
      width: var(--coord-size);
    }

    .grid {
      display: grid;
      gap: var(--gap);
      width: max-content;
      margin: 0;
    }

    .cell {
      width: var(--cell-size);
      height: var(--cell-size);
      border-radius: 9px;
      border: 1px solid #9ca3af;
      background: var(--zero);
      color: #111827;
      display: grid;
      place-items: center;
      font-weight: 700;
      cursor: pointer;
      transition: 100ms ease;
      user-select: none;
    }

    .cell:hover {
      transform: scale(1.03);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
    }

    .cell.one {
      background: var(--one);
      color: #fff;
      border-color: #111827;
    }

    .error {
      background: #fee2e2;
      color: #991b1b;
      border: 1px solid #fca5a5;
      border-radius: 10px;
      padding: 10px 12px;
      font-weight: 600;
    }

    @media (max-width: 760px) {
      :root {
        --cell-size: calc(36px * var(--ui-scale));
        --gap: calc(5px * var(--ui-scale));
      }
      .counter {
        margin-left: 0;
      }
    }
  </style>
</head>
<body>
  <main class="app" id="app">
    <section id="authGate" class="auth" hidden>
      <div><b>Задача защищена паролем.</b> Введите пароль из редактора.</div>
      <div class="auth-row">
        <input id="passwordInput" type="password" placeholder="Пароль">
        <button id="unlock" class="primary">Открыть задачу</button>
      </div>
      <div id="authError" class="auth-error"></div>
    </section>

    <div id="gameArea" hidden>
      <section class="toolbar">
        <button id="restart" class="primary">Заново</button>
        <button id="undo">Отменить</button>
        <button id="redo">Повторить</button>
        <div class="counter" id="stepCounter">Шаги: 0</div>
      </section>

      <div id="status" class="status progress">В процессе</div>
      <div id="codeWordBox" class="codeword" hidden></div>
      <section class="game-layout">
        <div class="grid-wrap">
          <div class="board" aria-label="Поле задачи">
            <div id="colCoords" class="coords-top"></div>
            <div class="board-main">
              <div id="rowCoords" class="coords-left"></div>
              <div id="grid" class="grid"></div>
            </div>
          </div>
        </div>
        <aside class="side">
          <h3>Журнал ходов</h3>
          <div id="movesLog" class="mono">-</div>
        </aside>
      </section>
    </div>
  </main>

  <script>
    const URL_CIPHER_KEY = "matrix-1-0-lite-key";

    const appEl = document.getElementById("app");
    const authGateEl = document.getElementById("authGate");
    const gameAreaEl = document.getElementById("gameArea");
    const passwordInputEl = document.getElementById("passwordInput");
    const unlockBtn = document.getElementById("unlock");
    const authErrorEl = document.getElementById("authError");
    const restartBtn = document.getElementById("restart");
    const undoBtn = document.getElementById("undo");
    const redoBtn = document.getElementById("redo");
    const stepCounterEl = document.getElementById("stepCounter");
    const statusEl = document.getElementById("status");
    const codeWordBoxEl = document.getElementById("codeWordBox");
    const colCoordsEl = document.getElementById("colCoords");
    const rowCoordsEl = document.getElementById("rowCoords");
    const gridEl = document.getElementById("grid");
    const movesLogEl = document.getElementById("movesLog");

    let n = 0;
    let initialBoard = [];
    let board = [];
    let history = [];
    let historyIndex = 0;
    let requiresPassword = false;
    let authSalt = 0;
    let authHash = 0;
    let revealCodeWord = "";
    let codeWordCipher = null;
    let codeWordCipherSalt = 0;
    let codeWordCipherCheck = 0;
    let codeWordKey32 = 0;
    let codeWordKeyReady = false;

    function decodeBase64Url(str) {
      const padded = str.replace(/-/g, "+").replace(/_/g, "/") + "===".slice((str.length + 3) % 4);
      const bin = atob(padded);
      const out = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; i++) out[i] = bin.charCodeAt(i);
      return out;
    }

    function obfuscateBytes(bytes, keyText) {
      const key = new TextEncoder().encode(keyText);
      const out = new Uint8Array(bytes.length);
      for (let i = 0; i < bytes.length; i++) {
        out[i] = bytes[i] ^ key[i % key.length] ^ ((i * 31) & 255);
      }
      return out;
    }

    function readUint32LE(bytes, offset) {
      return (
        (bytes[offset]) |
        (bytes[offset + 1] << 8) |
        (bytes[offset + 2] << 16) |
        (bytes[offset + 3] << 24)
      ) >>> 0;
    }

    function passwordHash32(password, salt32) {
      const data = new TextEncoder().encode(password);
      let h = (0x811c9dc5 ^ salt32) >>> 0;
      for (let i = 0; i < data.length; i++) {
        h ^= data[i];
        h = Math.imul(h, 0x01000193) >>> 0;
        h ^= h >>> 13;
      }
      h ^= data.length >>> 0;
      h = Math.imul(h, 0x85ebca6b) >>> 0;
      h ^= h >>> 16;
      return h >>> 0;
    }

    function hashBytes32(bytes, salt32) {
      let h = (0x811c9dc5 ^ salt32) >>> 0;
      for (let i = 0; i < bytes.length; i++) {
        h ^= bytes[i];
        h = Math.imul(h, 0x01000193) >>> 0;
        h ^= h >>> 13;
      }
      h ^= bytes.length >>> 0;
      h = Math.imul(h, 0x85ebca6b) >>> 0;
      h ^= h >>> 16;
      return h >>> 0;
    }

    function xorWithStream(bytes, seed32) {
      let s = (seed32 ^ 0x9e3779b9) >>> 0;
      const out = new Uint8Array(bytes.length);
      for (let i = 0; i < bytes.length; i++) {
        s ^= (s << 13) >>> 0;
        s ^= s >>> 17;
        s ^= (s << 5) >>> 0;
        out[i] = bytes[i] ^ (s & 255);
      }
      return out;
    }

    function tryDecryptCodeWord() {
      if (!codeWordCipher || !codeWordKeyReady) return "";
      const plain = xorWithStream(codeWordCipher, codeWordKey32);
      const check = hashBytes32(plain, (codeWordCipherSalt ^ 0x9e3779b9) >>> 0);
      if (check !== codeWordCipherCheck) return "";
      try {
        return new TextDecoder().decode(plain);
      } catch (_) {
        return "";
      }
    }

    function copyBoard(src) {
      return src.map((row) => row.slice());
    }

    function isUniform(srcBoard) {
      const bit = srcBoard[0][0];
      for (let r = 0; r < srcBoard.length; r++) {
        for (let c = 0; c < srcBoard.length; c++) {
          if (srcBoard[r][c] !== bit) return false;
        }
      }
      return true;
    }

    function targetBit(srcBoard) {
      return srcBoard[0][0];
    }

    function bin3(v) {
      return v.toString(2).padStart(3, "0").slice(-3);
    }

    function moveCode6(move) {
      return `${bin3(move.r)}${bin3(move.c)}`;
    }

    function renderCoords() {
      colCoordsEl.style.gridTemplateColumns = `repeat(${n}, var(--cell-size))`;
      rowCoordsEl.style.gridTemplateRows = `repeat(${n}, var(--cell-size))`;
      colCoordsEl.innerHTML = "";
      rowCoordsEl.innerHTML = "";

      for (let c = 0; c < n; c++) {
        const el = document.createElement("div");
        el.className = "coord";
        el.textContent = bin3(c);
        el.title = `Столбец ${c}`;
        colCoordsEl.appendChild(el);
      }

      for (let r = 0; r < n; r++) {
        const el = document.createElement("div");
        el.className = "coord";
        el.textContent = bin3(r);
        el.title = `Строка ${r}`;
        rowCoordsEl.appendChild(el);
      }
    }

    function toggleCell(r, c) {
      if (r < 0 || r >= n || c < 0 || c >= n) return;
      board[r][c] = board[r][c] ^ 1;
    }

    function applyMove(r, c) {
      for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
          toggleCell(r + dr, c + dc);
        }
      }
    }

    function updateStatus() {
      const solved = isUniform(board);
      if (solved && !revealCodeWord && codeWordCipher) {
        revealCodeWord = tryDecryptCodeWord();
      }
      statusEl.className = `status ${solved ? "ok" : "progress"}`;
      statusEl.textContent = solved
        ? `Решено: все ${targetBit(board)}`
        : "В процессе";
      if (solved && revealCodeWord) {
        codeWordBoxEl.hidden = false;
        codeWordBoxEl.textContent = `Кодовое слово: ${revealCodeWord}`;
      } else {
        codeWordBoxEl.hidden = true;
        codeWordBoxEl.textContent = "";
      }
      stepCounterEl.textContent = `Шаги: ${historyIndex}`;
      undoBtn.disabled = historyIndex === 0;
      redoBtn.disabled = historyIndex >= history.length;
    }

    function updateMovesLog() {
      if (!movesLogEl) return;
      if (historyIndex <= 0) {
        movesLogEl.textContent = "-";
        return;
      }
      const lines = [];
      for (let i = 0; i < historyIndex; i++) {
        lines.push(`${String(i + 1).padStart(3, " ")}. ${moveCode6(history[i])}`);
      }
      movesLogEl.textContent = lines.join("\n");
    }

    function renderGrid() {
      gridEl.style.gridTemplateColumns = `repeat(${n}, var(--cell-size))`;
      gridEl.innerHTML = "";

      for (let r = 0; r < n; r++) {
        for (let c = 0; c < n; c++) {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = `cell ${board[r][c] ? "one" : ""}`;
          btn.textContent = String(board[r][c]);
          btn.setAttribute("aria-label", `Ячейка ${r + 1}-${c + 1}: ${board[r][c]}`);
          btn.addEventListener("click", () => {
            if (historyIndex < history.length) {
              history = history.slice(0, historyIndex);
            }
            applyMove(r, c);
            history.push({ r, c });
            historyIndex++;
            render();
          });
          gridEl.appendChild(btn);
        }
      }
    }

    function render() {
      renderCoords();
      renderGrid();
      updateStatus();
      updateMovesLog();
    }

    function parseCompactPayload(raw) {
      if (raw.length < 4) throw new Error("Слишком короткий payload.");
      const version = raw[0];
      if (version !== 2 && version !== 3 && version !== 4 && version !== 5) throw new Error("Не compact payload.");

      const parsedN = raw[1];
      if (!Number.isInteger(parsedN) || parsedN < 2 || parsedN > 20) {
        throw new Error("Некорректный размер поля.");
      }

      const total = parsedN * parsedN;
      const bitsBytes = Math.ceil(total / 8);
      const need = 4 + bitsBytes + (version >= 3 ? 8 : 0);
      if (raw.length < need) throw new Error("Неполный payload.");

      const parsedBoard = [];
      let k = 0;
      for (let r = 0; r < parsedN; r++) {
        const row = [];
        for (let c = 0; c < parsedN; c++) {
          const bit = (raw[4 + (k >>> 3)] >>> (k & 7)) & 1;
          row.push(bit);
          k++;
        }
        parsedBoard.push(row);
      }

      if (isUniform(parsedBoard)) {
        throw new Error("Задача уже решена, нужен нерешенный старт.");
      }

      n = parsedN;
      initialBoard = copyBoard(parsedBoard);
      board = copyBoard(parsedBoard);
      history = [];
      historyIndex = 0;
      requiresPassword = false;
      authSalt = 0;
      authHash = 0;
      revealCodeWord = "";
      codeWordCipher = null;
      codeWordCipherSalt = 0;
      codeWordCipherCheck = 0;
      codeWordKey32 = 0;
      codeWordKeyReady = false;

      const cellSize = raw[2];
      const gap = raw[3];
      if (cellSize > 0) {
        const cs = Math.max(22, Math.min(60, Math.floor(Number(cellSize))));
        document.documentElement.style.setProperty("--cell-size", `${cs}px`);
      }
      if (gap > 0) {
        const g = Math.max(2, Math.min(12, Math.floor(Number(gap))));
        document.documentElement.style.setProperty("--gap", `${g}px`);
      }

      if (version >= 3) {
        let tailOffset = 4 + bitsBytes;
        authSalt = readUint32LE(raw, tailOffset);
        authHash = readUint32LE(raw, tailOffset + 4);
        requiresPassword = true;
        tailOffset += 8;

        if (version === 4) {
          if (raw.length < tailOffset + 1) throw new Error("Неполный payload (code word).");
          const wordLen = raw[tailOffset];
          if (raw.length < tailOffset + 1 + wordLen) throw new Error("Неполный payload (code word bytes).");
          revealCodeWord = new TextDecoder().decode(raw.subarray(tailOffset + 1, tailOffset + 1 + wordLen));
        } else if (version === 5) {
          if (raw.length < tailOffset + 9) throw new Error("Неполный payload (encrypted code word).");
          codeWordCipherSalt = readUint32LE(raw, tailOffset);
          codeWordCipherCheck = readUint32LE(raw, tailOffset + 4);
          const wordLen = raw[tailOffset + 8];
          if (raw.length < tailOffset + 9 + wordLen) throw new Error("Неполный payload (encrypted code bytes).");
          codeWordCipher = raw.slice(tailOffset + 9, tailOffset + 9 + wordLen);
        }
      }
    }

    function parseLegacyPayload(raw) {
      const payload = JSON.parse(new TextDecoder().decode(raw));

      if (!payload || payload.v !== 1 || payload.rule !== "moore-9") {
        throw new Error("Неподдерживаемый формат задачи.");
      }

      const parsedN = Number(payload.n);
      if (!Number.isInteger(parsedN) || parsedN < 2 || parsedN > 20) {
        throw new Error("Некорректный размер поля.");
      }

      if (typeof payload.cells !== "string" || payload.cells.length !== parsedN * parsedN) {
        throw new Error("Некорректные данные клеток.");
      }

      const parsedBoard = [];
      let k = 0;
      for (let r = 0; r < parsedN; r++) {
        const row = [];
        for (let c = 0; c < parsedN; c++) {
          const ch = payload.cells[k++];
          if (ch !== "0" && ch !== "1") throw new Error("Недопустимые значения клеток.");
          row.push(ch === "1" ? 1 : 0);
        }
        parsedBoard.push(row);
      }

      if (isUniform(parsedBoard)) {
        throw new Error("Задача уже решена, нужен нерешенный старт.");
      }

      n = parsedN;
      initialBoard = copyBoard(parsedBoard);
      board = copyBoard(parsedBoard);
      history = [];
      historyIndex = 0;
      requiresPassword = false;
      authSalt = 0;
      authHash = 0;
      revealCodeWord = typeof payload.codeWord === "string" ? payload.codeWord : "";
      codeWordCipher = null;
      codeWordCipherSalt = 0;
      codeWordCipherCheck = 0;
      codeWordKey32 = 0;
      codeWordKeyReady = false;
      if (payload.ui && Number.isFinite(payload.ui.cellSize)) {
        const cs = Math.max(22, Math.min(60, Math.floor(Number(payload.ui.cellSize))));
        document.documentElement.style.setProperty("--cell-size", `${cs}px`);
      }
      if (payload.ui && Number.isFinite(payload.ui.gap)) {
        const g = Math.max(2, Math.min(12, Math.floor(Number(payload.ui.gap))));
        document.documentElement.style.setProperty("--gap", `${g}px`);
      }
    }

    function loadPayloadFromUrl() {
      const params = new URLSearchParams(window.location.search);
      const token = params.get("h") || params.get("p");
      if (!token) {
        throw new Error("В URL нет параметра h/p с задачей.");
      }

      const mixed = decodeBase64Url(token);
      const raw = obfuscateBytes(mixed, URL_CIPHER_KEY);
      if (raw[0] === 2 || raw[0] === 3 || raw[0] === 4 || raw[0] === 5) {
        parseCompactPayload(raw);
      } else {
        parseLegacyPayload(raw);
      }
    }

    restartBtn.addEventListener("click", () => {
      board = copyBoard(initialBoard);
      history = [];
      historyIndex = 0;
      render();
    });

    undoBtn.addEventListener("click", () => {
      if (historyIndex <= 0) return;
      const move = history[historyIndex - 1];
      applyMove(move.r, move.c);
      historyIndex--;
      render();
    });

    redoBtn.addEventListener("click", () => {
      if (historyIndex >= history.length) return;
      const move = history[historyIndex];
      applyMove(move.r, move.c);
      historyIndex++;
      render();
    });

    unlockBtn.addEventListener("click", () => {
      const entered = passwordInputEl.value;
      const got = passwordHash32(entered, authSalt);
      if (got !== authHash) {
        authErrorEl.textContent = "Неверный пароль.";
        passwordInputEl.select();
        return;
      }
      codeWordKey32 = passwordHash32(`${entered}|cw`, codeWordCipherSalt);
      codeWordKeyReady = true;
      authErrorEl.textContent = "";
      passwordInputEl.value = "";
      authGateEl.remove();
      gameAreaEl.hidden = false;
      render();
    });

    passwordInputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter") unlockBtn.click();
    });

    try {
      loadPayloadFromUrl();
      authGateEl.hidden = true;
      gameAreaEl.hidden = false;
      render();
    } catch (err) {
      appEl.innerHTML = `<div class="error">Ошибка загрузки задачи: ${String(err.message || err)}</div>`;
    }
  </script>
</body>
</html>
